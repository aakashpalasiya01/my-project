/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rx";
exports.ids = ["vendor-chunks/rx"];
exports.modules = {

/***/ "(ssr)/./node_modules/rx/dist/rx.aggregates.js":
/*!***********************************************!*\
  !*** ./node_modules/rx/dist/rx.aggregates.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // References\n    var Observable = Rx.Observable, observableProto = Observable.prototype, BinaryDisposable = Rx.BinaryDisposable, AnonymousObservable = Rx.AnonymousObservable, AbstractObserver = Rx.internals.AbstractObserver, disposableEmpty = Rx.Disposable.empty, helpers = Rx.helpers, defaultComparer = helpers.defaultComparer, identity = helpers.identity, defaultSubComparer = helpers.defaultSubComparer, isFunction = helpers.isFunction, isPromise = helpers.isPromise, isArrayLike = helpers.isArrayLike, isIterable = helpers.isIterable, inherits = Rx.internals.inherits, observableFromPromise = Observable.fromPromise, observableFrom = Observable.from, bindCallback = Rx.internals.bindCallback, EmptyError = Rx.EmptyError, ObservableBase = Rx.ObservableBase, ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    var ExtremaByObservable = function(__super__) {\n        inherits(ExtremaByObservable, __super__);\n        function ExtremaByObservable(source, k, c) {\n            this.source = source;\n            this._k = k;\n            this._c = c;\n            __super__.call(this);\n        }\n        ExtremaByObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new ExtremaByObserver(o, this._k, this._c));\n        };\n        return ExtremaByObservable;\n    }(ObservableBase);\n    var ExtremaByObserver = function(__super__) {\n        inherits(ExtremaByObserver, __super__);\n        function ExtremaByObserver(o, k, c) {\n            this._o = o;\n            this._k = k;\n            this._c = c;\n            this._v = null;\n            this._hv = false;\n            this._l = [];\n            __super__.call(this);\n        }\n        ExtremaByObserver.prototype.next = function(x) {\n            var key = tryCatch(this._k)(x);\n            if (key === errorObj) {\n                return this._o.onError(key.e);\n            }\n            var comparison = 0;\n            if (!this._hv) {\n                this._hv = true;\n                this._v = key;\n            } else {\n                comparison = tryCatch(this._c)(key, this._v);\n                if (comparison === errorObj) {\n                    return this._o.onError(comparison.e);\n                }\n            }\n            if (comparison > 0) {\n                this._v = key;\n                this._l = [];\n            }\n            if (comparison >= 0) {\n                this._l.push(x);\n            }\n        };\n        ExtremaByObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ExtremaByObserver.prototype.completed = function() {\n            this._o.onNext(this._l);\n            this._o.onCompleted();\n        };\n        return ExtremaByObserver;\n    }(AbstractObserver);\n    function firstOnly(x) {\n        if (x.length === 0) {\n            throw new EmptyError();\n        }\n        return x[0];\n    }\n    var ReduceObservable = function(__super__) {\n        inherits(ReduceObservable, __super__);\n        function ReduceObservable(source, accumulator, hasSeed, seed) {\n            this.source = source;\n            this.accumulator = accumulator;\n            this.hasSeed = hasSeed;\n            this.seed = seed;\n            __super__.call(this);\n        }\n        ReduceObservable.prototype.subscribeCore = function(observer) {\n            return this.source.subscribe(new ReduceObserver(observer, this));\n        };\n        return ReduceObservable;\n    }(ObservableBase);\n    var ReduceObserver = function(__super__) {\n        inherits(ReduceObserver, __super__);\n        function ReduceObserver(o, parent) {\n            this._o = o;\n            this._p = parent;\n            this._fn = parent.accumulator;\n            this._hs = parent.hasSeed;\n            this._s = parent.seed;\n            this._ha = false;\n            this._a = null;\n            this._hv = false;\n            this._i = 0;\n            __super__.call(this);\n        }\n        ReduceObserver.prototype.next = function(x) {\n            !this._hv && (this._hv = true);\n            if (this._ha) {\n                this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);\n            } else {\n                this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;\n                this._ha = true;\n            }\n            if (this._a === errorObj) {\n                return this._o.onError(this._a.e);\n            }\n            this._i++;\n        };\n        ReduceObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ReduceObserver.prototype.completed = function() {\n            this._hv && this._o.onNext(this._a);\n            !this._hv && this._hs && this._o.onNext(this._s);\n            !this._hv && !this._hs && this._o.onError(new EmptyError());\n            this._o.onCompleted();\n        };\n        return ReduceObserver;\n    }(AbstractObserver);\n    /**\n  * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n  * For aggregation behavior with incremental intermediate results, see Observable.scan.\n  * @param {Function} accumulator An accumulator function to be invoked on each element.\n  * @param {Any} [seed] The initial accumulator value.\n  * @returns {Observable} An observable sequence containing a single element with the final accumulator value.\n  */ observableProto.reduce = function() {\n        var hasSeed = false, seed, accumulator = arguments[0];\n        if (arguments.length === 2) {\n            hasSeed = true;\n            seed = arguments[1];\n        }\n        return new ReduceObservable(this, accumulator, hasSeed, seed);\n    };\n    var SomeObservable = function(__super__) {\n        inherits(SomeObservable, __super__);\n        function SomeObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        SomeObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SomeObserver(o, this._fn, this.source));\n        };\n        return SomeObservable;\n    }(ObservableBase);\n    var SomeObserver = function(__super__) {\n        inherits(SomeObserver, __super__);\n        function SomeObserver(o, fn, s) {\n            this._o = o;\n            this._fn = fn;\n            this._s = s;\n            this._i = 0;\n            __super__.call(this);\n        }\n        SomeObserver.prototype.next = function(x) {\n            var result = tryCatch(this._fn)(x, this._i++, this._s);\n            if (result === errorObj) {\n                return this._o.onError(result.e);\n            }\n            if (Boolean(result)) {\n                this._o.onNext(true);\n                this._o.onCompleted();\n            }\n        };\n        SomeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SomeObserver.prototype.completed = function() {\n            this._o.onNext(false);\n            this._o.onCompleted();\n        };\n        return SomeObserver;\n    }(AbstractObserver);\n    /**\n   * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.\n   * @param {Function} [predicate] A function to test each element for a condition.\n   * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.\n   */ observableProto.some = function(predicate, thisArg) {\n        var fn = bindCallback(predicate, thisArg, 3);\n        return new SomeObservable(this, fn);\n    };\n    var IsEmptyObservable = function(__super__) {\n        inherits(IsEmptyObservable, __super__);\n        function IsEmptyObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        IsEmptyObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new IsEmptyObserver(o));\n        };\n        return IsEmptyObservable;\n    }(ObservableBase);\n    var IsEmptyObserver = function(__super__) {\n        inherits(IsEmptyObserver, __super__);\n        function IsEmptyObserver(o) {\n            this._o = o;\n            __super__.call(this);\n        }\n        IsEmptyObserver.prototype.next = function() {\n            this._o.onNext(false);\n            this._o.onCompleted();\n        };\n        IsEmptyObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        IsEmptyObserver.prototype.completed = function() {\n            this._o.onNext(true);\n            this._o.onCompleted();\n        };\n        return IsEmptyObserver;\n    }(AbstractObserver);\n    /**\n   * Determines whether an observable sequence is empty.\n   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.\n   */ observableProto.isEmpty = function() {\n        return new IsEmptyObservable(this);\n    };\n    var EveryObservable = function(__super__) {\n        inherits(EveryObservable, __super__);\n        function EveryObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        EveryObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new EveryObserver(o, this._fn, this.source));\n        };\n        return EveryObservable;\n    }(ObservableBase);\n    var EveryObserver = function(__super__) {\n        inherits(EveryObserver, __super__);\n        function EveryObserver(o, fn, s) {\n            this._o = o;\n            this._fn = fn;\n            this._s = s;\n            this._i = 0;\n            __super__.call(this);\n        }\n        EveryObserver.prototype.next = function(x) {\n            var result = tryCatch(this._fn)(x, this._i++, this._s);\n            if (result === errorObj) {\n                return this._o.onError(result.e);\n            }\n            if (!Boolean(result)) {\n                this._o.onNext(false);\n                this._o.onCompleted();\n            }\n        };\n        EveryObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        EveryObserver.prototype.completed = function() {\n            this._o.onNext(true);\n            this._o.onCompleted();\n        };\n        return EveryObserver;\n    }(AbstractObserver);\n    /**\n   * Determines whether all elements of an observable sequence satisfy a condition.\n   * @param {Function} [predicate] A function to test each element for a condition.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.\n   */ observableProto.every = function(predicate, thisArg) {\n        var fn = bindCallback(predicate, thisArg, 3);\n        return new EveryObservable(this, fn);\n    };\n    var IncludesObservable = function(__super__) {\n        inherits(IncludesObservable, __super__);\n        function IncludesObservable(source, elem, idx) {\n            var n = +idx || 0;\n            Math.abs(n) === Infinity && (n = 0);\n            this.source = source;\n            this._elem = elem;\n            this._n = n;\n            __super__.call(this);\n        }\n        IncludesObservable.prototype.subscribeCore = function(o) {\n            if (this._n < 0) {\n                o.onNext(false);\n                o.onCompleted();\n                return disposableEmpty;\n            }\n            return this.source.subscribe(new IncludesObserver(o, this._elem, this._n));\n        };\n        return IncludesObservable;\n    }(ObservableBase);\n    var IncludesObserver = function(__super__) {\n        inherits(IncludesObserver, __super__);\n        function IncludesObserver(o, elem, n) {\n            this._o = o;\n            this._elem = elem;\n            this._n = n;\n            this._i = 0;\n            __super__.call(this);\n        }\n        function comparer(a, b) {\n            return a === 0 && b === 0 || a === b || isNaN(a) && isNaN(b);\n        }\n        IncludesObserver.prototype.next = function(x) {\n            if (this._i++ >= this._n && comparer(x, this._elem)) {\n                this._o.onNext(true);\n                this._o.onCompleted();\n            }\n        };\n        IncludesObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        IncludesObserver.prototype.completed = function() {\n            this._o.onNext(false);\n            this._o.onCompleted();\n        };\n        return IncludesObserver;\n    }(AbstractObserver);\n    /**\n   * Determines whether an observable sequence includes a specified element with an optional equality comparer.\n   * @param searchElement The value to locate in the source sequence.\n   * @param {Number} [fromIndex] An equality comparer to compare elements.\n   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence includes an element that has the specified value from the given index.\n   */ observableProto.includes = function(searchElement, fromIndex) {\n        return new IncludesObservable(this, searchElement, fromIndex);\n    };\n    var CountObservable = function(__super__) {\n        inherits(CountObservable, __super__);\n        function CountObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        CountObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new CountObserver(o, this._fn, this.source));\n        };\n        return CountObservable;\n    }(ObservableBase);\n    var CountObserver = function(__super__) {\n        inherits(CountObserver, __super__);\n        function CountObserver(o, fn, s) {\n            this._o = o;\n            this._fn = fn;\n            this._s = s;\n            this._i = 0;\n            this._c = 0;\n            __super__.call(this);\n        }\n        CountObserver.prototype.next = function(x) {\n            if (this._fn) {\n                var result = tryCatch(this._fn)(x, this._i++, this._s);\n                if (result === errorObj) {\n                    return this._o.onError(result.e);\n                }\n                Boolean(result) && this._c++;\n            } else {\n                this._c++;\n            }\n        };\n        CountObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        CountObserver.prototype.completed = function() {\n            this._o.onNext(this._c);\n            this._o.onCompleted();\n        };\n        return CountObserver;\n    }(AbstractObserver);\n    /**\n   * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.\n   * @example\n   * res = source.count();\n   * res = source.count(function (x) { return x > 3; });\n   * @param {Function} [predicate]A function to test each element for a condition.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.\n   */ observableProto.count = function(predicate, thisArg) {\n        var fn = bindCallback(predicate, thisArg, 3);\n        return new CountObservable(this, fn);\n    };\n    var IndexOfObservable = function(__super__) {\n        inherits(IndexOfObservable, __super__);\n        function IndexOfObservable(source, e, n) {\n            this.source = source;\n            this._e = e;\n            this._n = n;\n            __super__.call(this);\n        }\n        IndexOfObservable.prototype.subscribeCore = function(o) {\n            if (this._n < 0) {\n                o.onNext(-1);\n                o.onCompleted();\n                return disposableEmpty;\n            }\n            return this.source.subscribe(new IndexOfObserver(o, this._e, this._n));\n        };\n        return IndexOfObservable;\n    }(ObservableBase);\n    var IndexOfObserver = function(__super__) {\n        inherits(IndexOfObserver, __super__);\n        function IndexOfObserver(o, e, n) {\n            this._o = o;\n            this._e = e;\n            this._n = n;\n            this._i = 0;\n            __super__.call(this);\n        }\n        IndexOfObserver.prototype.next = function(x) {\n            if (this._i >= this._n && x === this._e) {\n                this._o.onNext(this._i);\n                this._o.onCompleted();\n            }\n            this._i++;\n        };\n        IndexOfObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        IndexOfObserver.prototype.completed = function() {\n            this._o.onNext(-1);\n            this._o.onCompleted();\n        };\n        return IndexOfObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   * @param {Any} searchElement Element to locate in the array.\n   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.\n   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   */ observableProto.indexOf = function(searchElement, fromIndex) {\n        var n = +fromIndex || 0;\n        Math.abs(n) === Infinity && (n = 0);\n        return new IndexOfObservable(this, searchElement, n);\n    };\n    var SumObservable = function(__super__) {\n        inherits(SumObservable, __super__);\n        function SumObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        SumObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SumObserver(o, this._fn, this.source));\n        };\n        return SumObservable;\n    }(ObservableBase);\n    var SumObserver = function(__super__) {\n        inherits(SumObserver, __super__);\n        function SumObserver(o, fn, s) {\n            this._o = o;\n            this._fn = fn;\n            this._s = s;\n            this._i = 0;\n            this._c = 0;\n            __super__.call(this);\n        }\n        SumObserver.prototype.next = function(x) {\n            if (this._fn) {\n                var result = tryCatch(this._fn)(x, this._i++, this._s);\n                if (result === errorObj) {\n                    return this._o.onError(result.e);\n                }\n                this._c += result;\n            } else {\n                this._c += x;\n            }\n        };\n        SumObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SumObserver.prototype.completed = function() {\n            this._o.onNext(this._c);\n            this._o.onCompleted();\n        };\n        return SumObserver;\n    }(AbstractObserver);\n    /**\n   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.\n   * @param {Function} [selector] A transform function to apply to each element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.\n   */ observableProto.sum = function(keySelector, thisArg) {\n        var fn = bindCallback(keySelector, thisArg, 3);\n        return new SumObservable(this, fn);\n    };\n    /**\n   * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.\n   * @example\n   * var res = source.minBy(function (x) { return x.value; });\n   * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });\n   * @param {Function} keySelector Key selector function.\n   * @param {Function} [comparer] Comparer used to compare key values.\n   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.\n   */ observableProto.minBy = function(keySelector, comparer) {\n        comparer || (comparer = defaultSubComparer);\n        return new ExtremaByObservable(this, keySelector, function(x, y) {\n            return comparer(x, y) * -1;\n        });\n    };\n    /**\n   * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.\n   * @example\n   * var res = source.min();\n   * var res = source.min(function (x, y) { return x.value - y.value; });\n   * @param {Function} [comparer] Comparer used to compare elements.\n   * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.\n   */ observableProto.min = function(comparer) {\n        return this.minBy(identity, comparer).map(firstOnly);\n    };\n    /**\n   * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.\n   * @example\n   * var res = source.maxBy(function (x) { return x.value; });\n   * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });\n   * @param {Function} keySelector Key selector function.\n   * @param {Function} [comparer]  Comparer used to compare key values.\n   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.\n   */ observableProto.maxBy = function(keySelector, comparer) {\n        comparer || (comparer = defaultSubComparer);\n        return new ExtremaByObservable(this, keySelector, comparer);\n    };\n    /**\n   * Returns the maximum value in an observable sequence according to the specified comparer.\n   * @example\n   * var res = source.max();\n   * var res = source.max(function (x, y) { return x.value - y.value; });\n   * @param {Function} [comparer] Comparer used to compare elements.\n   * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.\n   */ observableProto.max = function(comparer) {\n        return this.maxBy(identity, comparer).map(firstOnly);\n    };\n    var AverageObservable = function(__super__) {\n        inherits(AverageObservable, __super__);\n        function AverageObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        AverageObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new AverageObserver(o, this._fn, this.source));\n        };\n        return AverageObservable;\n    }(ObservableBase);\n    var AverageObserver = function(__super__) {\n        inherits(AverageObserver, __super__);\n        function AverageObserver(o, fn, s) {\n            this._o = o;\n            this._fn = fn;\n            this._s = s;\n            this._c = 0;\n            this._t = 0;\n            __super__.call(this);\n        }\n        AverageObserver.prototype.next = function(x) {\n            if (this._fn) {\n                var r = tryCatch(this._fn)(x, this._c++, this._s);\n                if (r === errorObj) {\n                    return this._o.onError(r.e);\n                }\n                this._t += r;\n            } else {\n                this._c++;\n                this._t += x;\n            }\n        };\n        AverageObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        AverageObserver.prototype.completed = function() {\n            if (this._c === 0) {\n                return this._o.onError(new EmptyError());\n            }\n            this._o.onNext(this._t / this._c);\n            this._o.onCompleted();\n        };\n        return AverageObserver;\n    }(AbstractObserver);\n    /**\n   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.\n   * @param {Function} [selector] A transform function to apply to each element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.\n   */ observableProto.average = function(keySelector, thisArg) {\n        var source = this, fn;\n        if (isFunction(keySelector)) {\n            fn = bindCallback(keySelector, thisArg, 3);\n        }\n        return new AverageObservable(source, fn);\n    };\n    /**\n   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.\n   *\n   * @example\n   * var res = res = source.sequenceEqual([1,2,3]);\n   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });\n   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));\n   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });\n   * @param {Observable} second Second observable sequence or array to compare.\n   * @param {Function} [comparer] Comparer used to compare elements of both sequences.\n   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.\n   */ observableProto.sequenceEqual = function(second, comparer) {\n        var first = this;\n        comparer || (comparer = defaultComparer);\n        return new AnonymousObservable(function(o) {\n            var donel = false, doner = false, ql = [], qr = [];\n            var subscription1 = first.subscribe(function(x) {\n                if (qr.length > 0) {\n                    var v = qr.shift();\n                    var equal = tryCatch(comparer)(v, x);\n                    if (equal === errorObj) {\n                        return o.onError(equal.e);\n                    }\n                    if (!equal) {\n                        o.onNext(false);\n                        o.onCompleted();\n                    }\n                } else if (doner) {\n                    o.onNext(false);\n                    o.onCompleted();\n                } else {\n                    ql.push(x);\n                }\n            }, function(e) {\n                o.onError(e);\n            }, function() {\n                donel = true;\n                if (ql.length === 0) {\n                    if (qr.length > 0) {\n                        o.onNext(false);\n                        o.onCompleted();\n                    } else if (doner) {\n                        o.onNext(true);\n                        o.onCompleted();\n                    }\n                }\n            });\n            (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));\n            isPromise(second) && (second = observableFromPromise(second));\n            var subscription2 = second.subscribe(function(x) {\n                if (ql.length > 0) {\n                    var v = ql.shift();\n                    var equal = tryCatch(comparer)(v, x);\n                    if (equal === errorObj) {\n                        return o.onError(equal.e);\n                    }\n                    if (!equal) {\n                        o.onNext(false);\n                        o.onCompleted();\n                    }\n                } else if (donel) {\n                    o.onNext(false);\n                    o.onCompleted();\n                } else {\n                    qr.push(x);\n                }\n            }, function(e) {\n                o.onError(e);\n            }, function() {\n                doner = true;\n                if (qr.length === 0) {\n                    if (ql.length > 0) {\n                        o.onNext(false);\n                        o.onCompleted();\n                    } else if (donel) {\n                        o.onNext(true);\n                        o.onCompleted();\n                    }\n                }\n            });\n            return new BinaryDisposable(subscription1, subscription2);\n        }, first);\n    };\n    var ElementAtObservable = function(__super__) {\n        inherits(ElementAtObservable, __super__);\n        function ElementAtObservable(source, i, d) {\n            this.source = source;\n            this._i = i;\n            this._d = d;\n            __super__.call(this);\n        }\n        ElementAtObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new ElementAtObserver(o, this._i, this._d));\n        };\n        return ElementAtObservable;\n    }(ObservableBase);\n    var ElementAtObserver = function(__super__) {\n        inherits(ElementAtObserver, __super__);\n        function ElementAtObserver(o, i, d) {\n            this._o = o;\n            this._i = i;\n            this._d = d;\n            __super__.call(this);\n        }\n        ElementAtObserver.prototype.next = function(x) {\n            if (this._i-- === 0) {\n                this._o.onNext(x);\n                this._o.onCompleted();\n            }\n        };\n        ElementAtObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ElementAtObserver.prototype.completed = function() {\n            if (this._d === undefined) {\n                this._o.onError(new ArgumentOutOfRangeError());\n            } else {\n                this._o.onNext(this._d);\n                this._o.onCompleted();\n            }\n        };\n        return ElementAtObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the element at a specified index in a sequence or default value if not found.\n   * @param {Number} index The zero-based index of the element to retrieve.\n   * @param {Any} [defaultValue] The default value to use if elementAt does not find a value.\n   * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.\n   */ observableProto.elementAt = function(index, defaultValue) {\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        return new ElementAtObservable(this, index, defaultValue);\n    };\n    var SingleObserver = function(__super__) {\n        inherits(SingleObserver, __super__);\n        function SingleObserver(o, obj, s) {\n            this._o = o;\n            this._obj = obj;\n            this._s = s;\n            this._i = 0;\n            this._hv = false;\n            this._v = null;\n            __super__.call(this);\n        }\n        SingleObserver.prototype.next = function(x) {\n            var shouldYield = false;\n            if (this._obj.predicate) {\n                var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                Boolean(res) && (shouldYield = true);\n            } else if (!this._obj.predicate) {\n                shouldYield = true;\n            }\n            if (shouldYield) {\n                if (this._hv) {\n                    return this._o.onError(new Error(\"Sequence contains more than one matching element\"));\n                }\n                this._hv = true;\n                this._v = x;\n            }\n        };\n        SingleObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SingleObserver.prototype.completed = function() {\n            if (this._hv) {\n                this._o.onNext(this._v);\n                this._o.onCompleted();\n            } else if (this._obj.defaultValue === undefined) {\n                this._o.onError(new EmptyError());\n            } else {\n                this._o.onNext(this._obj.defaultValue);\n                this._o.onCompleted();\n            }\n        };\n        return SingleObserver;\n    }(AbstractObserver);\n    /**\n     * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.\n     * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.\n     */ observableProto.single = function(predicate, thisArg) {\n        var obj = {}, source = this;\n        if (typeof arguments[0] === \"object\") {\n            obj = arguments[0];\n        } else {\n            obj = {\n                predicate: arguments[0],\n                thisArg: arguments[1],\n                defaultValue: arguments[2]\n            };\n        }\n        if (isFunction(obj.predicate)) {\n            var fn = obj.predicate;\n            obj.predicate = bindCallback(fn, obj.thisArg, 3);\n        }\n        return new AnonymousObservable(function(o) {\n            return source.subscribe(new SingleObserver(o, obj, source));\n        }, source);\n    };\n    var FirstObservable = function(__super__) {\n        inherits(FirstObservable, __super__);\n        function FirstObservable(source, obj) {\n            this.source = source;\n            this._obj = obj;\n            __super__.call(this);\n        }\n        FirstObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new FirstObserver(o, this._obj, this.source));\n        };\n        return FirstObservable;\n    }(ObservableBase);\n    var FirstObserver = function(__super__) {\n        inherits(FirstObserver, __super__);\n        function FirstObserver(o, obj, s) {\n            this._o = o;\n            this._obj = obj;\n            this._s = s;\n            this._i = 0;\n            __super__.call(this);\n        }\n        FirstObserver.prototype.next = function(x) {\n            if (this._obj.predicate) {\n                var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                if (Boolean(res)) {\n                    this._o.onNext(x);\n                    this._o.onCompleted();\n                }\n            } else if (!this._obj.predicate) {\n                this._o.onNext(x);\n                this._o.onCompleted();\n            }\n        };\n        FirstObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        FirstObserver.prototype.completed = function() {\n            if (this._obj.defaultValue === undefined) {\n                this._o.onError(new EmptyError());\n            } else {\n                this._o.onNext(this._obj.defaultValue);\n                this._o.onCompleted();\n            }\n        };\n        return FirstObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.\n   * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.\n   */ observableProto.first = function() {\n        var obj = {}, source = this;\n        if (typeof arguments[0] === \"object\") {\n            obj = arguments[0];\n        } else {\n            obj = {\n                predicate: arguments[0],\n                thisArg: arguments[1],\n                defaultValue: arguments[2]\n            };\n        }\n        if (isFunction(obj.predicate)) {\n            var fn = obj.predicate;\n            obj.predicate = bindCallback(fn, obj.thisArg, 3);\n        }\n        return new FirstObservable(this, obj);\n    };\n    var LastObservable = function(__super__) {\n        inherits(LastObservable, __super__);\n        function LastObservable(source, obj) {\n            this.source = source;\n            this._obj = obj;\n            __super__.call(this);\n        }\n        LastObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new LastObserver(o, this._obj, this.source));\n        };\n        return LastObservable;\n    }(ObservableBase);\n    var LastObserver = function(__super__) {\n        inherits(LastObserver, __super__);\n        function LastObserver(o, obj, s) {\n            this._o = o;\n            this._obj = obj;\n            this._s = s;\n            this._i = 0;\n            this._hv = false;\n            this._v = null;\n            __super__.call(this);\n        }\n        LastObserver.prototype.next = function(x) {\n            var shouldYield = false;\n            if (this._obj.predicate) {\n                var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                Boolean(res) && (shouldYield = true);\n            } else if (!this._obj.predicate) {\n                shouldYield = true;\n            }\n            if (shouldYield) {\n                this._hv = true;\n                this._v = x;\n            }\n        };\n        LastObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        LastObserver.prototype.completed = function() {\n            if (this._hv) {\n                this._o.onNext(this._v);\n                this._o.onCompleted();\n            } else if (this._obj.defaultValue === undefined) {\n                this._o.onError(new EmptyError());\n            } else {\n                this._o.onNext(this._obj.defaultValue);\n                this._o.onCompleted();\n            }\n        };\n        return LastObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.\n   * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.\n   */ observableProto.last = function() {\n        var obj = {}, source = this;\n        if (typeof arguments[0] === \"object\") {\n            obj = arguments[0];\n        } else {\n            obj = {\n                predicate: arguments[0],\n                thisArg: arguments[1],\n                defaultValue: arguments[2]\n            };\n        }\n        if (isFunction(obj.predicate)) {\n            var fn = obj.predicate;\n            obj.predicate = bindCallback(fn, obj.thisArg, 3);\n        }\n        return new LastObservable(this, obj);\n    };\n    var FindValueObserver = function(__super__) {\n        inherits(FindValueObserver, __super__);\n        function FindValueObserver(observer, source, callback, yieldIndex) {\n            this._o = observer;\n            this._s = source;\n            this._cb = callback;\n            this._y = yieldIndex;\n            this._i = 0;\n            __super__.call(this);\n        }\n        FindValueObserver.prototype.next = function(x) {\n            var shouldRun = tryCatch(this._cb)(x, this._i, this._s);\n            if (shouldRun === errorObj) {\n                return this._o.onError(shouldRun.e);\n            }\n            if (shouldRun) {\n                this._o.onNext(this._y ? this._i : x);\n                this._o.onCompleted();\n            } else {\n                this._i++;\n            }\n        };\n        FindValueObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        FindValueObserver.prototype.completed = function() {\n            this._y && this._o.onNext(-1);\n            this._o.onCompleted();\n        };\n        return FindValueObserver;\n    }(AbstractObserver);\n    function findValue(source, predicate, thisArg, yieldIndex) {\n        var callback = bindCallback(predicate, thisArg, 3);\n        return new AnonymousObservable(function(o) {\n            return source.subscribe(new FindValueObserver(o, source, callback, yieldIndex));\n        }, source);\n    }\n    /**\n   * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.\n   * @param {Function} predicate The predicate that defines the conditions of the element to search for.\n   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.\n   * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.\n   */ observableProto.find = function(predicate, thisArg) {\n        return findValue(this, predicate, thisArg, false);\n    };\n    /**\n   * Searches for an element that matches the conditions defined by the specified predicate, and returns\n   * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.\n   * @param {Function} predicate The predicate that defines the conditions of the element to search for.\n   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.\n   * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.\n  */ observableProto.findIndex = function(predicate, thisArg) {\n        return findValue(this, predicate, thisArg, true);\n    };\n    var ToSetObservable = function(__super__) {\n        inherits(ToSetObservable, __super__);\n        function ToSetObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        ToSetObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new ToSetObserver(o));\n        };\n        return ToSetObservable;\n    }(ObservableBase);\n    var ToSetObserver = function(__super__) {\n        inherits(ToSetObserver, __super__);\n        function ToSetObserver(o) {\n            this._o = o;\n            this._s = new root.Set();\n            __super__.call(this);\n        }\n        ToSetObserver.prototype.next = function(x) {\n            this._s.add(x);\n        };\n        ToSetObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ToSetObserver.prototype.completed = function() {\n            this._o.onNext(this._s);\n            this._o.onCompleted();\n        };\n        return ToSetObserver;\n    }(AbstractObserver);\n    /**\n   * Converts the observable sequence to a Set if it exists.\n   * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.\n   */ observableProto.toSet = function() {\n        if (typeof root.Set === \"undefined\") {\n            throw new TypeError();\n        }\n        return new ToSetObservable(this);\n    };\n    var ToMapObservable = function(__super__) {\n        inherits(ToMapObservable, __super__);\n        function ToMapObservable(source, k, e) {\n            this.source = source;\n            this._k = k;\n            this._e = e;\n            __super__.call(this);\n        }\n        ToMapObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new ToMapObserver(o, this._k, this._e));\n        };\n        return ToMapObservable;\n    }(ObservableBase);\n    var ToMapObserver = function(__super__) {\n        inherits(ToMapObserver, __super__);\n        function ToMapObserver(o, k, e) {\n            this._o = o;\n            this._k = k;\n            this._e = e;\n            this._m = new root.Map();\n            __super__.call(this);\n        }\n        ToMapObserver.prototype.next = function(x) {\n            var key = tryCatch(this._k)(x);\n            if (key === errorObj) {\n                return this._o.onError(key.e);\n            }\n            var elem = x;\n            if (this._e) {\n                elem = tryCatch(this._e)(x);\n                if (elem === errorObj) {\n                    return this._o.onError(elem.e);\n                }\n            }\n            this._m.set(key, elem);\n        };\n        ToMapObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ToMapObserver.prototype.completed = function() {\n            this._o.onNext(this._m);\n            this._o.onCompleted();\n        };\n        return ToMapObserver;\n    }(AbstractObserver);\n    /**\n  * Converts the observable sequence to a Map if it exists.\n  * @param {Function} keySelector A function which produces the key for the Map.\n  * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.\n  * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.\n  */ observableProto.toMap = function(keySelector, elementSelector) {\n        if (typeof root.Map === \"undefined\") {\n            throw new TypeError();\n        }\n        return new ToMapObservable(this, keySelector, elementSelector);\n    };\n    var SliceObservable = function(__super__) {\n        inherits(SliceObservable, __super__);\n        function SliceObservable(source, b, e) {\n            this.source = source;\n            this._b = b;\n            this._e = e;\n            __super__.call(this);\n        }\n        SliceObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SliceObserver(o, this._b, this._e));\n        };\n        return SliceObservable;\n    }(ObservableBase);\n    var SliceObserver = function(__super__) {\n        inherits(SliceObserver, __super__);\n        function SliceObserver(o, b, e) {\n            this._o = o;\n            this._b = b;\n            this._e = e;\n            this._i = 0;\n            __super__.call(this);\n        }\n        SliceObserver.prototype.next = function(x) {\n            if (this._i >= this._b) {\n                if (this._e === this._i) {\n                    this._o.onCompleted();\n                } else {\n                    this._o.onNext(x);\n                }\n            }\n            this._i++;\n        };\n        SliceObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SliceObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return SliceObserver;\n    }(AbstractObserver);\n    /*\n  * The slice() method returns a shallow copy of a portion of an Observable into a new Observable object.\n  * Unlike the array version, this does not support negative numbers for being or end.\n  * @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.\n  * @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.\n  * If omitted, this will emit the rest of the Observable object.\n  * @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.\n  */ observableProto.slice = function(begin, end) {\n        var start = begin || 0;\n        if (start < 0) {\n            throw new Rx.ArgumentOutOfRangeError();\n        }\n        if (typeof end === \"number\" && end < start) {\n            throw new Rx.ArgumentOutOfRangeError();\n        }\n        return new SliceObservable(this, start, end);\n    };\n    var LastIndexOfObservable = function(__super__) {\n        inherits(LastIndexOfObservable, __super__);\n        function LastIndexOfObservable(source, e, n) {\n            this.source = source;\n            this._e = e;\n            this._n = n;\n            __super__.call(this);\n        }\n        LastIndexOfObservable.prototype.subscribeCore = function(o) {\n            if (this._n < 0) {\n                o.onNext(-1);\n                o.onCompleted();\n                return disposableEmpty;\n            }\n            return this.source.subscribe(new LastIndexOfObserver(o, this._e, this._n));\n        };\n        return LastIndexOfObservable;\n    }(ObservableBase);\n    var LastIndexOfObserver = function(__super__) {\n        inherits(LastIndexOfObserver, __super__);\n        function LastIndexOfObserver(o, e, n) {\n            this._o = o;\n            this._e = e;\n            this._n = n;\n            this._v = 0;\n            this._hv = false;\n            this._i = 0;\n            __super__.call(this);\n        }\n        LastIndexOfObserver.prototype.next = function(x) {\n            if (this._i >= this._n && x === this._e) {\n                this._hv = true;\n                this._v = this._i;\n            }\n            this._i++;\n        };\n        LastIndexOfObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        LastIndexOfObserver.prototype.completed = function() {\n            if (this._hv) {\n                this._o.onNext(this._v);\n            } else {\n                this._o.onNext(-1);\n            }\n            this._o.onCompleted();\n        };\n        return LastIndexOfObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the last index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   * @param {Any} searchElement Element to locate in the array.\n   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.\n   * @returns {Observable} And observable sequence containing the last index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   */ observableProto.lastIndexOf = function(searchElement, fromIndex) {\n        var n = +fromIndex || 0;\n        Math.abs(n) === Infinity && (n = 0);\n        return new LastIndexOfObservable(this, searchElement, n);\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5hZ2dyZWdhdGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw2S0FBNkc7O0FBRTNHLFVBQVVBLE9BQU87SUFDakIsSUFBSUMsY0FBYztRQUNoQixZQUFZO1FBQ1osVUFBVTtJQUNaO0lBRUEsU0FBU0MsWUFBWUMsS0FBSztRQUN4QixPQUFPLFNBQVVBLE1BQU1DLE1BQU0sS0FBS0EsU0FBVUQsUUFBUTtJQUN0RDtJQUVBLElBQUlFLGNBQWMsV0FBWSxDQUFDLE9BQU9DLFFBQVEsSUFBSUEsV0FBVyxDQUFDQSxRQUFRQyxRQUFRLEdBQUlELFVBQVU7SUFDNUYsSUFBSUUsYUFBYSxXQUFZLENBQUMsUUFBYUMsQ0FBQyxJQUFJQSxVQUFVLENBQUNBLE9BQU9GLFFBQVEsR0FBSUUsU0FBUztJQUN2RixJQUFJQyxhQUFhUixZQUFZRyxlQUFlRyxjQUFjLE9BQU9HLFdBQVcsWUFBWUE7SUFDeEYsSUFBSUMsV0FBV1YsWUFBWUQsV0FBVyxDQUFDLE9BQU9ZLEtBQUssSUFBSUE7SUFDdkQsSUFBSUMsYUFBYVosWUFBWUQsV0FBVyxDQUFDLFlBQWMsSUFBSWM7SUFDM0QsSUFBSUMsZ0JBQWdCLGNBQWVSLFdBQVdGLE9BQU8sS0FBS0QsY0FBZUEsY0FBYztJQUN2RixJQUFJWSxhQUFhZixZQUFZRCxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJO0lBQzdELElBQUlpQixPQUFPUixjQUFlLGVBQWlCTyxDQUFBQSxjQUFjQSxXQUFXRixNQUFNLEtBQU1ELGNBQWVGLFlBQVlLLGNBQWNFLFNBQVM7SUFFbEksOEJBQThCO0lBQzlCLElBQUksSUFBMEMsRUFBRTtRQUM5Q0MsaUNBQU87WUFBQztTQUFPLG1DQUFFLFNBQVVFLEVBQUUsRUFBRWhCLFFBQU87WUFDcEMsT0FBT04sUUFBUWtCLE1BQU1aLFVBQVNnQjtRQUNoQyxDQUFDO0FBQUEsa0dBQUM7SUFDSixPQUFPLEVBSU47QUFDSCxHQUFFRSxJQUFJLENBQUMs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QjtZQUNBLElBQUksQ0FBQ0EsRUFBRTtRQUNUO1FBQ0FvSCxvQkFBb0JoTSxTQUFTLENBQUN5RCxLQUFLLEdBQUcsU0FBVS9CLENBQUM7WUFBSSxJQUFJLENBQUNxQixFQUFFLENBQUNPLE9BQU8sQ0FBQzVCO1FBQUk7UUFDekVzSyxvQkFBb0JoTSxTQUFTLENBQUMwRCxTQUFTLEdBQUc7WUFDeEMsSUFBSSxJQUFJLENBQUNULEdBQUcsRUFBRTtnQkFDWixJQUFJLENBQUNGLEVBQUUsQ0FBQ1ksTUFBTSxDQUFDLElBQUksQ0FBQ1gsRUFBRTtZQUN4QixPQUFPO2dCQUNMLElBQUksQ0FBQ0QsRUFBRSxDQUFDWSxNQUFNLENBQUMsQ0FBQztZQUNsQjtZQUNBLElBQUksQ0FBQ1osRUFBRSxDQUFDYSxXQUFXO1FBQ3JCO1FBRUEsT0FBT29JO0lBQ1QsRUFBRTdMO0lBRUY7Ozs7O0dBS0MsR0FDREosZ0JBQWdCa00sV0FBVyxHQUFHLFNBQVN0RixhQUFhLEVBQUVDLFNBQVM7UUFDN0QsSUFBSWIsSUFBSSxDQUFDYSxhQUFhO1FBQ3RCWixLQUFLQyxHQUFHLENBQUNGLE9BQU9HLFlBQWFILENBQUFBLElBQUk7UUFDakMsT0FBTyxJQUFJZ0csc0JBQXNCLElBQUksRUFBRXBGLGVBQWVaO0lBQ3hEO0lBRUEsT0FBT3RHO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXJ2ZXItYWN0aW9uLy4vbm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguYWdncmVnYXRlcy5qcz9hNzVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LCBBbGwgcmlnaHRzIHJlc2VydmVkLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpID8gZXhwb3J0cyA6IG51bGw7XG4gIHZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKSA/IG1vZHVsZSA6IG51bGw7XG4gIHZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuICB2YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG4gIHZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSAoZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSA/IGZyZWVFeHBvcnRzIDogbnVsbDtcbiAgdmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8vIEJlY2F1c2Ugb2YgYnVpbGQgb3B0aW1pemVyc1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnLi9yeCddLCBmdW5jdGlvbiAoUngsIGV4cG9ydHMpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIFJ4KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QsIG1vZHVsZS5leHBvcnRzLCByZXF1aXJlKCcuL3J4JykpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUnggPSBmYWN0b3J5KHJvb3QsIHt9LCByb290LlJ4KTtcbiAgfVxufS5jYWxsKHRoaXMsIGZ1bmN0aW9uIChyb290LCBleHAsIFJ4LCB1bmRlZmluZWQpIHtcblxuICAvLyBSZWZlcmVuY2VzXG4gIHZhciBPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZhYmxlUHJvdG8gPSBPYnNlcnZhYmxlLnByb3RvdHlwZSxcbiAgICBCaW5hcnlEaXNwb3NhYmxlID0gUnguQmluYXJ5RGlzcG9zYWJsZSxcbiAgICBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSxcbiAgICBBYnN0cmFjdE9ic2VydmVyID0gUnguaW50ZXJuYWxzLkFic3RyYWN0T2JzZXJ2ZXIsXG4gICAgZGlzcG9zYWJsZUVtcHR5ID0gUnguRGlzcG9zYWJsZS5lbXB0eSxcbiAgICBoZWxwZXJzID0gUnguaGVscGVycyxcbiAgICBkZWZhdWx0Q29tcGFyZXIgPSBoZWxwZXJzLmRlZmF1bHRDb21wYXJlcixcbiAgICBpZGVudGl0eSA9IGhlbHBlcnMuaWRlbnRpdHksXG4gICAgZGVmYXVsdFN1YkNvbXBhcmVyID0gaGVscGVycy5kZWZhdWx0U3ViQ29tcGFyZXIsXG4gICAgaXNGdW5jdGlvbiA9IGhlbHBlcnMuaXNGdW5jdGlvbixcbiAgICBpc1Byb21pc2UgPSBoZWxwZXJzLmlzUHJvbWlzZSxcbiAgICBpc0FycmF5TGlrZSA9IGhlbHBlcnMuaXNBcnJheUxpa2UsXG4gICAgaXNJdGVyYWJsZSA9IGhlbHBlcnMuaXNJdGVyYWJsZSxcbiAgICBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyxcbiAgICBvYnNlcnZhYmxlRnJvbVByb21pc2UgPSBPYnNlcnZhYmxlLmZyb21Qcm9taXNlLFxuICAgIG9ic2VydmFibGVGcm9tID0gT2JzZXJ2YWJsZS5mcm9tLFxuICAgIGJpbmRDYWxsYmFjayA9IFJ4LmludGVybmFscy5iaW5kQ2FsbGJhY2ssXG4gICAgRW1wdHlFcnJvciA9IFJ4LkVtcHR5RXJyb3IsXG4gICAgT2JzZXJ2YWJsZUJhc2UgPSBSeC5PYnNlcnZhYmxlQmFzZSxcbiAgICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IFJ4LkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuXG4gIHZhciBlcnJvck9iaiA9IHtlOiB7fX07XG4gIFxuICBmdW5jdGlvbiB0cnlDYXRjaGVyR2VuKHRyeUNhdGNoVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyeUNhdGNoID0gUnguaW50ZXJuYWxzLnRyeUNhdGNoID0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZuIG11c3QgYmUgYSBmdW5jdGlvbicpOyB9XG4gICAgcmV0dXJuIHRyeUNhdGNoZXJHZW4oZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgIHRocm93IGU7XG4gIH1cblxuICB2YXIgRXh0cmVtYUJ5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXh0cmVtYUJ5T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHRyZW1hQnlPYnNlcnZhYmxlKHNvdXJjZSwgaywgYykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXh0cmVtYUJ5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBFeHRyZW1hQnlPYnNlcnZlcihvLCB0aGlzLl9rLCB0aGlzLl9jKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBFeHRyZW1hQnlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEV4dHJlbWFCeU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFeHRyZW1hQnlPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHRyZW1hQnlPYnNlcnZlcihvLCBrLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2sgPSBrO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9sID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFeHRyZW1hQnlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIga2V5ID0gdHJ5Q2F0Y2godGhpcy5faykoeCk7XG4gICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGtleS5lKTsgfVxuICAgICAgdmFyIGNvbXBhcmlzb24gPSAwO1xuICAgICAgaWYgKCF0aGlzLl9odikge1xuICAgICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3YgPSBrZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wYXJpc29uID0gdHJ5Q2F0Y2godGhpcy5fYykoa2V5LCB0aGlzLl92KTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IoY29tcGFyaXNvbi5lKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmlzb24gPiAwKSB7XG4gICAgICAgIHRoaXMuX3YgPSBrZXk7XG4gICAgICAgIHRoaXMuX2wgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJpc29uID49IDApIHsgdGhpcy5fbC5wdXNoKHgpOyB9XG4gICAgfTtcblxuICAgIEV4dHJlbWFCeU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIEV4dHJlbWFCeU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9sKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV4dHJlbWFCeU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICBmdW5jdGlvbiBmaXJzdE9ubHkoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRW1wdHlFcnJvcigpOyB9XG4gICAgcmV0dXJuIHhbMF07XG4gIH1cblxuICB2YXIgUmVkdWNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSZWR1Y2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFJlZHVjZU9ic2VydmFibGUoc291cmNlLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICB0aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFJlZHVjZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgUmVkdWNlT2JzZXJ2ZXIob2JzZXJ2ZXIsdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVkdWNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBSZWR1Y2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUmVkdWNlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVkdWNlT2JzZXJ2ZXIobywgcGFyZW50KSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwYXJlbnQ7XG4gICAgICB0aGlzLl9mbiA9IHBhcmVudC5hY2N1bXVsYXRvcjtcbiAgICAgIHRoaXMuX2hzID0gcGFyZW50Lmhhc1NlZWQ7XG4gICAgICB0aGlzLl9zID0gcGFyZW50LnNlZWQ7XG4gICAgICB0aGlzLl9oYSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYSA9IG51bGw7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZWR1Y2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAhdGhpcy5faHYgJiYgKHRoaXMuX2h2ID0gdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5faGEpIHtcbiAgICAgICAgdGhpcy5fYSA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9hLCB4LCB0aGlzLl9pLCB0aGlzLl9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2EgPSB0aGlzLl9ocyA/IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9zLCB4LCB0aGlzLl9pLCB0aGlzLl9wKSA6IHg7XG4gICAgICAgIHRoaXMuX2hhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX2EuZSk7IH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuXG4gICAgUmVkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgUmVkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2h2ICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX2EpO1xuICAgICAgIXRoaXMuX2h2ICYmIHRoaXMuX2hzICYmIHRoaXMuX28ub25OZXh0KHRoaXMuX3MpO1xuICAgICAgIXRoaXMuX2h2ICYmICF0aGlzLl9ocyAmJiB0aGlzLl9vLm9uRXJyb3IobmV3IEVtcHR5RXJyb3IoKSk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZWR1Y2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogQXBwbGllcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiBvdmVyIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZSBhZ2dyZWdhdGlvbiBhcyBhIHNpbmdsZSBlbGVtZW50IGluIHRoZSByZXN1bHQgc2VxdWVuY2UuIFRoZSBzcGVjaWZpZWQgc2VlZCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIGluY3JlbWVudGFsIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5zY2FuLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAqIEBwYXJhbSB7QW55fSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIGZpbmFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmVkdWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNTZWVkID0gZmFsc2UsIHNlZWQsIGFjY3VtdWxhdG9yID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBoYXNTZWVkID0gdHJ1ZTtcbiAgICAgIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkdWNlT2JzZXJ2YWJsZSh0aGlzLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCk7XG4gIH07XG5cbiAgdmFyIFNvbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTb21lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTb21lT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTb21lT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTb21lT2JzZXJ2ZXIobywgdGhpcy5fZm4sIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTb21lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTb21lT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNvbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNvbWVPYnNlcnZlcihvLCBmbiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNvbWVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgaWYgKEJvb2xlYW4ocmVzdWx0KSkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgU29tZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTb21lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KGZhbHNlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNvbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbnkgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHNhdGlzZmllcyBhIGNvbmRpdGlvbiBpZiBwcmVzZW50LCBlbHNlIGlmIGFueSBpdGVtcyBhcmUgaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXSBBIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IGZvciBhIGNvbmRpdGlvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgYW55IGVsZW1lbnRzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UgcGFzcyB0aGUgdGVzdCBpbiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSBpZiBnaXZlbiwgZWxzZSBpZiBhbnkgaXRlbXMgYXJlIGluIHRoZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zb21lID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU29tZU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIHZhciBJc0VtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSXNFbXB0eU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSXNFbXB0eU9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElzRW1wdHlPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IElzRW1wdHlPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJc0VtcHR5T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBJc0VtcHR5T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoSXNFbXB0eU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElzRW1wdHlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KGZhbHNlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuICAgIElzRW1wdHlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgSXNFbXB0eU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0cnVlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElzRW1wdHlPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgc291cmNlIHNlcXVlbmNlIGlzIGVtcHR5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJc0VtcHR5T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgRXZlcnlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFdmVyeU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXZlcnlPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEV2ZXJ5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBFdmVyeU9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXZlcnlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEV2ZXJ5T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV2ZXJ5T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBFdmVyeU9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRXZlcnlPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgaWYgKCFCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoZmFsc2UpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBFdmVyeU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBFdmVyeU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0cnVlKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZXJ5T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYWxsIGVsZW1lbnRzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugc2F0aXNmeSBhIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZV0gQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb24uXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgZGV0ZXJtaW5pbmcgd2hldGhlciBhbGwgZWxlbWVudHMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZSBwYXNzIHRoZSB0ZXN0IGluIHRoZSBzcGVjaWZpZWQgcHJlZGljYXRlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgRXZlcnlPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgSW5jbHVkZXNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmNsdWRlc09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSW5jbHVkZXNPYnNlcnZhYmxlKHNvdXJjZSwgZWxlbSwgaWR4KSB7XG4gICAgICB2YXIgbiA9ICtpZHggfHwgMDtcbiAgICAgIE1hdGguYWJzKG4pID09PSBJbmZpbml0eSAmJiAobiA9IDApO1xuXG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5fbiA9IG47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbmNsdWRlc09ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX24gPCAwKSB7XG4gICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbmNsdWRlc09ic2VydmVyKG8sIHRoaXMuX2VsZW0sIHRoaXMuX24pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEluY2x1ZGVzT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBJbmNsdWRlc09ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmNsdWRlc09ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluY2x1ZGVzT2JzZXJ2ZXIobywgZWxlbSwgbikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlcihhLCBiKSB7XG4gICAgICByZXR1cm4gKGEgPT09IDAgJiYgYiA9PT0gMCkgfHwgKGEgPT09IGIgfHwgKGlzTmFOKGEpICYmIGlzTmFOKGIpKSk7XG4gICAgfVxuXG4gICAgSW5jbHVkZXNPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5faSsrID49IHRoaXMuX24gJiYgY29tcGFyZXIoeCwgdGhpcy5fZWxlbSkpIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEluY2x1ZGVzT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIEluY2x1ZGVzT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbk5leHQoZmFsc2UpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gSW5jbHVkZXNPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGluY2x1ZGVzIGEgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBhbiBvcHRpb25hbCBlcXVhbGl0eSBjb21wYXJlci5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb21JbmRleF0gQW4gZXF1YWxpdHkgY29tcGFyZXIgdG8gY29tcGFyZSBlbGVtZW50cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpbmNsdWRlcyBhbiBlbGVtZW50IHRoYXQgaGFzIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uaW5jbHVkZXMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBJbmNsdWRlc09ic2VydmFibGUodGhpcywgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfTtcblxuICB2YXIgQ291bnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb3VudE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ291bnRPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENvdW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb3VudE9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ291bnRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvdW50T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvdW50T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBDb3VudE9ic2VydmVyKG8sIGZuLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fYyA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb3VudE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9mbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgIEJvb2xlYW4ocmVzdWx0KSAmJiAodGhpcy5fYysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2MrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIENvdW50T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIENvdW50T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX2MpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ291bnRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGhvdyBtYW55IGVsZW1lbnRzIGluIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBzYXRpc2Z5IGEgY29uZGl0aW9uIGlmIHByb3ZpZGVkLCBlbHNlIHRoZSBjb3VudCBvZiBpdGVtcy5cbiAgICogQGV4YW1wbGVcbiAgICogcmVzID0gc291cmNlLmNvdW50KCk7XG4gICAqIHJlcyA9IHNvdXJjZS5jb3VudChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA+IDM7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlXUEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIGhvdyBtYW55IGVsZW1lbnRzIGluIHRoZSBpbnB1dCBzZXF1ZW5jZSBzYXRpc2Z5IHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpZiBwcm92aWRlZCwgZWxzZSB0aGUgY291bnQgb2YgaXRlbXMgaW4gdGhlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvdW50ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgQ291bnRPYnNlcnZhYmxlKHRoaXMsIGZuKTtcbiAgfTtcblxuICB2YXIgSW5kZXhPZk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEluZGV4T2ZPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEluZGV4T2ZPYnNlcnZhYmxlKHNvdXJjZSwgZSwgbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5kZXhPZk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX24gPCAwKSB7XG4gICAgICAgIG8ub25OZXh0KC0xKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbmRleE9mT2JzZXJ2ZXIobywgdGhpcy5fZSwgdGhpcy5fbikpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW5kZXhPZk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgSW5kZXhPZk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbmRleE9mT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSW5kZXhPZk9ic2VydmVyKG8sIGUsIG4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9uID0gbjtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pID49IHRoaXMuX24gJiYgeCA9PT0gdGhpcy5fZSkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9pKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG4gICAgSW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBJbmRleE9mT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbk5leHQoLTEpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gSW5kZXhPZk9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QW55fSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gMC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuZCBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgbiA9ICtmcm9tSW5kZXggfHwgMDtcbiAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcbiAgICByZXR1cm4gbmV3IEluZGV4T2ZPYnNlcnZhYmxlKHRoaXMsIHNlYXJjaEVsZW1lbnQsIG4pO1xuICB9O1xuXG4gIHZhciBTdW1PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdW1PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN1bU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU3VtT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTdW1PYnNlcnZlcihvLCB0aGlzLl9mbiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1bU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU3VtT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN1bU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU3VtT2JzZXJ2ZXIobywgZm4sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9jID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN1bU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9mbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgIHRoaXMuX2MgKz0gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYyArPSB4O1xuICAgICAgfVxuICAgIH07XG4gICAgU3VtT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFN1bU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9jKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1bU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiBhIHNlcXVlbmNlIG9mIHZhbHVlcyB0aGF0IGFyZSBvYnRhaW5lZCBieSBpbnZva2luZyBhbiBvcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSwgZWxzZSBpZiBub3Qgc3BlY2lmaWVkIGNvbXB1dGVzIHRoZSBzdW0gb24gZWFjaCBpdGVtIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zdW0gPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2soa2V5U2VsZWN0b3IsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU3VtT2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgbWluaW11bSBrZXkgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWluQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudmFsdWU7IH0pO1xuICAgKiB2YXIgcmVzID0gc291cmNlLm1pbkJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCAtIHk7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBLZXkgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGtleSB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHplcm8gb3IgbW9yZSBlbGVtZW50cyB0aGF0IGhhdmUgYSBtaW5pbXVtIGtleSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5taW5CeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgY29tcGFyZXIpIHtcbiAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0U3ViQ29tcGFyZXIpO1xuICAgIHJldHVybiBuZXcgRXh0cmVtYUJ5T2JzZXJ2YWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGNvbXBhcmVyKHgsIHkpICogLTE7IH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbmFsIGNvbXBhcmVyIGVsc2UgYSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZXNzIHRoYW4gY2hlY2suXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWluKCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UubWluKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4LnZhbHVlIC0geS52YWx1ZTsgfSk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCB0aGUgbWluaW11bSBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWluID0gZnVuY3Rpb24gKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubWluQnkoaWRlbnRpdHksIGNvbXBhcmVyKS5tYXAoZmlyc3RPbmx5KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudHMgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBtYXhpbXVtICBrZXkgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UubWF4QnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudmFsdWU7IH0pO1xuICAgKiB2YXIgcmVzID0gc291cmNlLm1heEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnZhbHVlOyB9LCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCAtIHk7OyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgS2V5IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdICBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUga2V5IHZhbHVlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIGxpc3Qgb2YgemVybyBvciBtb3JlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1heGltdW0ga2V5IHZhbHVlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1heEJ5ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRTdWJDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBFeHRyZW1hQnlPYnNlcnZhYmxlKHRoaXMsIGtleVNlbGVjdG9yLCBjb21wYXJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBjb21wYXJlci5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXgoKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5tYXgoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgLSB5LnZhbHVlOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYSBzaW5nbGUgZWxlbWVudCB3aXRoIHRoZSBtYXhpbXVtIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5tYXggPSBmdW5jdGlvbiAoY29tcGFyZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhCeShpZGVudGl0eSwgY29tcGFyZXIpLm1hcChmaXJzdE9ubHkpO1xuICB9O1xuXG4gIHZhciBBdmVyYWdlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQXZlcmFnZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQXZlcmFnZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQXZlcmFnZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgQXZlcmFnZU9ic2VydmVyKG8sIHRoaXMuX2ZuLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXZlcmFnZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQXZlcmFnZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEF2ZXJhZ2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBBdmVyYWdlT2JzZXJ2ZXIobywgZm4sIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fYyA9IDA7XG4gICAgICB0aGlzLl90ID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEF2ZXJhZ2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZih0aGlzLl9mbikge1xuICAgICAgICB2YXIgciA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh4LCB0aGlzLl9jKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAociA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyLmUpOyB9XG4gICAgICAgIHRoaXMuX3QgKz0gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2MrKztcbiAgICAgICAgdGhpcy5fdCArPSB4O1xuICAgICAgfVxuICAgIH07XG4gICAgQXZlcmFnZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBBdmVyYWdlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9jID09PSAwKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IobmV3IEVtcHR5RXJyb3IoKSk7IH1cbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3QgLyB0aGlzLl9jKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF2ZXJhZ2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBhdmVyYWdlIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgdmFsdWVzIHRoYXQgYXJlIGluIHRoZSBzZXF1ZW5jZSBvciBvYnRhaW5lZCBieSBpbnZva2luZyBhIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggdGhlIGF2ZXJhZ2Ugb2YgdGhlIHNlcXVlbmNlIG9mIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5hdmVyYWdlID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMsIGZuO1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleVNlbGVjdG9yKSkge1xuICAgICAgZm4gPSBiaW5kQ2FsbGJhY2soa2V5U2VsZWN0b3IsIHRoaXNBcmcsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEF2ZXJhZ2VPYnNlcnZhYmxlKHNvdXJjZSwgZm4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBzZXF1ZW5jZXMgYXJlIGVxdWFsIGJ5IGNvbXBhcmluZyB0aGUgZWxlbWVudHMgcGFpcndpc2UgdXNpbmcgYSBzcGVjaWZpZWQgZXF1YWxpdHkgY29tcGFyZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSByZXMgPSBzb3VyY2Uuc2VxdWVuY2VFcXVhbChbMSwyLDNdKTtcbiAgICogdmFyIHJlcyA9IHJlcyA9IHNvdXJjZS5zZXF1ZW5jZUVxdWFsKFt7IHZhbHVlOiA0MiB9XSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgPT09IHkudmFsdWU7IH0pO1xuICAgKiAzIC0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoUnguT2JzZXJ2YWJsZS5yZXR1cm5WYWx1ZSg0MikpO1xuICAgKiA0IC0gcmVzID0gc291cmNlLnNlcXVlbmNlRXF1YWwoUnguT2JzZXJ2YWJsZS5yZXR1cm5WYWx1ZSh7IHZhbHVlOiA0MiB9KSwgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgudmFsdWUgPT09IHkudmFsdWU7IH0pO1xuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNlY29uZCBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBhcnJheSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBib3RoIHNlcXVlbmNlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBhIHNpbmdsZSBlbGVtZW50IHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIGJvdGggc2VxdWVuY2VzIGFyZSBvZiBlcXVhbCBsZW5ndGggYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgYXJlIGVxdWFsIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGVxdWFsaXR5IGNvbXBhcmVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNlcXVlbmNlRXF1YWwgPSBmdW5jdGlvbiAoc2Vjb25kLCBjb21wYXJlcikge1xuICAgIHZhciBmaXJzdCA9IHRoaXM7XG4gICAgY29tcGFyZXIgfHwgKGNvbXBhcmVyID0gZGVmYXVsdENvbXBhcmVyKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkb25lbCA9IGZhbHNlLCBkb25lciA9IGZhbHNlLCBxbCA9IFtdLCBxciA9IFtdO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjEgPSBmaXJzdC5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHFyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdiA9IHFyLnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIGVxdWFsID0gdHJ5Q2F0Y2goY29tcGFyZXIpKHYsIHgpO1xuICAgICAgICAgIGlmIChlcXVhbCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihlcXVhbC5lKTsgfVxuICAgICAgICAgIGlmICghZXF1YWwpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KGZhbHNlKTtcbiAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZXIpIHtcbiAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHFsLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uKGUpIHsgby5vbkVycm9yKGUpOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmVsID0gdHJ1ZTtcbiAgICAgICAgaWYgKHFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmIChxci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb25lcikge1xuICAgICAgICAgICAgby5vbk5leHQodHJ1ZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgKGlzQXJyYXlMaWtlKHNlY29uZCkgfHwgaXNJdGVyYWJsZShzZWNvbmQpKSAmJiAoc2Vjb25kID0gb2JzZXJ2YWJsZUZyb20oc2Vjb25kKSk7XG4gICAgICBpc1Byb21pc2Uoc2Vjb25kKSAmJiAoc2Vjb25kID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNlY29uZCkpO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjIgPSBzZWNvbmQuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChxbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHYgPSBxbC5zaGlmdCgpO1xuICAgICAgICAgIHZhciBlcXVhbCA9IHRyeUNhdGNoKGNvbXBhcmVyKSh2LCB4KTtcbiAgICAgICAgICBpZiAoZXF1YWwgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IoZXF1YWwuZSk7IH1cbiAgICAgICAgICBpZiAoIWVxdWFsKSB7XG4gICAgICAgICAgICBvLm9uTmV4dChmYWxzZSk7XG4gICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmVsKSB7XG4gICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxci5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlKSB7IG8ub25FcnJvcihlKTsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lciA9IHRydWU7XG4gICAgICAgIGlmIChxci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAocWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgby5vbk5leHQoZmFsc2UpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9uZWwpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KHRydWUpO1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uMSwgc3Vic2NyaXB0aW9uMik7XG4gICAgfSwgZmlyc3QpO1xuICB9O1xuXG4gIHZhciBFbGVtZW50QXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFbGVtZW50QXRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBdE9ic2VydmFibGUoc291cmNlLCBpLCBkKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFbGVtZW50QXRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IEVsZW1lbnRBdE9ic2VydmVyKG8sIHRoaXMuX2ksIHRoaXMuX2QpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEVsZW1lbnRBdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRWxlbWVudEF0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEVsZW1lbnRBdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRWxlbWVudEF0T2JzZXJ2ZXIobywgaSwgZCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9pID0gaTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRWxlbWVudEF0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX2ktLSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudEF0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIEVsZW1lbnRBdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9kKTtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRWxlbWVudEF0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4IGluIGEgc2VxdWVuY2Ugb3IgZGVmYXVsdCB2YWx1ZSBpZiBub3QgZm91bmQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXRyaWV2ZS5cbiAgICogQHBhcmFtIHtBbnl9IFtkZWZhdWx0VmFsdWVdIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBlbGVtZW50QXQgZG9lcyBub3QgZmluZCBhIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHByb2R1Y2VzIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5lbGVtZW50QXQgPSAgZnVuY3Rpb24gKGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50QXRPYnNlcnZhYmxlKHRoaXMsIGluZGV4LCBkZWZhdWx0VmFsdWUpO1xuICB9O1xuXG4gIHZhciBTaW5nbGVPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTaW5nbGVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTaW5nbGVPYnNlcnZlcihvLCBvYmosIHMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNpbmdsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaG91bGRZaWVsZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29iai5wcmVkaWNhdGUpKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgIEJvb2xlYW4ocmVzKSAmJiAoc2hvdWxkWWllbGQgPSB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgc2hvdWxkWWllbGQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFlpZWxkKSB7XG4gICAgICAgIGlmICh0aGlzLl9odikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vLm9uRXJyb3IobmV3IEVycm9yKCdTZXF1ZW5jZSBjb250YWlucyBtb3JlIHRoYW4gb25lIG1hdGNoaW5nIGVsZW1lbnQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faHYgPSB0cnVlO1xuICAgICAgICB0aGlzLl92ID0geDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNpbmdsZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTaW5nbGVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2h2KSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLl9vYmouZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFNpbmdsZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb25seSBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBpbiB0aGUgb3B0aW9uYWwgcHJlZGljYXRlLCBhbmQgcmVwb3J0cyBhbiBleGNlcHRpb24gaWYgdGhlcmUgaXMgbm90IGV4YWN0bHkgb25lIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNpbmdsZSBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZS5cbiAgICAgKi9cbiAgICBvYnNlcnZhYmxlUHJvdG8uc2luZ2xlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIG9iaiA9IHt9LCBzb3VyY2UgPSB0aGlzO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHtcbiAgICAgICAgICBwcmVkaWNhdGU6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICB0aGlzQXJnOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBhcmd1bWVudHNbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Z1bmN0aW9uIChvYmoucHJlZGljYXRlKSkge1xuICAgICAgICB2YXIgZm4gPSBvYmoucHJlZGljYXRlO1xuICAgICAgICBvYmoucHJlZGljYXRlID0gYmluZENhbGxiYWNrKGZuLCBvYmoudGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNpbmdsZU9ic2VydmVyKG8sIG9iaiwgc291cmNlKSk7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH07XG5cbiAgdmFyIEZpcnN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRmlyc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpcnN0T2JzZXJ2YWJsZShzb3VyY2UsIG9iaikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGaXJzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRmlyc3RPYnNlcnZlcihvLCB0aGlzLl9vYmosIHRoaXMuc291cmNlKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGaXJzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRmlyc3RPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaXJzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpcnN0T2JzZXJ2ZXIobywgb2JqLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYmoucHJlZGljYXRlKSh4LCB0aGlzLl9pKyssIHRoaXMuX3MpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICBpZiAoQm9vbGVhbihyZXMpKSB7XG4gICAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vYmoucHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX28ub25FcnJvcihuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX29iai5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGaXJzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBpZiBwcmVzZW50IGVsc2UgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gU2VxdWVuY2UgY29udGFpbmluZyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUgaWYgcHJvdmlkZWQsIGVsc2UgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB7fSwgc291cmNlID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqID0ge1xuICAgICAgICBwcmVkaWNhdGU6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgdGhpc0FyZzogYXJndW1lbnRzWzFdLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGFyZ3VtZW50c1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24gKG9iai5wcmVkaWNhdGUpKSB7XG4gICAgICB2YXIgZm4gPSBvYmoucHJlZGljYXRlO1xuICAgICAgb2JqLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhmbiwgb2JqLnRoaXNBcmcsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpcnN0T2JzZXJ2YWJsZSh0aGlzLCBvYmopO1xuICB9O1xuXG4gIHZhciBMYXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTGFzdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTGFzdE9ic2VydmFibGUoc291cmNlLCBvYmopIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTGFzdE9ic2VydmVyKG8sIHRoaXMuX29iaiwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIExhc3RPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhMYXN0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gTGFzdE9ic2VydmVyKG8sIG9iaiwgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3YgPSBudWxsO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBzaG91bGRZaWVsZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29iai5wcmVkaWNhdGUpKHgsIHRoaXMuX2krKywgdGhpcy5fcyk7XG4gICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgIEJvb2xlYW4ocmVzKSAmJiAoc2hvdWxkWWllbGQgPSB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX29iai5wcmVkaWNhdGUpIHtcbiAgICAgICAgc2hvdWxkWWllbGQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFlpZWxkKSB7XG4gICAgICAgIHRoaXMuX2h2ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdiA9IHg7XG4gICAgICB9XG4gICAgfTtcbiAgICBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIExhc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2h2KSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLl9vYmouZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fby5vbkVycm9yKG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQodGhpcy5fb2JqLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gaW4gdGhlIHByZWRpY2F0ZSBpZiBzcGVjaWZpZWQsIGVsc2UgdGhlIGxhc3QgZWxlbWVudC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGluIHRoZSBwcmVkaWNhdGUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge30sIHNvdXJjZSA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IHtcbiAgICAgICAgcHJlZGljYXRlOiBhcmd1bWVudHNbMF0sXG4gICAgICAgIHRoaXNBcmc6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uIChvYmoucHJlZGljYXRlKSkge1xuICAgICAgdmFyIGZuID0gb2JqLnByZWRpY2F0ZTtcbiAgICAgIG9iai5wcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2soZm4sIG9iai50aGlzQXJnLCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMYXN0T2JzZXJ2YWJsZSh0aGlzLCBvYmopO1xuICB9O1xuXG4gIHZhciBGaW5kVmFsdWVPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaW5kVmFsdWVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGaW5kVmFsdWVPYnNlcnZlcihvYnNlcnZlciwgc291cmNlLCBjYWxsYmFjaywgeWllbGRJbmRleCkge1xuICAgICAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5fcyA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2NiID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLl95ID0geWllbGRJbmRleDtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmluZFZhbHVlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHNob3VsZFJ1biA9IHRyeUNhdGNoKHRoaXMuX2NiKSh4LCB0aGlzLl9pLCB0aGlzLl9zKTtcbiAgICAgIGlmIChzaG91bGRSdW4gPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioc2hvdWxkUnVuLmUpOyB9XG4gICAgICBpZiAoc2hvdWxkUnVuKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3kgPyB0aGlzLl9pIDogeCk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2krKztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRmluZFZhbHVlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgRmluZFZhbHVlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3kgJiYgdGhpcy5fby5vbk5leHQoLTEpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmluZFZhbHVlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIGZ1bmN0aW9uIGZpbmRWYWx1ZSAoc291cmNlLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHlpZWxkSW5kZXgpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5kVmFsdWVPYnNlcnZlcihvLCBzb3VyY2UsIGNhbGxiYWNrLCB5aWVsZEluZGV4KSk7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgZGVmaW5lZCBieSB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSwgYW5kIHJldHVybnMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugd2l0aGluIHRoZSBlbnRpcmUgT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdGhhdCBkZWZpbmVzIHRoZSBjb25kaXRpb25zIG9mIHRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHByZWRpY2F0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgZGVmaW5lZCBieSB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSwgaWYgZm91bmQ7IG90aGVyd2lzZSwgdW5kZWZpbmVkLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZpbmRWYWx1ZSh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgdGhlIHNwZWNpZmllZCBwcmVkaWNhdGUsIGFuZCByZXR1cm5zXG4gICAqIGFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSB3aXRoaW4gdGhlIGVudGlyZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbmRpdGlvbnMgb2YgdGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyB0aGUgcHJlZGljYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkgbWF0Y2gsIGlmIGZvdW5kOyBvdGhlcndpc2UsIOKAkzEuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5maW5kSW5kZXggPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZpbmRWYWx1ZSh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHRydWUpO1xuICB9O1xuXG4gIHZhciBUb1NldE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRvU2V0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUb1NldE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRvU2V0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBUb1NldE9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvU2V0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUb1NldE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb1NldE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRvU2V0T2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gbmV3IHJvb3QuU2V0KCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb1NldE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3MuYWRkKHgpO1xuICAgIH07XG5cbiAgICBUb1NldE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFRvU2V0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3MpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9TZXRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGEgU2V0IGlmIGl0IGV4aXN0cy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSB2YWx1ZSBvZiBhIFNldCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50b1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHJvb3QuU2V0ID09PSAndW5kZWZpbmVkJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFRvU2V0T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVG9NYXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUb01hcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9NYXBPYnNlcnZhYmxlKHNvdXJjZSwgaywgZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9rID0gaztcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVG9NYXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRvTWFwT2JzZXJ2ZXIobywgdGhpcy5faywgdGhpcy5fZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9NYXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFRvTWFwT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRvTWFwT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9NYXBPYnNlcnZlcihvLCBrLCBlKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2sgPSBrO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICB0aGlzLl9tID0gbmV3IHJvb3QuTWFwKCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUb01hcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrZXkgPSB0cnlDYXRjaCh0aGlzLl9rKSh4KTtcbiAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB2YXIgZWxlbSA9IHg7XG4gICAgICBpZiAodGhpcy5fZSkge1xuICAgICAgICBlbGVtID0gdHJ5Q2F0Y2godGhpcy5fZSkoeCk7XG4gICAgICAgIGlmIChlbGVtID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGVsZW0uZSk7IH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fbS5zZXQoa2V5LCBlbGVtKTtcbiAgICB9O1xuXG4gICAgVG9NYXBPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBUb01hcE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9tKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvTWFwT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIENvbnZlcnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGEgTWFwIGlmIGl0IGV4aXN0cy5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlTZWxlY3RvciBBIGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIHRoZSBrZXkgZm9yIHRoZSBNYXAuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW2VsZW1lbnRTZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggcHJvZHVjZXMgdGhlIGVsZW1lbnQgZm9yIHRoZSBNYXAuIElmIG5vdCBwcmVzZW50LCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIHZhbHVlIG9mIGEgTWFwIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udG9NYXAgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3Rvcikge1xuICAgIGlmICh0eXBlb2Ygcm9vdC5NYXAgPT09ICd1bmRlZmluZWQnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgVG9NYXBPYnNlcnZhYmxlKHRoaXMsIGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpO1xuICB9O1xuXG4gIHZhciBTbGljZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNsaWNlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTbGljZU9ic2VydmFibGUoc291cmNlLCBiLCBlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgdGhpcy5fZSA9IGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTbGljZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2xpY2VPYnNlcnZlcihvLCB0aGlzLl9iLCB0aGlzLl9lKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTbGljZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2xpY2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2xpY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNsaWNlT2JzZXJ2ZXIobywgYiwgZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9iID0gYjtcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTbGljZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pID49IHRoaXMuX2IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2UgPT09IHRoaXMuX2kpIHtcbiAgICAgICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2krKztcbiAgICB9O1xuICAgIFNsaWNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFNsaWNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNsaWNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qXG4gICogVGhlIHNsaWNlKCkgbWV0aG9kIHJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIGFuIE9ic2VydmFibGUgaW50byBhIG5ldyBPYnNlcnZhYmxlIG9iamVjdC5cbiAgKiBVbmxpa2UgdGhlIGFycmF5IHZlcnNpb24sIHRoaXMgZG9lcyBub3Qgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzIGZvciBiZWluZyBvciBlbmQuXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtiZWdpbl0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLiBJZiBvbWl0dGVkLCB0aGlzIHdpbGwgZGVmYXVsdCB0byB6ZXJvLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kXSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGVuZCBleHRyYWN0aW9uLiBzbGljZSBleHRyYWN0cyB1cCB0byBidXQgbm90IGluY2x1ZGluZyBlbmQuXG4gICogSWYgb21pdHRlZCwgdGhpcyB3aWxsIGVtaXQgdGhlIHJlc3Qgb2YgdGhlIE9ic2VydmFibGUgb2JqZWN0LlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgYW4gT2JzZXJ2YWJsZSBpbnRvIGEgbmV3IE9ic2VydmFibGUgb2JqZWN0LlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2xpY2UgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgIHZhciBzdGFydCA9IGJlZ2luIHx8IDA7XG4gICAgaWYgKHN0YXJ0IDwgMCkgeyB0aHJvdyBuZXcgUnguQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJiBlbmQgPCBzdGFydCkge1xuICAgICAgdGhyb3cgbmV3IFJ4LkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2xpY2VPYnNlcnZhYmxlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICB9O1xuXG4gIHZhciBMYXN0SW5kZXhPZk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKExhc3RJbmRleE9mT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBMYXN0SW5kZXhPZk9ic2VydmFibGUoc291cmNlLCBlLCBuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2UgPSBlO1xuICAgICAgdGhpcy5fbiA9IG47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBMYXN0SW5kZXhPZk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHRoaXMuX24gPCAwKSB7XG4gICAgICAgIG8ub25OZXh0KC0xKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBMYXN0SW5kZXhPZk9ic2VydmVyKG8sIHRoaXMuX2UsIHRoaXMuX24pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExhc3RJbmRleE9mT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBMYXN0SW5kZXhPZk9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhMYXN0SW5kZXhPZk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIExhc3RJbmRleE9mT2JzZXJ2ZXIobywgZSwgbikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9lID0gZTtcbiAgICAgIHRoaXMuX24gPSBuO1xuICAgICAgdGhpcy5fdiA9IDA7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBMYXN0SW5kZXhPZk9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9pID49IHRoaXMuX24gJiYgeCA9PT0gdGhpcy5fZSkge1xuICAgICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3YgPSB0aGlzLl9pO1xuICAgICAgfVxuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG4gICAgTGFzdEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgTGFzdEluZGV4T2ZPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2h2KSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoLTEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGFzdEluZGV4T2ZPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QW55fSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXhdIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gMC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuZCBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgbiA9ICtmcm9tSW5kZXggfHwgMDtcbiAgICBNYXRoLmFicyhuKSA9PT0gSW5maW5pdHkgJiYgKG4gPSAwKTtcbiAgICByZXR1cm4gbmV3IExhc3RJbmRleE9mT2JzZXJ2YWJsZSh0aGlzLCBzZWFyY2hFbGVtZW50LCBuKTtcbiAgfTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVQcm90byIsInByb3RvdHlwZSIsIkJpbmFyeURpc3Bvc2FibGUiLCJBbm9ueW1vdXNPYnNlcnZhYmxlIiwiQWJzdHJhY3RPYnNlcnZlciIsImludGVybmFscyIsImRpc3Bvc2FibGVFbXB0eSIsIkRpc3Bvc2FibGUiLCJlbXB0eSIsImhlbHBlcnMiLCJkZWZhdWx0Q29tcGFyZXIiLCJpZGVudGl0eSIsImRlZmF1bHRTdWJDb21wYXJlciIsImlzRnVuY3Rpb24iLCJpc1Byb21pc2UiLCJpc0FycmF5TGlrZSIsImlzSXRlcmFibGUiLCJpbmhlcml0cyIsIm9ic2VydmFibGVGcm9tUHJvbWlzZSIsImZyb21Qcm9taXNlIiwib2JzZXJ2YWJsZUZyb20iLCJmcm9tIiwiYmluZENhbGxiYWNrIiwiRW1wdHlFcnJvciIsIk9ic2VydmFibGVCYXNlIiwiQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IiLCJlcnJvck9iaiIsImUiLCJ0cnlDYXRjaGVyR2VuIiwidHJ5Q2F0Y2hUYXJnZXQiLCJ0cnlDYXRjaGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ0cnlDYXRjaCIsImZuIiwiVHlwZUVycm9yIiwidGhyb3dlciIsIkV4dHJlbWFCeU9ic2VydmFibGUiLCJfX3N1cGVyX18iLCJzb3VyY2UiLCJrIiwiYyIsIl9rIiwiX2MiLCJzdWJzY3JpYmVDb3JlIiwibyIsInN1YnNjcmliZSIsIkV4dHJlbWFCeU9ic2VydmVyIiwiX28iLCJfdiIsIl9odiIsIl9sIiwibmV4dCIsIngiLCJrZXkiLCJvbkVycm9yIiwiY29tcGFyaXNvbiIsInB1c2giLCJlcnJvciIsImNvbXBsZXRlZCIsIm9uTmV4dCIsIm9uQ29tcGxldGVkIiwiZmlyc3RPbmx5IiwibGVuZ3RoIiwiUmVkdWNlT2JzZXJ2YWJsZSIsImFjY3VtdWxhdG9yIiwiaGFzU2VlZCIsInNlZWQiLCJvYnNlcnZlciIsIlJlZHVjZU9ic2VydmVyIiwicGFyZW50IiwiX3AiLCJfZm4iLCJfaHMiLCJfcyIsIl9oYSIsIl9hIiwiX2kiLCJyZWR1Y2UiLCJTb21lT2JzZXJ2YWJsZSIsIlNvbWVPYnNlcnZlciIsInMiLCJyZXN1bHQiLCJCb29sZWFuIiwic29tZSIsInByZWRpY2F0ZSIsInRoaXNBcmciLCJJc0VtcHR5T2JzZXJ2YWJsZSIsIklzRW1wdHlPYnNlcnZlciIsImlzRW1wdHkiLCJFdmVyeU9ic2VydmFibGUiLCJFdmVyeU9ic2VydmVyIiwiZXZlcnkiLCJJbmNsdWRlc09ic2VydmFibGUiLCJlbGVtIiwiaWR4IiwibiIsIk1hdGgiLCJhYnMiLCJJbmZpbml0eSIsIl9lbGVtIiwiX24iLCJJbmNsdWRlc09ic2VydmVyIiwiY29tcGFyZXIiLCJhIiwiYiIsImlzTmFOIiwiaW5jbHVkZXMiLCJzZWFyY2hFbGVtZW50IiwiZnJvbUluZGV4IiwiQ291bnRPYnNlcnZhYmxlIiwiQ291bnRPYnNlcnZlciIsImNvdW50IiwiSW5kZXhPZk9ic2VydmFibGUiLCJfZSIsIkluZGV4T2ZPYnNlcnZlciIsImluZGV4T2YiLCJTdW1PYnNlcnZhYmxlIiwiU3VtT2JzZXJ2ZXIiLCJzdW0iLCJrZXlTZWxlY3RvciIsIm1pbkJ5IiwieSIsIm1pbiIsIm1hcCIsIm1heEJ5IiwibWF4IiwiQXZlcmFnZU9ic2VydmFibGUiLCJBdmVyYWdlT2JzZXJ2ZXIiLCJfdCIsInIiLCJhdmVyYWdlIiwic2VxdWVuY2VFcXVhbCIsInNlY29uZCIsImZpcnN0IiwiZG9uZWwiLCJkb25lciIsInFsIiwicXIiLCJzdWJzY3JpcHRpb24xIiwidiIsInNoaWZ0IiwiZXF1YWwiLCJzdWJzY3JpcHRpb24yIiwiRWxlbWVudEF0T2JzZXJ2YWJsZSIsImkiLCJkIiwiX2QiLCJFbGVtZW50QXRPYnNlcnZlciIsImVsZW1lbnRBdCIsImluZGV4IiwiZGVmYXVsdFZhbHVlIiwiU2luZ2xlT2JzZXJ2ZXIiLCJvYmoiLCJfb2JqIiwic2hvdWxkWWllbGQiLCJyZXMiLCJFcnJvciIsInNpbmdsZSIsIkZpcnN0T2JzZXJ2YWJsZSIsIkZpcnN0T2JzZXJ2ZXIiLCJMYXN0T2JzZXJ2YWJsZSIsIkxhc3RPYnNlcnZlciIsImxhc3QiLCJGaW5kVmFsdWVPYnNlcnZlciIsImNhbGxiYWNrIiwieWllbGRJbmRleCIsIl9jYiIsIl95Iiwic2hvdWxkUnVuIiwiZmluZFZhbHVlIiwiZmluZCIsImZpbmRJbmRleCIsIlRvU2V0T2JzZXJ2YWJsZSIsIlRvU2V0T2JzZXJ2ZXIiLCJTZXQiLCJhZGQiLCJ0b1NldCIsIlRvTWFwT2JzZXJ2YWJsZSIsIlRvTWFwT2JzZXJ2ZXIiLCJfbSIsIk1hcCIsInNldCIsInRvTWFwIiwiZWxlbWVudFNlbGVjdG9yIiwiU2xpY2VPYnNlcnZhYmxlIiwiX2IiLCJTbGljZU9ic2VydmVyIiwic2xpY2UiLCJiZWdpbiIsImVuZCIsInN0YXJ0IiwiTGFzdEluZGV4T2ZPYnNlcnZhYmxlIiwiTGFzdEluZGV4T2ZPYnNlcnZlciIsImxhc3RJbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.aggregates.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.async.js":
/*!******************************************!*\
  !*** ./node_modules/rx/dist/rx.async.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx.binding */ \"(ssr)/./node_modules/rx/dist/rx.binding.js\"),\n            exports\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            root.Rx = factory(root, exports1, Rx);\n            return root.Rx;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // Aliases\n    var Observable = Rx.Observable, observableFromPromise = Observable.fromPromise, observableThrow = Observable.throwError, AnonymousObservable = Rx.AnonymousObservable, ObservableBase = Rx.ObservableBase, AsyncSubject = Rx.AsyncSubject, disposableCreate = Rx.Disposable.create, CompositeDisposable = Rx.CompositeDisposable, immediateScheduler = Rx.Scheduler.immediate, defaultScheduler = Rx.Scheduler[\"default\"], inherits = Rx.internals.inherits, isScheduler = Rx.Scheduler.isScheduler, isPromise = Rx.helpers.isPromise, isFunction = Rx.helpers.isFunction, isIterable = Rx.helpers.isIterable, isArrayLike = Rx.helpers.isArrayLike;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    Observable.wrap = function(fn) {\n        function createObservable() {\n            return Observable.spawn.call(this, fn.apply(this, arguments));\n        }\n        createObservable.__generatorFunction__ = fn;\n        return createObservable;\n    };\n    var spawn = Observable.spawn = function() {\n        var gen = arguments[0], self1 = this, args = [];\n        for(var i = 1, len = arguments.length; i < len; i++){\n            args.push(arguments[i]);\n        }\n        return new AnonymousObservable(function(o) {\n            var g = new CompositeDisposable();\n            if (isFunction(gen)) {\n                gen = gen.apply(self1, args);\n            }\n            if (!gen || !isFunction(gen.next)) {\n                o.onNext(gen);\n                return o.onCompleted();\n            }\n            function processGenerator(res) {\n                var ret = tryCatch(gen.next).call(gen, res);\n                if (ret === errorObj) {\n                    return o.onError(ret.e);\n                }\n                next(ret);\n            }\n            processGenerator();\n            function onError(err) {\n                var ret = tryCatch(gen.next).call(gen, err);\n                if (ret === errorObj) {\n                    return o.onError(ret.e);\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    o.onNext(ret.value);\n                    o.onCompleted();\n                    return;\n                }\n                var obs = toObservable.call(self1, ret.value);\n                var value = null;\n                var hasValue = false;\n                if (Observable.isObservable(obs)) {\n                    g.add(obs.subscribe(function(val) {\n                        hasValue = true;\n                        value = val;\n                    }, onError, function() {\n                        hasValue && processGenerator(value);\n                    }));\n                } else {\n                    onError(new TypeError(\"type not supported\"));\n                }\n            }\n            return g;\n        });\n    };\n    function toObservable(obj) {\n        if (!obj) {\n            return obj;\n        }\n        if (Observable.isObservable(obj)) {\n            return obj;\n        }\n        if (isPromise(obj)) {\n            return Observable.fromPromise(obj);\n        }\n        if (isGeneratorFunction(obj) || isGenerator(obj)) {\n            return spawn.call(this, obj);\n        }\n        if (isFunction(obj)) {\n            return thunkToObservable.call(this, obj);\n        }\n        if (isArrayLike(obj) || isIterable(obj)) {\n            return arrayToObservable.call(this, obj);\n        }\n        if (isObject(obj)) {\n            return objectToObservable.call(this, obj);\n        }\n        return obj;\n    }\n    function arrayToObservable(obj) {\n        return Observable.from(obj).concatMap(function(o) {\n            if (Observable.isObservable(o) || isObject(o)) {\n                return toObservable.call(null, o);\n            } else {\n                return Rx.Observable.just(o);\n            }\n        }).toArray();\n    }\n    function objectToObservable(obj) {\n        var results = new obj.constructor(), keys = Object.keys(obj), observables = [];\n        for(var i = 0, len = keys.length; i < len; i++){\n            var key = keys[i];\n            var observable = toObservable.call(this, obj[key]);\n            if (observable && Observable.isObservable(observable)) {\n                defer(observable, key);\n            } else {\n                results[key] = obj[key];\n            }\n        }\n        return Observable.forkJoin.apply(Observable, observables).map(function() {\n            return results;\n        });\n        function defer(observable, key) {\n            results[key] = undefined;\n            observables.push(observable.map(function(next) {\n                results[key] = next;\n            }));\n        }\n    }\n    function thunkToObservable(fn) {\n        var self1 = this;\n        return new AnonymousObservable(function(o) {\n            fn.call(self1, function() {\n                var err = arguments[0], res = arguments[1];\n                if (err) {\n                    return o.onError(err);\n                }\n                if (arguments.length > 2) {\n                    var args = [];\n                    for(var i = 1, len = arguments.length; i < len; i++){\n                        args.push(arguments[i]);\n                    }\n                    res = args;\n                }\n                o.onNext(res);\n                o.onCompleted();\n            });\n        });\n    }\n    function isGenerator(obj) {\n        return isFunction(obj.next) && isFunction(obj[\"throw\"]);\n    }\n    function isGeneratorFunction(obj) {\n        var ctor = obj.constructor;\n        if (!ctor) {\n            return false;\n        }\n        if (ctor.name === \"GeneratorFunction\" || ctor.displayName === \"GeneratorFunction\") {\n            return true;\n        }\n        return isGenerator(ctor.prototype);\n    }\n    function isObject(val) {\n        return Object == val.constructor;\n    }\n    /**\n   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.\n   *\n   * @example\n   * var res = Rx.Observable.start(function () { console.log('hello'); });\n   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);\n   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);\n   *\n   * @param {Function} func Function to run asynchronously.\n   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.\n   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.\n   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n   *\n   * Remarks\n   * * The function is called immediately, not during the subscription of the resulting sequence.\n   * * Multiple subscriptions to the resulting sequence can observe the function's result.\n   */ Observable.start = function(func, context, scheduler) {\n        return observableToAsync(func, context, scheduler)();\n    };\n    /**\n   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.\n   * @param {Function} function Function to convert to an asynchronous function.\n   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.\n   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n   * @returns {Function} Asynchronous function.\n   */ var observableToAsync = Observable.toAsync = function(func, context, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return function() {\n            var args = arguments, subject = new AsyncSubject();\n            scheduler.schedule(null, function() {\n                var result;\n                try {\n                    result = func.apply(context, args);\n                } catch (e) {\n                    subject.onError(e);\n                    return;\n                }\n                subject.onNext(result);\n                subject.onCompleted();\n            });\n            return subject.asObservable();\n        };\n    };\n    function createCbObservable(fn, ctx, selector, args) {\n        var o = new AsyncSubject();\n        args.push(createCbHandler(o, ctx, selector));\n        fn.apply(ctx, args);\n        return o.asObservable();\n    }\n    function createCbHandler(o, ctx, selector) {\n        return function handler() {\n            var len = arguments.length, results = new Array(len);\n            for(var i = 0; i < len; i++){\n                results[i] = arguments[i];\n            }\n            if (isFunction(selector)) {\n                results = tryCatch(selector).apply(ctx, results);\n                if (results === errorObj) {\n                    return o.onError(results.e);\n                }\n                o.onNext(results);\n            } else {\n                if (results.length <= 1) {\n                    o.onNext(results[0]);\n                } else {\n                    o.onNext(results);\n                }\n            }\n            o.onCompleted();\n        };\n    }\n    /**\n * Converts a callback function to an observable sequence.\n *\n * @param {Function} fn Function with a callback as the last parameter to convert to an Observable sequence.\n * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.\n * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.\n */ Observable.fromCallback = function(fn, ctx, selector) {\n        return function() {\n            typeof ctx === \"undefined\" && (ctx = this);\n            var len = arguments.length, args = new Array(len);\n            for(var i = 0; i < len; i++){\n                args[i] = arguments[i];\n            }\n            return createCbObservable(fn, ctx, selector, args);\n        };\n    };\n    function createNodeObservable(fn, ctx, selector, args) {\n        var o = new AsyncSubject();\n        args.push(createNodeHandler(o, ctx, selector));\n        fn.apply(ctx, args);\n        return o.asObservable();\n    }\n    function createNodeHandler(o, ctx, selector) {\n        return function handler() {\n            var err = arguments[0];\n            if (err) {\n                return o.onError(err);\n            }\n            var len = arguments.length, results = [];\n            for(var i = 1; i < len; i++){\n                results[i - 1] = arguments[i];\n            }\n            if (isFunction(selector)) {\n                var results = tryCatch(selector).apply(ctx, results);\n                if (results === errorObj) {\n                    return o.onError(results.e);\n                }\n                o.onNext(results);\n            } else {\n                if (results.length <= 1) {\n                    o.onNext(results[0]);\n                } else {\n                    o.onNext(results);\n                }\n            }\n            o.onCompleted();\n        };\n    }\n    /**\n * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.\n * @param {Function} fn The function to call\n * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.\n * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.\n */ Observable.fromNodeCallback = function(fn, ctx, selector) {\n        return function() {\n            typeof ctx === \"undefined\" && (ctx = this);\n            var len = arguments.length, args = new Array(len);\n            for(var i = 0; i < len; i++){\n                args[i] = arguments[i];\n            }\n            return createNodeObservable(fn, ctx, selector, args);\n        };\n    };\n    function isNodeList(el) {\n        if (root.StaticNodeList) {\n            // IE8 Specific\n            // instanceof is slower than Object#toString, but Object#toString will not work as intended in IE8\n            return el instanceof root.StaticNodeList || el instanceof root.NodeList;\n        } else {\n            return Object.prototype.toString.call(el) === \"[object NodeList]\";\n        }\n    }\n    function ListenDisposable(e, n, fn) {\n        this._e = e;\n        this._n = n;\n        this._fn = fn;\n        this._e.addEventListener(this._n, this._fn, false);\n        this.isDisposed = false;\n    }\n    ListenDisposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this._e.removeEventListener(this._n, this._fn, false);\n            this.isDisposed = true;\n        }\n    };\n    function createEventListener(el, eventName, handler) {\n        var disposables = new CompositeDisposable();\n        // Asume NodeList or HTMLCollection\n        var elemToString = Object.prototype.toString.call(el);\n        if (isNodeList(el) || elemToString === \"[object HTMLCollection]\") {\n            for(var i = 0, len = el.length; i < len; i++){\n                disposables.add(createEventListener(el.item(i), eventName, handler));\n            }\n        } else if (el) {\n            disposables.add(new ListenDisposable(el, eventName, handler));\n        }\n        return disposables;\n    }\n    /**\n   * Configuration option to determine whether to use native events only\n   */ Rx.config.useNativeEvents = false;\n    var EventObservable = function(__super__) {\n        inherits(EventObservable, __super__);\n        function EventObservable(el, name, fn) {\n            this._el = el;\n            this._n = name;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        function createHandler(o, fn) {\n            return function handler() {\n                var results = arguments[0];\n                if (isFunction(fn)) {\n                    results = tryCatch(fn).apply(null, arguments);\n                    if (results === errorObj) {\n                        return o.onError(results.e);\n                    }\n                }\n                o.onNext(results);\n            };\n        }\n        EventObservable.prototype.subscribeCore = function(o) {\n            return createEventListener(this._el, this._n, createHandler(o, this._fn));\n        };\n        return EventObservable;\n    }(ObservableBase);\n    /**\n   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.\n   * @param {Object} element The DOMElement or NodeList to attach a listener.\n   * @param {String} eventName The event name to attach the observable sequence.\n   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n   * @returns {Observable} An observable sequence of events from the specified element and the specified event.\n   */ Observable.fromEvent = function(element, eventName, selector) {\n        // Node.js specific\n        if (element.addListener) {\n            return fromEventPattern(function(h) {\n                element.addListener(eventName, h);\n            }, function(h) {\n                element.removeListener(eventName, h);\n            }, selector);\n        }\n        // Use only if non-native events are allowed\n        if (!Rx.config.useNativeEvents) {\n            // Handles jq, Angular.js, Zepto, Marionette, Ember.js\n            if (typeof element.on === \"function\" && typeof element.off === \"function\") {\n                return fromEventPattern(function(h) {\n                    element.on(eventName, h);\n                }, function(h) {\n                    element.off(eventName, h);\n                }, selector);\n            }\n        }\n        return new EventObservable(element, eventName, selector).publish().refCount();\n    };\n    var EventPatternObservable = function(__super__) {\n        inherits(EventPatternObservable, __super__);\n        function EventPatternObservable(add, del, fn) {\n            this._add = add;\n            this._del = del;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        function createHandler(o, fn) {\n            return function handler() {\n                var results = arguments[0];\n                if (isFunction(fn)) {\n                    results = tryCatch(fn).apply(null, arguments);\n                    if (results === errorObj) {\n                        return o.onError(results.e);\n                    }\n                }\n                o.onNext(results);\n            };\n        }\n        EventPatternObservable.prototype.subscribeCore = function(o) {\n            var fn = createHandler(o, this._fn);\n            var returnValue = this._add(fn);\n            return new EventPatternDisposable(this._del, fn, returnValue);\n        };\n        function EventPatternDisposable(del, fn, ret) {\n            this._del = del;\n            this._fn = fn;\n            this._ret = ret;\n            this.isDisposed = false;\n        }\n        EventPatternDisposable.prototype.dispose = function() {\n            if (!this.isDisposed) {\n                isFunction(this._del) && this._del(this._fn, this._ret);\n                this.isDisposed = true;\n            }\n        };\n        return EventPatternObservable;\n    }(ObservableBase);\n    /**\n   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.\n   * @param {Function} addHandler The function to add a handler to the emitter.\n   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.\n   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n   * @returns {Observable} An observable sequence which wraps an event from an event emitter\n   */ var fromEventPattern = Observable.fromEventPattern = function(addHandler, removeHandler, selector) {\n        return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();\n    };\n    /**\n   * Invokes the asynchronous function, surfacing the result through an observable sequence.\n   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.\n   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n   */ Observable.startAsync = function(functionAsync) {\n        var promise = tryCatch(functionAsync)();\n        if (promise === errorObj) {\n            return observableThrow(promise.e);\n        }\n        return observableFromPromise(promise);\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxLQUFLLElBQUksQ0FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQzlCLEdBQUcsRUFBRSxJQUFJLENBQUNpQyxJQUFJO2dCQUN0RCxJQUFJLENBQUMvQixVQUFVLEdBQUc7WUFDcEI7UUFDRjtRQUVBLE9BQU95QjtJQUNULEVBQUV6STtJQUVGOzs7Ozs7R0FNQyxHQUNELElBQUlrSSxtQkFBbUJ4SSxXQUFXd0ksZ0JBQWdCLEdBQUcsU0FBVWMsVUFBVSxFQUFFQyxhQUFhLEVBQUVwRCxRQUFRO1FBQ2hHLE9BQU8sSUFBSTRDLHVCQUF1Qk8sWUFBWUMsZUFBZXBELFVBQVUwQyxPQUFPLEdBQUdDLFFBQVE7SUFDM0Y7SUFFQTs7OztHQUlDLEdBQ0Q5SSxXQUFXd0osVUFBVSxHQUFHLFNBQVVDLGFBQWE7UUFDN0MsSUFBSUMsVUFBVTNILFNBQVMwSDtRQUN2QixJQUFJQyxZQUFZbEksVUFBVTtZQUFFLE9BQU9yQixnQkFBZ0J1SixRQUFRakksQ0FBQztRQUFHO1FBQy9ELE9BQU94QixzQkFBc0J5SjtJQUMvQjtJQUVBLE9BQU8vSjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9kaXN0L3J4LmFzeW5jLmpzPzMxYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQsIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLk9iamVjdCA9PT0gT2JqZWN0KSA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIHZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkgPyBleHBvcnRzIDogbnVsbDtcbiAgdmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpID8gbW9kdWxlIDogbnVsbDtcbiAgdmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCk7XG4gIHZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcbiAgdmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IChmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpID8gZnJlZUV4cG9ydHMgOiBudWxsO1xuICB2YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLy8gQmVjYXVzZSBvZiBidWlsZCBvcHRpbWl6ZXJzXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWycuL3J4LmJpbmRpbmcnLCAnZXhwb3J0cyddLCBmdW5jdGlvbiAoUngsIGV4cG9ydHMpIHtcbiAgICAgIHJvb3QuUnggPSBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIFJ4KTtcbiAgICAgIHJldHVybiByb290LlJ4O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCwgbW9kdWxlLmV4cG9ydHMsIHJlcXVpcmUoJy4vcngnKSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5SeCA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuUngpO1xuICB9XG59LmNhbGwodGhpcywgZnVuY3Rpb24gKHJvb3QsIGV4cCwgUngsIHVuZGVmaW5lZCkge1xuXG4gIC8vIEFsaWFzZXNcbiAgdmFyIE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLFxuICAgIG9ic2VydmFibGVGcm9tUHJvbWlzZSA9IE9ic2VydmFibGUuZnJvbVByb21pc2UsXG4gICAgb2JzZXJ2YWJsZVRocm93ID0gT2JzZXJ2YWJsZS50aHJvd0Vycm9yLFxuICAgIEFub255bW91c09ic2VydmFibGUgPSBSeC5Bbm9ueW1vdXNPYnNlcnZhYmxlLFxuICAgIE9ic2VydmFibGVCYXNlID0gUnguT2JzZXJ2YWJsZUJhc2UsXG4gICAgQXN5bmNTdWJqZWN0ID0gUnguQXN5bmNTdWJqZWN0LFxuICAgIGRpc3Bvc2FibGVDcmVhdGUgPSBSeC5EaXNwb3NhYmxlLmNyZWF0ZSxcbiAgICBDb21wb3NpdGVEaXNwb3NhYmxlID0gUnguQ29tcG9zaXRlRGlzcG9zYWJsZSxcbiAgICBpbW1lZGlhdGVTY2hlZHVsZXIgPSBSeC5TY2hlZHVsZXIuaW1tZWRpYXRlLFxuICAgIGRlZmF1bHRTY2hlZHVsZXIgPSBSeC5TY2hlZHVsZXJbJ2RlZmF1bHQnXSxcbiAgICBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyxcbiAgICBpc1NjaGVkdWxlciA9IFJ4LlNjaGVkdWxlci5pc1NjaGVkdWxlcixcbiAgICBpc1Byb21pc2UgPSBSeC5oZWxwZXJzLmlzUHJvbWlzZSxcbiAgICBpc0Z1bmN0aW9uID0gUnguaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgIGlzSXRlcmFibGUgPSBSeC5oZWxwZXJzLmlzSXRlcmFibGUsXG4gICAgaXNBcnJheUxpa2UgPSBSeC5oZWxwZXJzLmlzQXJyYXlMaWtlO1xuXG4gIHZhciBlcnJvck9iaiA9IHtlOiB7fX07XG4gIFxuICBmdW5jdGlvbiB0cnlDYXRjaGVyR2VuKHRyeUNhdGNoVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyeUNhdGNoID0gUnguaW50ZXJuYWxzLnRyeUNhdGNoID0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZuIG11c3QgYmUgYSBmdW5jdGlvbicpOyB9XG4gICAgcmV0dXJuIHRyeUNhdGNoZXJHZW4oZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgIHRocm93IGU7XG4gIH1cblxuICBPYnNlcnZhYmxlLndyYXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKCkge1xuICAgICAgcmV0dXJuIE9ic2VydmFibGUuc3Bhd24uY2FsbCh0aGlzLCBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVPYnNlcnZhYmxlLl9fZ2VuZXJhdG9yRnVuY3Rpb25fXyA9IGZuO1xuICAgIHJldHVybiBjcmVhdGVPYnNlcnZhYmxlO1xuICB9O1xuXG4gIHZhciBzcGF3biA9IE9ic2VydmFibGUuc3Bhd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGFyZ3VtZW50c1swXSwgc2VsZiA9IHRoaXMsIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3MucHVzaChhcmd1bWVudHNbaV0pOyB9XG5cbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oZ2VuKSkgeyBnZW4gPSBnZW4uYXBwbHkoc2VsZiwgYXJncyk7IH1cbiAgICAgIGlmICghZ2VuIHx8ICFpc0Z1bmN0aW9uKGdlbi5uZXh0KSkge1xuICAgICAgICBvLm9uTmV4dChnZW4pO1xuICAgICAgICByZXR1cm4gby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzR2VuZXJhdG9yKHJlcykge1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goZ2VuLm5leHQpLmNhbGwoZ2VuLCByZXMpO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJldC5lKTsgfVxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NHZW5lcmF0b3IoKTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGdlbi5uZXh0KS5jYWxsKGdlbiwgZXJyKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXQuZSk7IH1cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICBpZiAocmV0LmRvbmUpIHtcbiAgICAgICAgICBvLm9uTmV4dChyZXQudmFsdWUpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9icyA9IHRvT2JzZXJ2YWJsZS5jYWxsKHNlbGYsIHJldC52YWx1ZSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUob2JzKSkge1xuICAgICAgICAgIGcuYWRkKG9icy5zdWJzY3JpYmUoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbDtcbiAgICAgICAgICB9LCBvbkVycm9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhhc1ZhbHVlICYmIHByb2Nlc3NHZW5lcmF0b3IodmFsdWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkVycm9yKG5ldyBUeXBlRXJyb3IoJ3R5cGUgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b09ic2VydmFibGUob2JqKSB7XG4gICAgaWYgKCFvYmopIHsgcmV0dXJuIG9iajsgfVxuICAgIGlmIChPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShvYmopKSB7IHJldHVybiBvYmo7IH1cbiAgICBpZiAoaXNQcm9taXNlKG9iaikpIHsgcmV0dXJuIE9ic2VydmFibGUuZnJvbVByb21pc2Uob2JqKTsgfVxuICAgIGlmIChpc0dlbmVyYXRvckZ1bmN0aW9uKG9iaikgfHwgaXNHZW5lcmF0b3Iob2JqKSkgeyByZXR1cm4gc3Bhd24uY2FsbCh0aGlzLCBvYmopOyB9XG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSkgeyByZXR1cm4gdGh1bmtUb09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmopOyB9XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgfHwgaXNJdGVyYWJsZShvYmopKSB7IHJldHVybiBhcnJheVRvT2JzZXJ2YWJsZS5jYWxsKHRoaXMsIG9iaik7IH1cbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge3JldHVybiBvYmplY3RUb09ic2VydmFibGUuY2FsbCh0aGlzLCBvYmopO31cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlUb09ic2VydmFibGUgKG9iaikge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20ob2JqKS5jb25jYXRNYXAoZnVuY3Rpb24obykge1xuICAgICAgaWYoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUobykgfHwgaXNPYmplY3QobykpIHtcbiAgICAgICAgcmV0dXJuIHRvT2JzZXJ2YWJsZS5jYWxsKG51bGwsIG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuanVzdChvKTtcbiAgICAgIH1cbiAgICB9KS50b0FycmF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RUb09ic2VydmFibGUgKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpLCBrZXlzID0gT2JqZWN0LmtleXMob2JqKSwgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRvT2JzZXJ2YWJsZS5jYWxsKHRoaXMsIG9ialtrZXldKTtcblxuICAgICAgaWYob2JzZXJ2YWJsZSAmJiBPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSkge1xuICAgICAgICBkZWZlcihvYnNlcnZhYmxlLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9ic2VydmFibGUuZm9ya0pvaW4uYXBwbHkoT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZXMpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pO1xuXG5cbiAgICBmdW5jdGlvbiBkZWZlciAob2JzZXJ2YWJsZSwga2V5KSB7XG4gICAgICByZXN1bHRzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICBvYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUubWFwKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJlc3VsdHNba2V5XSA9IG5leHQ7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGh1bmtUb09ic2VydmFibGUoZm4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICBmbi5jYWxsKHNlbGYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXSwgcmVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBvLm9uRXJyb3IoZXJyKTsgfVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7IH1cbiAgICAgICAgICByZXMgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIG8ub25OZXh0KHJlcyk7XG4gICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZW5lcmF0b3Iob2JqKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24gKG9iai5uZXh0KSAmJiBpc0Z1bmN0aW9uIChvYmpbJ3Rocm93J10pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoIWN0b3IpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGN0b3IubmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJyB8fCBjdG9yLmRpc3BsYXlOYW1lID09PSAnR2VuZXJhdG9yRnVuY3Rpb24nKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmV0dXJuIGlzR2VuZXJhdG9yKGN0b3IucHJvdG90eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBPYmplY3QgPT0gdmFsLmNvbnN0cnVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBhc3luY2hyb25vdXNseSBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciwgc3VyZmFjaW5nIHRoZSByZXN1bHQgdGhyb3VnaCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5zdGFydChmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdoZWxsbycpOyB9KTtcbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuc3RhcnQoZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnaGVsbG8nKTsgfSwgUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5zdGFydChmdW5jdGlvbiAoKSB7IHRoaXMubG9nKCdoZWxsbycpOyB9LCBSeC5TY2hlZHVsZXIudGltZW91dCwgY29uc29sZSk7XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gcnVuIGFzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIGZ1bmN0aW9uIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cbiAgICogQHBhcmFtIFtjb250ZXh0XSAgVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IHZhbHVlLCBvciBhbiBleGNlcHRpb24uXG4gICAqXG4gICAqIFJlbWFya3NcbiAgICogKiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIGltbWVkaWF0ZWx5LCBub3QgZHVyaW5nIHRoZSBzdWJzY3JpcHRpb24gb2YgdGhlIHJlc3VsdGluZyBzZXF1ZW5jZS5cbiAgICogKiBNdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2FuIG9ic2VydmUgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5zdGFydCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0LCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZVRvQXN5bmMoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZnVuY3Rpb24gaW50byBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uIEVhY2ggaW52b2NhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBjYXVzZXMgYW4gaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIEZ1bmN0aW9uIHRvIGNvbnZlcnQgdG8gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZnVuY3Rpb24gb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGV4dF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBc3luY2hyb25vdXMgZnVuY3Rpb24uXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZVRvQXN5bmMgPSBPYnNlcnZhYmxlLnRvQXN5bmMgPSBmdW5jdGlvbiAoZnVuYywgY29udGV4dCwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBzdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuXG4gICAgICBzY2hlZHVsZXIuc2NoZWR1bGUobnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdWJqZWN0Lm9uRXJyb3IoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YmplY3Qub25OZXh0KHJlc3VsdCk7XG4gICAgICAgIHN1YmplY3Qub25Db21wbGV0ZWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgfTtcblxuZnVuY3Rpb24gY3JlYXRlQ2JPYnNlcnZhYmxlKGZuLCBjdHgsIHNlbGVjdG9yLCBhcmdzKSB7XG4gIHZhciBvID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuXG4gIGFyZ3MucHVzaChjcmVhdGVDYkhhbmRsZXIobywgY3R4LCBzZWxlY3RvcikpO1xuICBmbi5hcHBseShjdHgsIGFyZ3MpO1xuXG4gIHJldHVybiBvLmFzT2JzZXJ2YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYkhhbmRsZXIobywgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgcmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICByZXN1bHRzID0gdHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KGN0eCwgcmVzdWx0cyk7XG4gICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgby5vbk5leHQocmVzdWx0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLm9uTmV4dChyZXN1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvLm9uQ29tcGxldGVkKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG8gY29udmVydCB0byBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtNaXhlZH0gW2N0eF0gVGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jIHBhcmFtZXRlciB0byBiZSBleGVjdXRlZC4gIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBzZWxlY3RvciB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGNhbGxiYWNrIHRvIHByb2R1Y2UgYSBzaW5nbGUgaXRlbSB0byB5aWVsZCBvbiBuZXh0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uLCB3aGVuIGV4ZWN1dGVkIHdpdGggdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgbWludXMgdGhlIGNhbGxiYWNrLCBwcm9kdWNlcyBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50cyB0byB0aGUgY2FsbGJhY2sgYXMgYW4gYXJyYXkuXG4gKi9cbk9ic2VydmFibGUuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuLCBjdHgsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHlwZW9mIGN0eCA9PT0gJ3VuZGVmaW5lZCcgJiYgKGN0eCA9IHRoaXMpOyBcblxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBjcmVhdGVDYk9ic2VydmFibGUoZm4sIGN0eCwgc2VsZWN0b3IsIGFyZ3MpO1xuICB9O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZU9ic2VydmFibGUoZm4sIGN0eCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgdmFyIG8gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG5cbiAgYXJncy5wdXNoKGNyZWF0ZU5vZGVIYW5kbGVyKG8sIGN0eCwgc2VsZWN0b3IpKTtcbiAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcblxuICByZXR1cm4gby5hc09ic2VydmFibGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUhhbmRsZXIobywgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBvLm9uRXJyb3IoZXJyKTsgfVxuXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHsgcmVzdWx0c1tpIC0gMV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0cnlDYXRjaChzZWxlY3RvcikuYXBwbHkoY3R4LCByZXN1bHRzKTtcbiAgICAgIGlmIChyZXN1bHRzID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHJlc3VsdHMuZSk7IH1cbiAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBvLm9uTmV4dChyZXN1bHRzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ub25OZXh0KHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIE5vZGUuanMgY2FsbGJhY2sgc3R5bGUgZnVuY3Rpb24gdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gIFRoaXMgbXVzdCBiZSBpbiBmdW5jdGlvbiAoZXJyLCAuLi4pIGZvcm1hdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge01peGVkfSBbY3R4XSBUaGUgY29udGV4dCBmb3IgdGhlIGZ1bmMgcGFyYW1ldGVyIHRvIGJlIGV4ZWN1dGVkLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgY2FsbGJhY2sgbWludXMgdGhlIGVycm9yIHRvIHByb2R1Y2UgYSBzaW5nbGUgaXRlbSB0byB5aWVsZCBvbiBuZXh0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCB3aGVuIGFwcGxpZWQsIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBjYWxsYmFjayBhcmd1bWVudHMgYXMgYW4gYXJyYXkuXG4gKi9cbk9ic2VydmFibGUuZnJvbU5vZGVDYWxsYmFjayA9IGZ1bmN0aW9uIChmbiwgY3R4LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHR5cGVvZiBjdHggPT09ICd1bmRlZmluZWQnICYmIChjdHggPSB0aGlzKTsgXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlT2JzZXJ2YWJsZShmbiwgY3R4LCBzZWxlY3RvciwgYXJncyk7XG4gIH07XG59O1xuXG4gIGZ1bmN0aW9uIGlzTm9kZUxpc3QoZWwpIHtcbiAgICBpZiAocm9vdC5TdGF0aWNOb2RlTGlzdCkge1xuICAgICAgLy8gSUU4IFNwZWNpZmljXG4gICAgICAvLyBpbnN0YW5jZW9mIGlzIHNsb3dlciB0aGFuIE9iamVjdCN0b1N0cmluZywgYnV0IE9iamVjdCN0b1N0cmluZyB3aWxsIG5vdCB3b3JrIGFzIGludGVuZGVkIGluIElFOFxuICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2Ygcm9vdC5TdGF0aWNOb2RlTGlzdCB8fCBlbCBpbnN0YW5jZW9mIHJvb3QuTm9kZUxpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwpID09PSAnW29iamVjdCBOb2RlTGlzdF0nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIExpc3RlbkRpc3Bvc2FibGUoZSwgbiwgZm4pIHtcbiAgICB0aGlzLl9lID0gZTtcbiAgICB0aGlzLl9uID0gbjtcbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX2UuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9uLCB0aGlzLl9mbiwgZmFsc2UpO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9XG4gIExpc3RlbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuX2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9uLCB0aGlzLl9mbiwgZmFsc2UpO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRMaXN0ZW5lciAoZWwsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHZhciBkaXNwb3NhYmxlcyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG5cbiAgICAvLyBBc3VtZSBOb2RlTGlzdCBvciBIVE1MQ29sbGVjdGlvblxuICAgIHZhciBlbGVtVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwpO1xuICAgIGlmIChpc05vZGVMaXN0KGVsKSB8fCBlbGVtVG9TdHJpbmcgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBkaXNwb3NhYmxlcy5hZGQoY3JlYXRlRXZlbnRMaXN0ZW5lcihlbC5pdGVtKGkpLCBldmVudE5hbWUsIGhhbmRsZXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICBkaXNwb3NhYmxlcy5hZGQobmV3IExpc3RlbkRpc3Bvc2FibGUoZWwsIGV2ZW50TmFtZSwgaGFuZGxlcikpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXNwb3NhYmxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbiB0byBkZXRlcm1pbmUgd2hldGhlciB0byB1c2UgbmF0aXZlIGV2ZW50cyBvbmx5XG4gICAqL1xuICBSeC5jb25maWcudXNlTmF0aXZlRXZlbnRzID0gZmFsc2U7XG5cbiAgdmFyIEV2ZW50T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFdmVudE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXZlbnRPYnNlcnZhYmxlKGVsLCBuYW1lLCBmbikge1xuICAgICAgdGhpcy5fZWwgPSBlbDtcbiAgICAgIHRoaXMuX24gPSBuYW1lO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXIobywgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgIHJlc3VsdHMgPSB0cnlDYXRjaChmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICAgIH1cbiAgICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEV2ZW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgdGhpcy5fZWwsXG4gICAgICAgIHRoaXMuX24sXG4gICAgICAgIGNyZWF0ZUhhbmRsZXIobywgdGhpcy5fZm4pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBtYXRjaGluZyBET01FbGVtZW50IG9yIGVhY2ggaXRlbSBpbiB0aGUgTm9kZUxpc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IFRoZSBET01FbGVtZW50IG9yIE5vZGVMaXN0IHRvIGF0dGFjaCBhIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGF0dGFjaCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgZXZlbnRzIGZyb20gdGhlIHNwZWNpZmllZCBlbGVtZW50IGFuZCB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3Rvcikge1xuICAgIC8vIE5vZGUuanMgc3BlY2lmaWNcbiAgICBpZiAoZWxlbWVudC5hZGRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGZyb21FdmVudFBhdHRlcm4oXG4gICAgICAgIGZ1bmN0aW9uIChoKSB7IGVsZW1lbnQuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBoKTsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGgpOyB9LFxuICAgICAgICBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLy8gVXNlIG9ubHkgaWYgbm9uLW5hdGl2ZSBldmVudHMgYXJlIGFsbG93ZWRcbiAgICBpZiAoIVJ4LmNvbmZpZy51c2VOYXRpdmVFdmVudHMpIHtcbiAgICAgIC8vIEhhbmRsZXMganEsIEFuZ3VsYXIuanMsIFplcHRvLCBNYXJpb25ldHRlLCBFbWJlci5qc1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbGVtZW50Lm9mZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50UGF0dGVybihcbiAgICAgICAgICBmdW5jdGlvbiAoaCkgeyBlbGVtZW50Lm9uKGV2ZW50TmFtZSwgaCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGgpIHsgZWxlbWVudC5vZmYoZXZlbnROYW1lLCBoKTsgfSxcbiAgICAgICAgICBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFdmVudE9ic2VydmFibGUoZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3RvcikucHVibGlzaCgpLnJlZkNvdW50KCk7XG4gIH07XG5cbiAgdmFyIEV2ZW50UGF0dGVybk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFdmVudFBhdHRlcm5PYnNlcnZhYmxlKGFkZCwgZGVsLCBmbikge1xuICAgICAgdGhpcy5fYWRkID0gYWRkO1xuICAgICAgdGhpcy5fZGVsID0gZGVsO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXIobywgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgIHJlc3VsdHMgPSB0cnlDYXRjaChmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0cyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHRzLmUpOyB9XG4gICAgICAgIH1cbiAgICAgICAgby5vbk5leHQocmVzdWx0cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIEV2ZW50UGF0dGVybk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGZuID0gY3JlYXRlSGFuZGxlcihvLCB0aGlzLl9mbik7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0aGlzLl9hZGQoZm4pO1xuICAgICAgcmV0dXJuIG5ldyBFdmVudFBhdHRlcm5EaXNwb3NhYmxlKHRoaXMuX2RlbCwgZm4sIHJldHVyblZhbHVlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZShkZWwsIGZuLCByZXQpIHtcbiAgICAgIHRoaXMuX2RlbCA9IGRlbDtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICB0aGlzLl9yZXQgPSByZXQ7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBFdmVudFBhdHRlcm5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICBpc0Z1bmN0aW9uKHRoaXMuX2RlbCkgJiYgdGhpcy5fZGVsKHRoaXMuX2ZuLCB0aGlzLl9yZXQpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgZnJvbSBhbiBldmVudCBlbWl0dGVyIHZpYSBhbiBhZGRIYW5kbGVyL3JlbW92ZUhhbmRsZXIgcGFpci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWRkSGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gYWRkIGEgaGFuZGxlciB0byB0aGUgZW1pdHRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlbW92ZUhhbmRsZXJdIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byByZW1vdmUgYSBoYW5kbGVyIGZyb20gYW4gZW1pdHRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBBIHNlbGVjdG9yIHdoaWNoIHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciB0byBwcm9kdWNlIGEgc2luZ2xlIGl0ZW0gdG8geWllbGQgb24gbmV4dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggd3JhcHMgYW4gZXZlbnQgZnJvbSBhbiBldmVudCBlbWl0dGVyXG4gICAqL1xuICB2YXIgZnJvbUV2ZW50UGF0dGVybiA9IE9ic2VydmFibGUuZnJvbUV2ZW50UGF0dGVybiA9IGZ1bmN0aW9uIChhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3RvcikucHVibGlzaCgpLnJlZkNvdW50KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludm9rZXMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiwgc3VyZmFjaW5nIHRoZSByZXN1bHQgdGhyb3VnaCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbkFzeW5jIEFzeW5jaHJvbm91cyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSB0byBydW4uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGV4cG9zaW5nIHRoZSBmdW5jdGlvbidzIHJlc3VsdCB2YWx1ZSwgb3IgYW4gZXhjZXB0aW9uLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5zdGFydEFzeW5jID0gZnVuY3Rpb24gKGZ1bmN0aW9uQXN5bmMpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRyeUNhdGNoKGZ1bmN0aW9uQXN5bmMpKCk7XG4gICAgaWYgKHByb21pc2UgPT09IGVycm9yT2JqKSB7IHJldHVybiBvYnNlcnZhYmxlVGhyb3cocHJvbWlzZS5lKTsgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbVByb21pc2UocHJvbWlzZSk7XG4gIH07XG5cbiAgcmV0dXJuIFJ4O1xufSkpO1xuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJvYmplY3RUeXBlcyIsImNoZWNrR2xvYmFsIiwidmFsdWUiLCJPYmplY3QiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwiZnJlZVdpbmRvdyIsIndpbmRvdyIsIm1vZHVsZUV4cG9ydHMiLCJ0aGlzR2xvYmFsIiwicm9vdCIsIkZ1bmN0aW9uIiwiZGVmaW5lIiwiYW1kIiwiUngiLCJyZXF1aXJlIiwiY2FsbCIsImV4cCIsInVuZGVmaW5lZCIsIk9ic2VydmFibGUiLCJvYnNlcnZhYmxlRnJvbVByb21pc2UiLCJmcm9tUHJvbWlzZSIsIm9ic2VydmFibGVUaHJvdyIsInRocm93RXJyb3IiLCJBbm9ueW1vdXNPYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZUJhc2UiLCJBc3luY1N1YmplY3QiLCJkaXNwb3NhYmxlQ3JlYXRlIiwiRGlzcG9zYWJsZSIsImNyZWF0ZSIsIkNvbXBvc2l0ZURpc3Bvc2FibGUiLCJpbW1lZGlhdGVTY2hlZHVsZXIiLCJTY2hlZHVsZXIiLCJpbW1lZGlhdGUiLCJkZWZhdWx0U2NoZWR1bGVyIiwiaW5oZXJpdHMiLCJpbnRlcm5hbHMiLCJpc1NjaGVkdWxlciIsImlzUHJvbWlzZSIsImhlbHBlcnMiLCJpc0Z1bmN0aW9uIiwiaXNJdGVyYWJsZSIsImlzQXJyYXlMaWtlIiwiZXJyb3JPYmoiLCJlIiwidHJ5Q2F0Y2hlckdlbiIsInRyeUNhdGNoVGFyZ2V0IiwidHJ5Q2F0Y2hlciIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJ5Q2F0Y2giLCJmbiIsIlR5cGVFcnJvciIsInRocm93ZXIiLCJ3cmFwIiwiY3JlYXRlT2JzZXJ2YWJsZSIsInNwYXduIiwiX19nZW5lcmF0b3JGdW5jdGlvbl9fIiwiZ2VuIiwiYXJncyIsImkiLCJsZW4iLCJsZW5ndGgiLCJwdXNoIiwibyIsImciLCJuZXh0Iiwib25OZXh0Iiwib25Db21wbGV0ZWQiLCJwcm9jZXNzR2VuZXJhdG9yIiwicmVzIiwicmV0Iiwib25FcnJvciIsImVyciIsImRvbmUiLCJvYnMiLCJ0b09ic2VydmFibGUiLCJoYXNWYWx1ZSIsImlzT2JzZXJ2YWJsZSIsImFkZCIsInN1YnNjcmliZSIsInZhbCIsIm9iaiIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJpc0dlbmVyYXRvciIsInRodW5rVG9PYnNlcnZhYmxlIiwiYXJyYXlUb09ic2VydmFibGUiLCJpc09iamVjdCIsIm9iamVjdFRvT2JzZXJ2YWJsZSIsImZyb20iLCJjb25jYXRNYXAiLCJqdXN0IiwidG9BcnJheSIsInJlc3VsdHMiLCJjb25zdHJ1Y3RvciIsImtleXMiLCJvYnNlcnZhYmxlcyIsImtleSIsIm9ic2VydmFibGUiLCJkZWZlciIsImZvcmtKb2luIiwibWFwIiwiY3RvciIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsInByb3RvdHlwZSIsInN0YXJ0IiwiZnVuYyIsImNvbnRleHQiLCJzY2hlZHVsZXIiLCJvYnNlcnZhYmxlVG9Bc3luYyIsInRvQXN5bmMiLCJzdWJqZWN0Iiwic2NoZWR1bGUiLCJyZXN1bHQiLCJhc09ic2VydmFibGUiLCJjcmVhdGVDYk9ic2VydmFibGUiLCJjdHgiLCJzZWxlY3RvciIsImNyZWF0ZUNiSGFuZGxlciIsImhhbmRsZXIiLCJBcnJheSIsImZyb21DYWxsYmFjayIsImNyZWF0ZU5vZGVPYnNlcnZhYmxlIiwiY3JlYXRlTm9kZUhhbmRsZXIiLCJmcm9tTm9kZUNhbGxiYWNrIiwiaXNOb2RlTGlzdCIsImVsIiwiU3RhdGljTm9kZUxpc3QiLCJOb2RlTGlzdCIsInRvU3RyaW5nIiwiTGlzdGVuRGlzcG9zYWJsZSIsIm4iLCJfZSIsIl9uIiwiX2ZuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImlzRGlzcG9zZWQiLCJkaXNwb3NlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZUV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJkaXNwb3NhYmxlcyIsImVsZW1Ub1N0cmluZyIsIml0ZW0iLCJjb25maWciLCJ1c2VOYXRpdmVFdmVudHMiLCJFdmVudE9ic2VydmFibGUiLCJfX3N1cGVyX18iLCJfZWwiLCJjcmVhdGVIYW5kbGVyIiwic3Vic2NyaWJlQ29yZSIsImZyb21FdmVudCIsImVsZW1lbnQiLCJhZGRMaXN0ZW5lciIsImZyb21FdmVudFBhdHRlcm4iLCJoIiwicmVtb3ZlTGlzdGVuZXIiLCJvbiIsIm9mZiIsInB1Ymxpc2giLCJyZWZDb3VudCIsIkV2ZW50UGF0dGVybk9ic2VydmFibGUiLCJkZWwiLCJfYWRkIiwiX2RlbCIsInJldHVyblZhbHVlIiwiRXZlbnRQYXR0ZXJuRGlzcG9zYWJsZSIsIl9yZXQiLCJhZGRIYW5kbGVyIiwicmVtb3ZlSGFuZGxlciIsInN0YXJ0QXN5bmMiLCJmdW5jdGlvbkFzeW5jIiwicHJvbWlzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.async.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.backpressure.js":
/*!*************************************************!*\
  !*** ./node_modules/rx/dist/rx.backpressure.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // References\n    var Observable = Rx.Observable, observableProto = Observable.prototype, AnonymousObservable = Rx.AnonymousObservable, AbstractObserver = Rx.internals.AbstractObserver, CompositeDisposable = Rx.CompositeDisposable, BinaryDisposable = Rx.BinaryDisposable, NAryDisposable = Rx.NAryDisposable, Notification = Rx.Notification, Subject = Rx.Subject, Observer = Rx.Observer, disposableEmpty = Rx.Disposable.empty, disposableCreate = Rx.Disposable.create, inherits = Rx.internals.inherits, addProperties = Rx.internals.addProperties, defaultScheduler = Rx.Scheduler[\"default\"], currentThreadScheduler = Rx.Scheduler.currentThread, identity = Rx.helpers.identity, isScheduler = Rx.Scheduler.isScheduler, isFunction = Rx.helpers.isFunction, checkDisposed = Rx.Disposable.checkDisposed;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    /**\n  * Used to pause and resume streams.\n  */ Rx.Pauser = function(__super__) {\n        inherits(Pauser, __super__);\n        function Pauser() {\n            __super__.call(this);\n        }\n        /**\n     * Pauses the underlying sequence.\n     */ Pauser.prototype.pause = function() {\n            this.onNext(false);\n        };\n        /**\n    * Resumes the underlying sequence.\n    */ Pauser.prototype.resume = function() {\n            this.onNext(true);\n        };\n        return Pauser;\n    }(Subject);\n    var PausableObservable = function(__super__) {\n        inherits(PausableObservable, __super__);\n        function PausableObservable(source, pauser) {\n            this.source = source;\n            this.controller = new Subject();\n            this.paused = true;\n            if (pauser && pauser.subscribe) {\n                this.pauser = this.controller.merge(pauser);\n            } else {\n                this.pauser = this.controller;\n            }\n            __super__.call(this);\n        }\n        PausableObservable.prototype._subscribe = function(o) {\n            var conn = this.source.publish(), subscription = conn.subscribe(o), connection = disposableEmpty;\n            var pausable = this.pauser.startWith(!this.paused).distinctUntilChanged().subscribe(function(b) {\n                if (b) {\n                    connection = conn.connect();\n                } else {\n                    connection.dispose();\n                    connection = disposableEmpty;\n                }\n            });\n            return new NAryDisposable([\n                subscription,\n                connection,\n                pausable\n            ]);\n        };\n        PausableObservable.prototype.pause = function() {\n            this.paused = true;\n            this.controller.onNext(false);\n        };\n        PausableObservable.prototype.resume = function() {\n            this.paused = false;\n            this.controller.onNext(true);\n        };\n        return PausableObservable;\n    }(Observable);\n    /**\n   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.\n   * @example\n   * var pauser = new Rx.Subject();\n   * var source = Rx.Observable.interval(100).pausable(pauser);\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */ observableProto.pausable = function(pauser) {\n        return new PausableObservable(this, pauser);\n    };\n    function combineLatestSource(source, subject, resultSelector) {\n        return new AnonymousObservable(function(o) {\n            var hasValue = [\n                false,\n                false\n            ], hasValueAll = false, isDone = false, values = new Array(2), err;\n            function next(x, i) {\n                values[i] = x;\n                hasValue[i] = true;\n                if (hasValueAll || (hasValueAll = hasValue.every(identity))) {\n                    if (err) {\n                        return o.onError(err);\n                    }\n                    var res = tryCatch(resultSelector).apply(null, values);\n                    if (res === errorObj) {\n                        return o.onError(res.e);\n                    }\n                    o.onNext(res);\n                }\n                isDone && values[1] && o.onCompleted();\n            }\n            return new BinaryDisposable(source.subscribe(function(x) {\n                next(x, 0);\n            }, function(e) {\n                if (values[1]) {\n                    o.onError(e);\n                } else {\n                    err = e;\n                }\n            }, function() {\n                isDone = true;\n                values[1] && o.onCompleted();\n            }), subject.subscribe(function(x) {\n                next(x, 1);\n            }, function(e) {\n                o.onError(e);\n            }, function() {\n                isDone = true;\n                next(true, 1);\n            }));\n        }, source);\n    }\n    var PausableBufferedObservable = function(__super__) {\n        inherits(PausableBufferedObservable, __super__);\n        function PausableBufferedObservable(source, pauser) {\n            this.source = source;\n            this.controller = new Subject();\n            this.paused = true;\n            if (pauser && pauser.subscribe) {\n                this.pauser = this.controller.merge(pauser);\n            } else {\n                this.pauser = this.controller;\n            }\n            __super__.call(this);\n        }\n        PausableBufferedObservable.prototype._subscribe = function(o) {\n            var q = [], previousShouldFire;\n            function drainQueue() {\n                while(q.length > 0){\n                    o.onNext(q.shift());\n                }\n            }\n            var subscription = combineLatestSource(this.source, this.pauser.startWith(!this.paused).distinctUntilChanged(), function(data, shouldFire) {\n                return {\n                    data: data,\n                    shouldFire: shouldFire\n                };\n            }).subscribe(function(results) {\n                if (previousShouldFire !== undefined && results.shouldFire !== previousShouldFire) {\n                    previousShouldFire = results.shouldFire;\n                    // change in shouldFire\n                    if (results.shouldFire) {\n                        drainQueue();\n                    }\n                } else {\n                    previousShouldFire = results.shouldFire;\n                    // new data\n                    if (results.shouldFire) {\n                        o.onNext(results.data);\n                    } else {\n                        q.push(results.data);\n                    }\n                }\n            }, function(err) {\n                drainQueue();\n                o.onError(err);\n            }, function() {\n                drainQueue();\n                o.onCompleted();\n            });\n            return subscription;\n        };\n        PausableBufferedObservable.prototype.pause = function() {\n            this.paused = true;\n            this.controller.onNext(false);\n        };\n        PausableBufferedObservable.prototype.resume = function() {\n            this.paused = false;\n            this.controller.onNext(true);\n        };\n        return PausableBufferedObservable;\n    }(Observable);\n    /**\n   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,\n   * and yields the values that were buffered while paused.\n   * @example\n   * var pauser = new Rx.Subject();\n   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */ observableProto.pausableBuffered = function(pauser) {\n        return new PausableBufferedObservable(this, pauser);\n    };\n    var ControlledObservable = function(__super__) {\n        inherits(ControlledObservable, __super__);\n        function ControlledObservable(source, enableQueue, scheduler) {\n            __super__.call(this);\n            this.subject = new ControlledSubject(enableQueue, scheduler);\n            this.source = source.multicast(this.subject).refCount();\n        }\n        ControlledObservable.prototype._subscribe = function(o) {\n            return this.source.subscribe(o);\n        };\n        ControlledObservable.prototype.request = function(numberOfItems) {\n            return this.subject.request(numberOfItems == null ? -1 : numberOfItems);\n        };\n        return ControlledObservable;\n    }(Observable);\n    var ControlledSubject = function(__super__) {\n        inherits(ControlledSubject, __super__);\n        function ControlledSubject(enableQueue, scheduler) {\n            enableQueue == null && (enableQueue = true);\n            __super__.call(this);\n            this.subject = new Subject();\n            this.enableQueue = enableQueue;\n            this.queue = enableQueue ? [] : null;\n            this.requestedCount = 0;\n            this.requestedDisposable = null;\n            this.error = null;\n            this.hasFailed = false;\n            this.hasCompleted = false;\n            this.scheduler = scheduler || currentThreadScheduler;\n        }\n        addProperties(ControlledSubject.prototype, Observer, {\n            _subscribe: function(o) {\n                return this.subject.subscribe(o);\n            },\n            onCompleted: function() {\n                this.hasCompleted = true;\n                if (!this.enableQueue || this.queue.length === 0) {\n                    this.subject.onCompleted();\n                    this.disposeCurrentRequest();\n                } else {\n                    this.queue.push(Notification.createOnCompleted());\n                }\n            },\n            onError: function(error) {\n                this.hasFailed = true;\n                this.error = error;\n                if (!this.enableQueue || this.queue.length === 0) {\n                    this.subject.onError(error);\n                    this.disposeCurrentRequest();\n                } else {\n                    this.queue.push(Notification.createOnError(error));\n                }\n            },\n            onNext: function(value) {\n                if (this.requestedCount <= 0) {\n                    this.enableQueue && this.queue.push(Notification.createOnNext(value));\n                } else {\n                    this.requestedCount-- === 0 && this.disposeCurrentRequest();\n                    this.subject.onNext(value);\n                }\n            },\n            _processRequest: function(numberOfItems) {\n                if (this.enableQueue) {\n                    while(this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== \"N\")){\n                        var first = this.queue.shift();\n                        first.accept(this.subject);\n                        if (first.kind === \"N\") {\n                            numberOfItems--;\n                        } else {\n                            this.disposeCurrentRequest();\n                            this.queue = [];\n                        }\n                    }\n                }\n                return numberOfItems;\n            },\n            request: function(number) {\n                this.disposeCurrentRequest();\n                var self1 = this;\n                this.requestedDisposable = this.scheduler.schedule(number, function(s, i) {\n                    var remaining = self1._processRequest(i);\n                    var stopped = self1.hasCompleted || self1.hasFailed;\n                    if (!stopped && remaining > 0) {\n                        self1.requestedCount = remaining;\n                        return disposableCreate(function() {\n                            self1.requestedCount = 0;\n                        });\n                    // Scheduled item is still in progress. Return a new\n                    // disposable to allow the request to be interrupted\n                    // via dispose.\n                    }\n                });\n                return this.requestedDisposable;\n            },\n            disposeCurrentRequest: function() {\n                if (this.requestedDisposable) {\n                    this.requestedDisposable.dispose();\n                    this.requestedDisposable = null;\n                }\n            }\n        });\n        return ControlledSubject;\n    }(Observable);\n    /**\n   * Attaches a controller to the observable sequence with the ability to queue.\n   * @example\n   * var source = Rx.Observable.interval(100).controlled();\n   * source.request(3); // Reads 3 values\n   * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request\n   * @param {Scheduler} scheduler determines how the requests will be scheduled\n   * @returns {Observable} The observable sequence which only propagates values on request.\n   */ observableProto.controlled = function(enableQueue, scheduler) {\n        if (enableQueue && isScheduler(enableQueue)) {\n            scheduler = enableQueue;\n            enableQueue = true;\n        }\n        if (enableQueue == null) {\n            enableQueue = true;\n        }\n        return new ControlledObservable(this, enableQueue, scheduler);\n    };\n    var StopAndWaitObservable = function(__super__) {\n        inherits(StopAndWaitObservable, __super__);\n        function StopAndWaitObservable(source) {\n            __super__.call(this);\n            this.source = source;\n        }\n        function scheduleMethod(s, self1) {\n            return self1.source.request(1);\n        }\n        StopAndWaitObservable.prototype._subscribe = function(o) {\n            this.subscription = this.source.subscribe(new StopAndWaitObserver(o, this, this.subscription));\n            return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));\n        };\n        var StopAndWaitObserver = function(__sub__) {\n            inherits(StopAndWaitObserver, __sub__);\n            function StopAndWaitObserver(observer, observable, cancel) {\n                __sub__.call(this);\n                this.observer = observer;\n                this.observable = observable;\n                this.cancel = cancel;\n                this.scheduleDisposable = null;\n            }\n            StopAndWaitObserver.prototype.completed = function() {\n                this.observer.onCompleted();\n                this.dispose();\n            };\n            StopAndWaitObserver.prototype.error = function(error) {\n                this.observer.onError(error);\n                this.dispose();\n            };\n            function innerScheduleMethod(s, self1) {\n                return self1.observable.source.request(1);\n            }\n            StopAndWaitObserver.prototype.next = function(value) {\n                this.observer.onNext(value);\n                this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod);\n            };\n            StopAndWaitObserver.dispose = function() {\n                this.observer = null;\n                if (this.cancel) {\n                    this.cancel.dispose();\n                    this.cancel = null;\n                }\n                if (this.scheduleDisposable) {\n                    this.scheduleDisposable.dispose();\n                    this.scheduleDisposable = null;\n                }\n                __sub__.prototype.dispose.call(this);\n            };\n            return StopAndWaitObserver;\n        }(AbstractObserver);\n        return StopAndWaitObservable;\n    }(Observable);\n    /**\n   * Attaches a stop and wait observable to the current observable.\n   * @returns {Observable} A stop and wait observable.\n   */ ControlledObservable.prototype.stopAndWait = function() {\n        return new StopAndWaitObservable(this);\n    };\n    var WindowedObservable = function(__super__) {\n        inherits(WindowedObservable, __super__);\n        function WindowedObservable(source, windowSize) {\n            __super__.call(this);\n            this.source = source;\n            this.windowSize = windowSize;\n        }\n        function scheduleMethod(s, self1) {\n            return self1.source.request(self1.windowSize);\n        }\n        WindowedObservable.prototype._subscribe = function(o) {\n            this.subscription = this.source.subscribe(new WindowedObserver(o, this, this.subscription));\n            return new BinaryDisposable(this.subscription, defaultScheduler.schedule(this, scheduleMethod));\n        };\n        var WindowedObserver = function(__sub__) {\n            inherits(WindowedObserver, __sub__);\n            function WindowedObserver(observer, observable, cancel) {\n                this.observer = observer;\n                this.observable = observable;\n                this.cancel = cancel;\n                this.received = 0;\n                this.scheduleDisposable = null;\n                __sub__.call(this);\n            }\n            WindowedObserver.prototype.completed = function() {\n                this.observer.onCompleted();\n                this.dispose();\n            };\n            WindowedObserver.prototype.error = function(error) {\n                this.observer.onError(error);\n                this.dispose();\n            };\n            function innerScheduleMethod(s, self1) {\n                return self1.observable.source.request(self1.observable.windowSize);\n            }\n            WindowedObserver.prototype.next = function(value) {\n                this.observer.onNext(value);\n                this.received = ++this.received % this.observable.windowSize;\n                this.received === 0 && (this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod));\n            };\n            WindowedObserver.prototype.dispose = function() {\n                this.observer = null;\n                if (this.cancel) {\n                    this.cancel.dispose();\n                    this.cancel = null;\n                }\n                if (this.scheduleDisposable) {\n                    this.scheduleDisposable.dispose();\n                    this.scheduleDisposable = null;\n                }\n                __sub__.prototype.dispose.call(this);\n            };\n            return WindowedObserver;\n        }(AbstractObserver);\n        return WindowedObservable;\n    }(Observable);\n    /**\n   * Creates a sliding windowed observable based upon the window size.\n   * @param {Number} windowSize The number of items in the window\n   * @returns {Observable} A windowed observable based upon the window size.\n   */ ControlledObservable.prototype.windowed = function(windowSize) {\n        return new WindowedObservable(this, windowSize);\n    };\n    /**\n   * Pipes the existing Observable sequence into a Node.js Stream.\n   * @param {Stream} dest The destination Node.js stream.\n   * @returns {Stream} The destination stream.\n   */ observableProto.pipe = function(dest) {\n        var source = this.pausableBuffered();\n        function onDrain() {\n            source.resume();\n        }\n        dest.addListener(\"drain\", onDrain);\n        source.subscribe(function(x) {\n            !dest.write(x) && source.pause();\n        }, function(err) {\n            dest.emit(\"error\", err);\n        }, function() {\n            // Hack check because STDIO is not closable\n            !dest._isStdio && dest.end();\n            dest.removeListener(\"drain\", onDrain);\n        });\n        source.resume();\n        return dest;\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5iYWNrcHJlc3N1cmUuanMiLCJtYXBwaW5ncyI6IjtBQUFBLDZLQUE2Rzs7QUFFM0csVUFBVUEsT0FBTztJQUNqQixJQUFJQyxjQUFjO1FBQ2hCLFlBQVk7UUFDWixVQUFVO0lBQ1o7SUFFQSxTQUFTQyxZQUFZQyxLQUFLO1FBQ3hCLE9BQU8sU0FBVUEsTUFBTUMsTUFBTSxLQUFLQSxTQUFVRCxRQUFRO0lBQ3REO0lBRUEsSUFBSUUsY0FBYyxXQUFZLENBQUMsT0FBT0MsUUFBUSxJQUFJQSxXQUFXLENBQUNBLFFBQVFDLFFBQVEsR0FBSUQsVUFBVTtJQUM1RixJQUFJRSxhQUFhLFdBQVksQ0FBQyxRQUFhQyxDQUFDLElBQUlBLFVBQVUsQ0FBQ0EsT0FBT0YsUUFBUSxHQUFJRSxTQUFTO0lBQ3ZGLElBQUlDLGFBQWFSLFlBQVlHLGVBQWVHLGNBQWMsT0FBT0csV0FBVyxZQUFZQTtJQUN4RixJQUFJQyxXQUFXVixZQUFZRCxXQUFXLENBQUMsT0FBT1ksS0FBSyxJQUFJQTtJQUN2RCxJQUFJQyxhQUFhWixZQUFZRCxXQUFXLENBQUMsWUFBYyxJQUFJYztJQUMzRCxJQUFJQyxnQkFBZ0IsY0FBZVIsV0FBV0YsT0FBTyxLQUFLRCxjQUFlQSxjQUFjO0lBQ3ZGLElBQUlZLGFBQWFmLFlBQVlELFdBQVcsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLElBQUk7SUFDN0QsSUFBSWlCLE9BQU9SLGNBQWUsZUFBaUJPLENBQUFBLGNBQWNBLFdBQVdGLE1BQU0sS0FBTUQsY0FBZUYsWUFBWUssY0FBY0UsU0FBUztJQUVsSSw4QkFBOEI7SUFDOUIsSUFBSSxJQUEwQyxFQUFFO1FBQzlDQyxpQ0FBTztZQUFDO1NBQU8sbUNBQUUsU0FBVUUsRUFBRSxFQUFFaEIsUUFBTztZQUNwQyxPQUFPTixRQUFRa0IsTUFBTVosVUFBU2dCO1FBQ2hDLENBQUM7QUFBQSxrR0FBQztJQUNKLE9BQU8sRUFJTjtBQUNILEdBQUVFLElBQUksQ0FB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O0lBQ3RDO0lBRUE7Ozs7R0FJQyxHQUNEakksZ0JBQWdCcUksSUFBSSxHQUFHLFNBQVVDLElBQUk7UUFDbkMsSUFBSTFGLFNBQVMsSUFBSSxDQUFDNEMsZ0JBQWdCO1FBRWxDLFNBQVMrQztZQUNQM0YsT0FBT0YsTUFBTTtRQUNmO1FBRUE0RixLQUFLRSxXQUFXLENBQUMsU0FBU0Q7UUFFMUIzRixPQUFPSSxTQUFTLENBQ2QsU0FBVXdCLENBQUM7WUFDVCxDQUFDOEQsS0FBS0csS0FBSyxDQUFDakUsTUFBTTVCLE9BQU9KLEtBQUs7UUFDaEMsR0FDQSxTQUFVOEIsR0FBRztZQUNYZ0UsS0FBS0ksSUFBSSxDQUFDLFNBQVNwRTtRQUNyQixHQUNBO1lBQ0UsMkNBQTJDO1lBQzNDLENBQUNnRSxLQUFLSyxRQUFRLElBQUlMLEtBQUtNLEdBQUc7WUFDMUJOLEtBQUtPLGNBQWMsQ0FBQyxTQUFTTjtRQUMvQjtRQUVGM0YsT0FBT0YsTUFBTTtRQUViLE9BQU80RjtJQUNUO0lBRUEsT0FBTzVJO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXJ2ZXItYWN0aW9uLy4vbm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguYmFja3ByZXNzdXJlLmpzPzdkNTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQsIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLk9iamVjdCA9PT0gT2JqZWN0KSA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIHZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkgPyBleHBvcnRzIDogbnVsbDtcbiAgdmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpID8gbW9kdWxlIDogbnVsbDtcbiAgdmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCk7XG4gIHZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcbiAgdmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IChmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpID8gZnJlZUV4cG9ydHMgOiBudWxsO1xuICB2YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLy8gQmVjYXVzZSBvZiBidWlsZCBvcHRpbWl6ZXJzXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWycuL3J4J10sIGZ1bmN0aW9uIChSeCwgZXhwb3J0cykge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgUngpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCwgbW9kdWxlLmV4cG9ydHMsIHJlcXVpcmUoJy4vcngnKSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5SeCA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuUngpO1xuICB9XG59LmNhbGwodGhpcywgZnVuY3Rpb24gKHJvb3QsIGV4cCwgUngsIHVuZGVmaW5lZCkge1xuXG4gIC8vIFJlZmVyZW5jZXNcbiAgdmFyIE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLFxuICAgIG9ic2VydmFibGVQcm90byA9IE9ic2VydmFibGUucHJvdG90eXBlLFxuICAgIEFub255bW91c09ic2VydmFibGUgPSBSeC5Bbm9ueW1vdXNPYnNlcnZhYmxlLFxuICAgIEFic3RyYWN0T2JzZXJ2ZXIgPSBSeC5pbnRlcm5hbHMuQWJzdHJhY3RPYnNlcnZlcixcbiAgICBDb21wb3NpdGVEaXNwb3NhYmxlID0gUnguQ29tcG9zaXRlRGlzcG9zYWJsZSxcbiAgICBCaW5hcnlEaXNwb3NhYmxlID0gUnguQmluYXJ5RGlzcG9zYWJsZSxcbiAgICBOQXJ5RGlzcG9zYWJsZSA9IFJ4Lk5BcnlEaXNwb3NhYmxlLFxuICAgIE5vdGlmaWNhdGlvbiA9IFJ4Lk5vdGlmaWNhdGlvbixcbiAgICBTdWJqZWN0ID0gUnguU3ViamVjdCxcbiAgICBPYnNlcnZlciA9IFJ4Lk9ic2VydmVyLFxuICAgIGRpc3Bvc2FibGVFbXB0eSA9IFJ4LkRpc3Bvc2FibGUuZW1wdHksXG4gICAgZGlzcG9zYWJsZUNyZWF0ZSA9IFJ4LkRpc3Bvc2FibGUuY3JlYXRlLFxuICAgIGluaGVyaXRzID0gUnguaW50ZXJuYWxzLmluaGVyaXRzLFxuICAgIGFkZFByb3BlcnRpZXMgPSBSeC5pbnRlcm5hbHMuYWRkUHJvcGVydGllcyxcbiAgICBkZWZhdWx0U2NoZWR1bGVyID0gUnguU2NoZWR1bGVyWydkZWZhdWx0J10sXG4gICAgY3VycmVudFRocmVhZFNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlci5jdXJyZW50VGhyZWFkLFxuICAgIGlkZW50aXR5ID0gUnguaGVscGVycy5pZGVudGl0eSxcbiAgICBpc1NjaGVkdWxlciA9IFJ4LlNjaGVkdWxlci5pc1NjaGVkdWxlcixcbiAgICBpc0Z1bmN0aW9uID0gUnguaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgIGNoZWNrRGlzcG9zZWQgPSBSeC5EaXNwb3NhYmxlLmNoZWNrRGlzcG9zZWQ7XG5cbiAgdmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbiAgXG4gIGZ1bmN0aW9uIHRyeUNhdGNoZXJHZW4odHJ5Q2F0Y2hUYXJnZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgdHJ5Q2F0Y2ggPSBSeC5pbnRlcm5hbHMudHJ5Q2F0Y2ggPSBmdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignZm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7IH1cbiAgICByZXR1cm4gdHJ5Q2F0Y2hlckdlbihmbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZWQgdG8gcGF1c2UgYW5kIHJlc3VtZSBzdHJlYW1zLlxuICAqL1xuICBSeC5QYXVzZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYXVzZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAgICovXG4gICAgUGF1c2VyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5vbk5leHQoZmFsc2UpOyB9O1xuXG4gICAgLyoqXG4gICAgKiBSZXN1bWVzIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLlxuICAgICovXG4gICAgUGF1c2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMub25OZXh0KHRydWUpOyB9O1xuXG4gICAgcmV0dXJuIFBhdXNlcjtcbiAgfShTdWJqZWN0KSk7XG5cbiAgdmFyIFBhdXNhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoUGF1c2FibGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhdXNhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHBhdXNlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gICAgICBpZiAocGF1c2VyICYmIHBhdXNlci5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXIubWVyZ2UocGF1c2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGF1c2VyID0gdGhpcy5jb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBQYXVzYWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGNvbm4gPSB0aGlzLnNvdXJjZS5wdWJsaXNoKCksXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IGNvbm4uc3Vic2NyaWJlKG8pLFxuICAgICAgICBjb25uZWN0aW9uID0gZGlzcG9zYWJsZUVtcHR5O1xuXG4gICAgICB2YXIgcGF1c2FibGUgPSB0aGlzLnBhdXNlci5zdGFydFdpdGgoIXRoaXMucGF1c2VkKS5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGNvbm5lY3Rpb24gPSBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICBjb25uZWN0aW9uID0gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbc3Vic2NyaXB0aW9uLCBjb25uZWN0aW9uLCBwYXVzYWJsZV0pO1xuICAgIH07XG5cbiAgICBQYXVzYWJsZU9ic2VydmFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250cm9sbGVyLm9uTmV4dChmYWxzZSk7XG4gICAgfTtcblxuICAgIFBhdXNhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQodHJ1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXVzYWJsZU9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIHVwb24gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggeWllbGRzIHRydWUvZmFsc2UuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwYXVzZXIgPSBuZXcgUnguU3ViamVjdCgpO1xuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDApLnBhdXNhYmxlKHBhdXNlcik7XG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcGF1c2VyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHVzZWQgdG8gcGF1c2UgdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBwYXVzZWQgYmFzZWQgdXBvbiB0aGUgcGF1c2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhdXNhYmxlID0gZnVuY3Rpb24gKHBhdXNlcikge1xuICAgIHJldHVybiBuZXcgUGF1c2FibGVPYnNlcnZhYmxlKHRoaXMsIHBhdXNlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tYmluZUxhdGVzdFNvdXJjZShzb3VyY2UsIHN1YmplY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgaGFzVmFsdWUgPSBbZmFsc2UsIGZhbHNlXSxcbiAgICAgICAgaGFzVmFsdWVBbGwgPSBmYWxzZSxcbiAgICAgICAgaXNEb25lID0gZmFsc2UsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheSgyKSxcbiAgICAgICAgZXJyO1xuXG4gICAgICBmdW5jdGlvbiBuZXh0KHgsIGkpIHtcbiAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgaGFzVmFsdWVbaV0gPSB0cnVlO1xuICAgICAgICBpZiAoaGFzVmFsdWVBbGwgfHwgKGhhc1ZhbHVlQWxsID0gaGFzVmFsdWUuZXZlcnkoaWRlbnRpdHkpKSkge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIG8ub25FcnJvcihlcnIpOyB9XG4gICAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHJlc3VsdFNlbGVjdG9yKS5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzLmUpOyB9XG4gICAgICAgICAgby5vbk5leHQocmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpc0RvbmUgJiYgdmFsdWVzWzFdICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBuZXh0KHgsIDApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbMV0pIHtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZXNbMV0gJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH0pLFxuICAgICAgICBzdWJqZWN0LnN1YnNjcmliZShcbiAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgbmV4dCh4LCAxKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dCh0cnVlLCAxKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICB2YXIgUGF1c2FibGVCdWZmZXJlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlKHNvdXJjZSwgcGF1c2VyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG5cbiAgICAgIGlmIChwYXVzZXIgJiYgcGF1c2VyLnN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLnBhdXNlciA9IHRoaXMuY29udHJvbGxlci5tZXJnZShwYXVzZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZXIgPSB0aGlzLmNvbnRyb2xsZXI7XG4gICAgICB9XG5cbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBxID0gW10sIHByZXZpb3VzU2hvdWxkRmlyZTtcblxuICAgICAgZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHsgd2hpbGUgKHEubGVuZ3RoID4gMCkgeyBvLm9uTmV4dChxLnNoaWZ0KCkpOyB9IH1cblxuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9XG4gICAgICAgIGNvbWJpbmVMYXRlc3RTb3VyY2UoXG4gICAgICAgICAgdGhpcy5zb3VyY2UsXG4gICAgICAgICAgdGhpcy5wYXVzZXIuc3RhcnRXaXRoKCF0aGlzLnBhdXNlZCkuZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgICBmdW5jdGlvbiAoZGF0YSwgc2hvdWxkRmlyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgc2hvdWxkRmlyZTogc2hvdWxkRmlyZSB9O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1Nob3VsZEZpcmUgIT09IHVuZGVmaW5lZCAmJiByZXN1bHRzLnNob3VsZEZpcmUgIT09IHByZXZpb3VzU2hvdWxkRmlyZSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2hvdWxkRmlyZSA9IHJlc3VsdHMuc2hvdWxkRmlyZTtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgaW4gc2hvdWxkRmlyZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLnNob3VsZEZpcmUpIHsgZHJhaW5RdWV1ZSgpOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTaG91bGRGaXJlID0gcmVzdWx0cy5zaG91bGRGaXJlO1xuICAgICAgICAgICAgICAgIC8vIG5ldyBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuc2hvdWxkRmlyZSkge1xuICAgICAgICAgICAgICAgICAgby5vbk5leHQocmVzdWx0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcS5wdXNoKHJlc3VsdHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247ICAgICAgXG4gICAgfTtcblxuICAgIFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5vbk5leHQodHJ1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogUGF1c2VzIHRoZSB1bmRlcmx5aW5nIG9ic2VydmFibGUgc2VxdWVuY2UgYmFzZWQgdXBvbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCB5aWVsZHMgdHJ1ZS9mYWxzZSxcbiAgICogYW5kIHlpZWxkcyB0aGUgdmFsdWVzIHRoYXQgd2VyZSBidWZmZXJlZCB3aGlsZSBwYXVzZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwYXVzZXIgPSBuZXcgUnguU3ViamVjdCgpO1xuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDApLnBhdXNhYmxlQnVmZmVyZWQocGF1c2VyKTtcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBwYXVzZXIgVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwYXVzZSB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIGlzIHBhdXNlZCBiYXNlZCB1cG9uIHRoZSBwYXVzZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGF1c2FibGVCdWZmZXJlZCA9IGZ1bmN0aW9uIChwYXVzZXIpIHtcbiAgICByZXR1cm4gbmV3IFBhdXNhYmxlQnVmZmVyZWRPYnNlcnZhYmxlKHRoaXMsIHBhdXNlcik7XG4gIH07XG5cbiAgdmFyIENvbnRyb2xsZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb250cm9sbGVkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDb250cm9sbGVkT2JzZXJ2YWJsZSAoc291cmNlLCBlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc3ViamVjdCA9IG5ldyBDb250cm9sbGVkU3ViamVjdChlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlLm11bHRpY2FzdCh0aGlzLnN1YmplY3QpLnJlZkNvdW50KCk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShvKTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlZE9ic2VydmFibGUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcykge1xuICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5yZXF1ZXN0KG51bWJlck9mSXRlbXMgPT0gbnVsbCA/IC0xIDogbnVtYmVyT2ZJdGVtcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb250cm9sbGVkT2JzZXJ2YWJsZTtcblxuICB9KE9ic2VydmFibGUpKTtcblxuICB2YXIgQ29udHJvbGxlZFN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbnRyb2xsZWRTdWJqZWN0LCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbnRyb2xsZWRTdWJqZWN0KGVuYWJsZVF1ZXVlLCBzY2hlZHVsZXIpIHtcbiAgICAgIGVuYWJsZVF1ZXVlID09IG51bGwgJiYgKGVuYWJsZVF1ZXVlID0gdHJ1ZSk7XG5cbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zdWJqZWN0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgIHRoaXMuZW5hYmxlUXVldWUgPSBlbmFibGVRdWV1ZTtcbiAgICAgIHRoaXMucXVldWUgPSBlbmFibGVRdWV1ZSA/IFtdIDogbnVsbDtcbiAgICAgIHRoaXMucmVxdWVzdGVkQ291bnQgPSAwO1xuICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlciB8fCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyO1xuICAgIH1cblxuICAgIGFkZFByb3BlcnRpZXMoQ29udHJvbGxlZFN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlciwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5zdWJzY3JpYmUobyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUXVldWUgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnN1YmplY3Qub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVldWUucHVzaChOb3RpZmljYXRpb24uY3JlYXRlT25Db21wbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVRdWV1ZSB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuc3ViamVjdC5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVldWUucHVzaChOb3RpZmljYXRpb24uY3JlYXRlT25FcnJvcihlcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25OZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkQ291bnQgPD0gMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlUXVldWUgJiYgdGhpcy5xdWV1ZS5wdXNoKE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAodGhpcy5yZXF1ZXN0ZWRDb3VudC0tID09PSAwKSAmJiB0aGlzLmRpc3Bvc2VDdXJyZW50UmVxdWVzdCgpO1xuICAgICAgICAgIHRoaXMuc3ViamVjdC5vbk5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3Byb2Nlc3NSZXF1ZXN0OiBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcykge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVRdWV1ZSkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgKG51bWJlck9mSXRlbXMgPiAwIHx8IHRoaXMucXVldWVbMF0ua2luZCAhPT0gJ04nKSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgZmlyc3QuYWNjZXB0KHRoaXMuc3ViamVjdCk7XG4gICAgICAgICAgICBpZiAoZmlyc3Qua2luZCA9PT0gJ04nKSB7XG4gICAgICAgICAgICAgIG51bWJlck9mSXRlbXMtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZUN1cnJlbnRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYmVyT2ZJdGVtcztcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUN1cnJlbnRSZXF1ZXN0KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLnJlcXVlc3RlZERpc3Bvc2FibGUgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShudW1iZXIsXG4gICAgICAgIGZ1bmN0aW9uKHMsIGkpIHtcbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gc2VsZi5fcHJvY2Vzc1JlcXVlc3QoaSk7XG4gICAgICAgICAgdmFyIHN0b3BwZWQgPSBzZWxmLmhhc0NvbXBsZXRlZCB8fCBzZWxmLmhhc0ZhaWxlZDtcbiAgICAgICAgICBpZiAoIXN0b3BwZWQgJiYgcmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgc2VsZi5yZXF1ZXN0ZWRDb3VudCA9IHJlbWFpbmluZztcblxuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZWxmLnJlcXVlc3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBTY2hlZHVsZWQgaXRlbSBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gUmV0dXJuIGEgbmV3XG4gICAgICAgICAgICAgIC8vIGRpc3Bvc2FibGUgdG8gYWxsb3cgdGhlIHJlcXVlc3QgdG8gYmUgaW50ZXJydXB0ZWRcbiAgICAgICAgICAgICAgLy8gdmlhIGRpc3Bvc2UuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2VDdXJyZW50UmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0ZWREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RlZERpc3Bvc2FibGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ29udHJvbGxlZFN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIGNvbnRyb2xsZXIgdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgYWJpbGl0eSB0byBxdWV1ZS5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwKS5jb250cm9sbGVkKCk7XG4gICAqIHNvdXJjZS5yZXF1ZXN0KDMpOyAvLyBSZWFkcyAzIHZhbHVlc1xuICAgKiBAcGFyYW0ge2Jvb2x9IGVuYWJsZVF1ZXVlIHRydXRoeSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIHNob3VsZCBiZSBxdWV1ZWQgcGVuZGluZyB0aGUgbmV4dCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgZGV0ZXJtaW5lcyBob3cgdGhlIHJlcXVlc3RzIHdpbGwgYmUgc2NoZWR1bGVkXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBvbmx5IHByb3BhZ2F0ZXMgdmFsdWVzIG9uIHJlcXVlc3QuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29udHJvbGxlZCA9IGZ1bmN0aW9uIChlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKSB7XG5cbiAgICBpZiAoZW5hYmxlUXVldWUgJiYgaXNTY2hlZHVsZXIoZW5hYmxlUXVldWUpKSB7XG4gICAgICBzY2hlZHVsZXIgPSBlbmFibGVRdWV1ZTtcbiAgICAgIGVuYWJsZVF1ZXVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlUXVldWUgPT0gbnVsbCkgeyAgZW5hYmxlUXVldWUgPSB0cnVlOyB9XG4gICAgcmV0dXJuIG5ldyBDb250cm9sbGVkT2JzZXJ2YWJsZSh0aGlzLCBlbmFibGVRdWV1ZSwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU3RvcEFuZFdhaXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdG9wQW5kV2FpdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3RvcEFuZFdhaXRPYnNlcnZhYmxlIChzb3VyY2UpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuc291cmNlLnJlcXVlc3QoMSk7XG4gICAgfVxuXG4gICAgU3RvcEFuZFdhaXRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTdG9wQW5kV2FpdE9ic2VydmVyKG8sIHRoaXMsIHRoaXMuc3Vic2NyaXB0aW9uKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLFxuICAgICAgICBkZWZhdWx0U2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIHNjaGVkdWxlTWV0aG9kKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIFN0b3BBbmRXYWl0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3ViX18pIHtcbiAgICAgIGluaGVyaXRzKFN0b3BBbmRXYWl0T2JzZXJ2ZXIsIF9fc3ViX18pO1xuICAgICAgZnVuY3Rpb24gU3RvcEFuZFdhaXRPYnNlcnZlciAob2JzZXJ2ZXIsIG9ic2VydmFibGUsIGNhbmNlbCkge1xuICAgICAgICBfX3N1Yl9fLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgU3RvcEFuZFdhaXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfTtcblxuICAgICAgU3RvcEFuZFdhaXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBpbm5lclNjaGVkdWxlTWV0aG9kKHMsIHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYub2JzZXJ2YWJsZS5zb3VyY2UucmVxdWVzdCgxKTtcbiAgICAgIH1cblxuICAgICAgU3RvcEFuZFdhaXRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gZGVmYXVsdFNjaGVkdWxlci5zY2hlZHVsZSh0aGlzLCBpbm5lclNjaGVkdWxlTWV0aG9kKTtcbiAgICAgIH07XG5cbiAgICAgIFN0b3BBbmRXYWl0T2JzZXJ2ZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbCkge1xuICAgICAgICAgIHRoaXMuY2FuY2VsLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLmNhbmNlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZURpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfX3N1Yl9fLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU3RvcEFuZFdhaXRPYnNlcnZlcjtcbiAgICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAgIHJldHVybiBTdG9wQW5kV2FpdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgc3RvcCBhbmQgd2FpdCBvYnNlcnZhYmxlIHRvIHRoZSBjdXJyZW50IG9ic2VydmFibGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIHN0b3AgYW5kIHdhaXQgb2JzZXJ2YWJsZS5cbiAgICovXG4gIENvbnRyb2xsZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdG9wQW5kV2FpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3BBbmRXYWl0T2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgV2luZG93ZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaW5kb3dlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2luZG93ZWRPYnNlcnZhYmxlKHNvdXJjZSwgd2luZG93U2l6ZSkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuc291cmNlLnJlcXVlc3Qoc2VsZi53aW5kb3dTaXplKTtcbiAgICB9XG5cbiAgICBXaW5kb3dlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFdpbmRvd2VkT2JzZXJ2ZXIobywgdGhpcywgdGhpcy5zdWJzY3JpcHRpb24pKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24sXG4gICAgICAgIGRlZmF1bHRTY2hlZHVsZXIuc2NoZWR1bGUodGhpcywgc2NoZWR1bGVNZXRob2QpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgV2luZG93ZWRPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdWJfXykge1xuICAgICAgaW5oZXJpdHMoV2luZG93ZWRPYnNlcnZlciwgX19zdWJfXyk7XG4gICAgICBmdW5jdGlvbiBXaW5kb3dlZE9ic2VydmVyKG9ic2VydmVyLCBvYnNlcnZhYmxlLCBjYW5jZWwpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlID0gbnVsbDtcbiAgICAgICAgX19zdWJfXy5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBXaW5kb3dlZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9O1xuXG4gICAgICBXaW5kb3dlZE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGlubmVyU2NoZWR1bGVNZXRob2Qocywgc2VsZikge1xuICAgICAgICByZXR1cm4gc2VsZi5vYnNlcnZhYmxlLnNvdXJjZS5yZXF1ZXN0KHNlbGYub2JzZXJ2YWJsZS53aW5kb3dTaXplKTtcbiAgICAgIH1cblxuICAgICAgV2luZG93ZWRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSArK3RoaXMucmVjZWl2ZWQgJSB0aGlzLm9ic2VydmFibGUud2luZG93U2l6ZTtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9PT0gMCAmJiAodGhpcy5zY2hlZHVsZURpc3Bvc2FibGUgPSBkZWZhdWx0U2NoZWR1bGVyLnNjaGVkdWxlKHRoaXMsIGlubmVyU2NoZWR1bGVNZXRob2QpKTtcbiAgICAgIH07XG5cbiAgICAgIFdpbmRvd2VkT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbC5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jYW5jZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSkge1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlRGlzcG9zYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgX19zdWJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFdpbmRvd2VkT2JzZXJ2ZXI7XG4gICAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgICByZXR1cm4gV2luZG93ZWRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNsaWRpbmcgd2luZG93ZWQgb2JzZXJ2YWJsZSBiYXNlZCB1cG9uIHRoZSB3aW5kb3cgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd1NpemUgVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgd2luZG93XG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIHdpbmRvd2VkIG9ic2VydmFibGUgYmFzZWQgdXBvbiB0aGUgd2luZG93IHNpemUuXG4gICAqL1xuICBDb250cm9sbGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93ZWQgPSBmdW5jdGlvbiAod2luZG93U2l6ZSkge1xuICAgIHJldHVybiBuZXcgV2luZG93ZWRPYnNlcnZhYmxlKHRoaXMsIHdpbmRvd1NpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQaXBlcyB0aGUgZXhpc3RpbmcgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIGEgTm9kZS5qcyBTdHJlYW0uXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBkZXN0IFRoZSBkZXN0aW5hdGlvbiBOb2RlLmpzIHN0cmVhbS5cbiAgICogQHJldHVybnMge1N0cmVhbX0gVGhlIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5wYXVzYWJsZUJ1ZmZlcmVkKCk7XG5cbiAgICBmdW5jdGlvbiBvbkRyYWluKCkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIGRlc3QuYWRkTGlzdGVuZXIoJ2RyYWluJywgb25EcmFpbik7XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgIWRlc3Qud3JpdGUoeCkgJiYgc291cmNlLnBhdXNlKCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEhhY2sgY2hlY2sgYmVjYXVzZSBTVERJTyBpcyBub3QgY2xvc2FibGVcbiAgICAgICAgIWRlc3QuX2lzU3RkaW8gJiYgZGVzdC5lbmQoKTtcbiAgICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbkRyYWluKTtcbiAgICAgIH0pO1xuXG4gICAgc291cmNlLnJlc3VtZSgpO1xuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH07XG5cbiAgcmV0dXJuIFJ4O1xufSkpO1xuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJvYmplY3RUeXBlcyIsImNoZWNrR2xvYmFsIiwidmFsdWUiLCJPYmplY3QiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwiZnJlZVdpbmRvdyIsIndpbmRvdyIsIm1vZHVsZUV4cG9ydHMiLCJ0aGlzR2xvYmFsIiwicm9vdCIsIkZ1bmN0aW9uIiwiZGVmaW5lIiwiYW1kIiwiUngiLCJyZXF1aXJlIiwiY2FsbCIsImV4cCIsInVuZGVmaW5lZCIsIk9ic2VydmFibGUiLCJvYnNlcnZhYmxlUHJvdG8iLCJwcm90b3R5cGUiLCJBbm9ueW1vdXNPYnNlcnZhYmxlIiwiQWJzdHJhY3RPYnNlcnZlciIsImludGVybmFscyIsIkNvbXBvc2l0ZURpc3Bvc2FibGUiLCJCaW5hcnlEaXNwb3NhYmxlIiwiTkFyeURpc3Bvc2FibGUiLCJOb3RpZmljYXRpb24iLCJTdWJqZWN0IiwiT2JzZXJ2ZXIiLCJkaXNwb3NhYmxlRW1wdHkiLCJEaXNwb3NhYmxlIiwiZW1wdHkiLCJkaXNwb3NhYmxlQ3JlYXRlIiwiY3JlYXRlIiwiaW5oZXJpdHMiLCJhZGRQcm9wZXJ0aWVzIiwiZGVmYXVsdFNjaGVkdWxlciIsIlNjaGVkdWxlciIsImN1cnJlbnRUaHJlYWRTY2hlZHVsZXIiLCJjdXJyZW50VGhyZWFkIiwiaWRlbnRpdHkiLCJoZWxwZXJzIiwiaXNTY2hlZHVsZXIiLCJpc0Z1bmN0aW9uIiwiY2hlY2tEaXNwb3NlZCIsImVycm9yT2JqIiwiZSIsInRyeUNhdGNoZXJHZW4iLCJ0cnlDYXRjaFRhcmdldCIsInRyeUNhdGNoZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyeUNhdGNoIiwiZm4iLCJUeXBlRXJyb3IiLCJ0aHJvd2VyIiwiUGF1c2VyIiwiX19zdXBlcl9fIiwicGF1c2UiLCJvbk5leHQiLCJyZXN1bWUiLCJQYXVzYWJsZU9ic2VydmFibGUiLCJzb3VyY2UiLCJwYXVzZXIiLCJjb250cm9sbGVyIiwicGF1c2VkIiwic3Vic2NyaWJlIiwibWVyZ2UiLCJfc3Vic2NyaWJlIiwibyIsImNvbm4iLCJwdWJsaXNoIiwic3Vic2NyaXB0aW9uIiwiY29ubmVjdGlvbiIsInBhdXNhYmxlIiwic3RhcnRXaXRoIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJiIiwiY29ubmVjdCIsImRpc3Bvc2UiLCJjb21iaW5lTGF0ZXN0U291cmNlIiwic3ViamVjdCIsInJlc3VsdFNlbGVjdG9yIiwiaGFzVmFsdWUiLCJoYXNWYWx1ZUFsbCIsImlzRG9uZSIsInZhbHVlcyIsIkFycmF5IiwiZXJyIiwibmV4dCIsIngiLCJpIiwiZXZlcnkiLCJvbkVycm9yIiwicmVzIiwib25Db21wbGV0ZWQiLCJQYXVzYWJsZUJ1ZmZlcmVkT2JzZXJ2YWJsZSIsInEiLCJwcmV2aW91c1Nob3VsZEZpcmUiLCJkcmFpblF1ZXVlIiwibGVuZ3RoIiwic2hpZnQiLCJkYXRhIiwic2hvdWxkRmlyZSIsInJlc3VsdHMiLCJwdXNoIiwicGF1c2FibGVCdWZmZXJlZCIsIkNvbnRyb2xsZWRPYnNlcnZhYmxlIiwiZW5hYmxlUXVldWUiLCJzY2hlZHVsZXIiLCJDb250cm9sbGVkU3ViamVjdCIsIm11bHRpY2FzdCIsInJlZkNvdW50IiwicmVxdWVzdCIsIm51bWJlck9mSXRlbXMiLCJxdWV1ZSIsInJlcXVlc3RlZENvdW50IiwicmVxdWVzdGVkRGlzcG9zYWJsZSIsImVycm9yIiwiaGFzRmFpbGVkIiwiaGFzQ29tcGxldGVkIiwiZGlzcG9zZUN1cnJlbnRSZXF1ZXN0IiwiY3JlYXRlT25Db21wbGV0ZWQiLCJjcmVhdGVPbkVycm9yIiwiY3JlYXRlT25OZXh0IiwiX3Byb2Nlc3NSZXF1ZXN0Iiwia2luZCIsImZpcnN0IiwiYWNjZXB0IiwibnVtYmVyIiwic2NoZWR1bGUiLCJzIiwicmVtYWluaW5nIiwic3RvcHBlZCIsImNvbnRyb2xsZWQiLCJTdG9wQW5kV2FpdE9ic2VydmFibGUiLCJzY2hlZHVsZU1ldGhvZCIsIlN0b3BBbmRXYWl0T2JzZXJ2ZXIiLCJfX3N1Yl9fIiwib2JzZXJ2ZXIiLCJvYnNlcnZhYmxlIiwiY2FuY2VsIiwic2NoZWR1bGVEaXNwb3NhYmxlIiwiY29tcGxldGVkIiwiaW5uZXJTY2hlZHVsZU1ldGhvZCIsInN0b3BBbmRXYWl0IiwiV2luZG93ZWRPYnNlcnZhYmxlIiwid2luZG93U2l6ZSIsIldpbmRvd2VkT2JzZXJ2ZXIiLCJyZWNlaXZlZCIsIndpbmRvd2VkIiwicGlwZSIsImRlc3QiLCJvbkRyYWluIiwiYWRkTGlzdGVuZXIiLCJ3cml0ZSIsImVtaXQiLCJfaXNTdGRpbyIsImVuZCIsInJlbW92ZUxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.backpressure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.binding.js":
/*!********************************************!*\
  !*** ./node_modules/rx/dist/rx.binding.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    var Observable = Rx.Observable, observableProto = Observable.prototype, AnonymousObservable = Rx.AnonymousObservable, ObservableBase = Rx.ObservableBase, Subject = Rx.Subject, AsyncSubject = Rx.AsyncSubject, Observer = Rx.Observer, ScheduledObserver = Rx.internals.ScheduledObserver, disposableCreate = Rx.Disposable.create, disposableEmpty = Rx.Disposable.empty, BinaryDisposable = Rx.BinaryDisposable, currentThreadScheduler = Rx.Scheduler.currentThread, isFunction = Rx.helpers.isFunction, inherits = Rx.internals.inherits, addProperties = Rx.internals.addProperties, checkDisposed = Rx.Disposable.checkDisposed;\n    // Utilities\n    function cloneArray(arr) {\n        var len = arr.length, a = new Array(len);\n        for(var i = 0; i < len; i++){\n            a[i] = arr[i];\n        }\n        return a;\n    }\n    var MulticastObservable = function(__super__) {\n        inherits(MulticastObservable, __super__);\n        function MulticastObservable(source, fn1, fn2) {\n            this.source = source;\n            this._fn1 = fn1;\n            this._fn2 = fn2;\n            __super__.call(this);\n        }\n        MulticastObservable.prototype.subscribeCore = function(o) {\n            var connectable = this.source.multicast(this._fn1());\n            return new BinaryDisposable(this._fn2(connectable).subscribe(o), connectable.connect());\n        };\n        return MulticastObservable;\n    }(ObservableBase);\n    /**\n   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each\n   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's\n   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n   *\n   * @example\n   * 1 - res = source.multicast(observable);\n   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });\n   *\n   * @param {Function|Subject} subjectOrSubjectSelector\n   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.\n   * Or:\n   * Subject to push source elements into.\n   *\n   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name=\"subjectOrSubjectSelector\" is a factory function.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */ observableProto.multicast = function(subjectOrSubjectSelector, selector) {\n        return isFunction(subjectOrSubjectSelector) ? new MulticastObservable(this, subjectOrSubjectSelector, selector) : new ConnectableObservable(this, subjectOrSubjectSelector);\n    };\n    /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.\n   * This operator is a specialization of Multicast using a regular Subject.\n   *\n   * @example\n   * var resres = source.publish();\n   * var res = source.publish(function (x) { return x; });\n   *\n   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */ observableProto.publish = function(selector) {\n        return selector && isFunction(selector) ? this.multicast(function() {\n            return new Subject();\n        }, selector) : this.multicast(new Subject());\n    };\n    /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence.\n   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */ observableProto.share = function() {\n        return this.publish().refCount();\n    };\n    /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.\n   * This operator is a specialization of Multicast using a AsyncSubject.\n   *\n   * @example\n   * var res = source.publishLast();\n   * var res = source.publishLast(function (x) { return x; });\n   *\n   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */ observableProto.publishLast = function(selector) {\n        return selector && isFunction(selector) ? this.multicast(function() {\n            return new AsyncSubject();\n        }, selector) : this.multicast(new AsyncSubject());\n    };\n    /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.\n   * This operator is a specialization of Multicast using a BehaviorSubject.\n   *\n   * @example\n   * var res = source.publishValue(42);\n   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);\n   *\n   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.\n   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */ observableProto.publishValue = function(initialValueOrSelector, initialValue) {\n        return arguments.length === 2 ? this.multicast(function() {\n            return new BehaviorSubject(initialValue);\n        }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));\n    };\n    /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.\n   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */ observableProto.shareValue = function(initialValue) {\n        return this.publishValue(initialValue).refCount();\n    };\n    /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n   * This operator is a specialization of Multicast using a ReplaySubject.\n   *\n   * @example\n   * var res = source.replay(null, 3);\n   * var res = source.replay(null, 3, 500);\n   * var res = source.replay(null, 3, 500, scheduler);\n   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);\n   *\n   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.\n   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n   * @param windowSize [Optional] Maximum time length of the replay buffer.\n   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */ observableProto.replay = function(selector, bufferSize, windowSize, scheduler) {\n        return selector && isFunction(selector) ? this.multicast(function() {\n            return new ReplaySubject(bufferSize, windowSize, scheduler);\n        }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));\n    };\n    /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   *\n   * @example\n   * var res = source.shareReplay(3);\n   * var res = source.shareReplay(3, 500);\n   * var res = source.shareReplay(3, 500, scheduler);\n   *\n\n   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n   * @param window [Optional] Maximum time length of the replay buffer.\n   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */ observableProto.shareReplay = function(bufferSize, windowSize, scheduler) {\n        return this.replay(null, bufferSize, windowSize, scheduler).refCount();\n    };\n    var InnerSubscription = function(s, o) {\n        this._s = s;\n        this._o = o;\n    };\n    InnerSubscription.prototype.dispose = function() {\n        if (!this._s.isDisposed && this._o !== null) {\n            var idx = this._s.observers.indexOf(this._o);\n            this._s.observers.splice(idx, 1);\n            this._o = null;\n        }\n    };\n    /**\n   *  Represents a value that changes over time.\n   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.\n   */ var BehaviorSubject = Rx.BehaviorSubject = function(__super__) {\n        inherits(BehaviorSubject, __super__);\n        function BehaviorSubject(value) {\n            __super__.call(this);\n            this.value = value;\n            this.observers = [];\n            this.isDisposed = false;\n            this.isStopped = false;\n            this.hasError = false;\n        }\n        addProperties(BehaviorSubject.prototype, Observer.prototype, {\n            _subscribe: function(o) {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.observers.push(o);\n                    o.onNext(this.value);\n                    return new InnerSubscription(this, o);\n                }\n                if (this.hasError) {\n                    o.onError(this.error);\n                } else {\n                    o.onCompleted();\n                }\n                return disposableEmpty;\n            },\n            /**\n       * Gets the current value or throws an exception.\n       * Value is frozen after onCompleted is called.\n       * After onError is called always throws the specified exception.\n       * An exception is always thrown after dispose is called.\n       * @returns {Mixed} The initial value passed to the constructor until onNext is called; after which, the last value passed to onNext.\n       */ getValue: function() {\n                checkDisposed(this);\n                if (this.hasError) {\n                    thrower(this.error);\n                }\n                return this.value;\n            },\n            /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */ hasObservers: function() {\n                checkDisposed(this);\n                return this.observers.length > 0;\n            },\n            /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */ onCompleted: function() {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                this.isStopped = true;\n                for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                    os[i].onCompleted();\n                }\n                this.observers.length = 0;\n            },\n            /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */ onError: function(error) {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                this.isStopped = true;\n                this.hasError = true;\n                this.error = error;\n                for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                    os[i].onError(error);\n                }\n                this.observers.length = 0;\n            },\n            /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */ onNext: function(value) {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                this.value = value;\n                for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                    os[i].onNext(value);\n                }\n            },\n            /**\n       * Unsubscribe all observers and release resources.\n       */ dispose: function() {\n                this.isDisposed = true;\n                this.observers = null;\n                this.value = null;\n                this.error = null;\n            }\n        });\n        return BehaviorSubject;\n    }(Observable);\n    /**\n   * Represents an object that is both an observable sequence as well as an observer.\n   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.\n   */ var ReplaySubject = Rx.ReplaySubject = function(__super__) {\n        var maxSafeInteger = Math.pow(2, 53) - 1;\n        function createRemovableDisposable(subject, observer) {\n            return disposableCreate(function() {\n                observer.dispose();\n                !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);\n            });\n        }\n        inherits(ReplaySubject, __super__);\n        /**\n     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.\n     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.\n     *  @param {Number} [windowSize] Maximum time length of the replay buffer.\n     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.\n     */ function ReplaySubject(bufferSize, windowSize, scheduler) {\n            this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;\n            this.windowSize = windowSize == null ? maxSafeInteger : windowSize;\n            this.scheduler = scheduler || currentThreadScheduler;\n            this.q = [];\n            this.observers = [];\n            this.isStopped = false;\n            this.isDisposed = false;\n            this.hasError = false;\n            this.error = null;\n            __super__.call(this);\n        }\n        addProperties(ReplaySubject.prototype, Observer.prototype, {\n            _subscribe: function(o) {\n                checkDisposed(this);\n                var so = new ScheduledObserver(this.scheduler, o), subscription = createRemovableDisposable(this, so);\n                this._trim(this.scheduler.now());\n                this.observers.push(so);\n                for(var i = 0, len = this.q.length; i < len; i++){\n                    so.onNext(this.q[i].value);\n                }\n                if (this.hasError) {\n                    so.onError(this.error);\n                } else if (this.isStopped) {\n                    so.onCompleted();\n                }\n                so.ensureActive();\n                return subscription;\n            },\n            /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */ hasObservers: function() {\n                checkDisposed(this);\n                return this.observers.length > 0;\n            },\n            _trim: function(now) {\n                while(this.q.length > this.bufferSize){\n                    this.q.shift();\n                }\n                while(this.q.length > 0 && now - this.q[0].interval > this.windowSize){\n                    this.q.shift();\n                }\n            },\n            /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */ onNext: function(value) {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                var now = this.scheduler.now();\n                this.q.push({\n                    interval: now,\n                    value: value\n                });\n                this._trim(now);\n                for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                    var observer = os[i];\n                    observer.onNext(value);\n                    observer.ensureActive();\n                }\n            },\n            /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */ onError: function(error) {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                this.isStopped = true;\n                this.error = error;\n                this.hasError = true;\n                var now = this.scheduler.now();\n                this._trim(now);\n                for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                    var observer = os[i];\n                    observer.onError(error);\n                    observer.ensureActive();\n                }\n                this.observers.length = 0;\n            },\n            /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */ onCompleted: function() {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                this.isStopped = true;\n                var now = this.scheduler.now();\n                this._trim(now);\n                for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                    var observer = os[i];\n                    observer.onCompleted();\n                    observer.ensureActive();\n                }\n                this.observers.length = 0;\n            },\n            /**\n       * Unsubscribe all observers and release resources.\n       */ dispose: function() {\n                this.isDisposed = true;\n                this.observers = null;\n            }\n        });\n        return ReplaySubject;\n    }(Observable);\n    var RefCountObservable = function(__super__) {\n        inherits(RefCountObservable, __super__);\n        function RefCountObservable(source) {\n            this.source = source;\n            this._count = 0;\n            this._connectableSubscription = null;\n            __super__.call(this);\n        }\n        RefCountObservable.prototype.subscribeCore = function(o) {\n            var subscription = this.source.subscribe(o);\n            ++this._count === 1 && (this._connectableSubscription = this.source.connect());\n            return new RefCountDisposable(this, subscription);\n        };\n        function RefCountDisposable(p, s) {\n            this._p = p;\n            this._s = s;\n            this.isDisposed = false;\n        }\n        RefCountDisposable.prototype.dispose = function() {\n            if (!this.isDisposed) {\n                this.isDisposed = true;\n                this._s.dispose();\n                --this._p._count === 0 && this._p._connectableSubscription.dispose();\n            }\n        };\n        return RefCountObservable;\n    }(ObservableBase);\n    var ConnectableObservable = Rx.ConnectableObservable = function(__super__) {\n        inherits(ConnectableObservable, __super__);\n        function ConnectableObservable(source, subject) {\n            this.source = source;\n            this._connection = null;\n            this._source = source.asObservable();\n            this._subject = subject;\n            __super__.call(this);\n        }\n        function ConnectDisposable(parent, subscription) {\n            this._p = parent;\n            this._s = subscription;\n        }\n        ConnectDisposable.prototype.dispose = function() {\n            if (this._s) {\n                this._s.dispose();\n                this._s = null;\n                this._p._connection = null;\n            }\n        };\n        ConnectableObservable.prototype.connect = function() {\n            if (!this._connection) {\n                if (this._subject.isStopped) {\n                    return disposableEmpty;\n                }\n                var subscription = this._source.subscribe(this._subject);\n                this._connection = new ConnectDisposable(this, subscription);\n            }\n            return this._connection;\n        };\n        ConnectableObservable.prototype._subscribe = function(o) {\n            return this._subject.subscribe(o);\n        };\n        ConnectableObservable.prototype.refCount = function() {\n            return new RefCountObservable(this);\n        };\n        return ConnectableObservable;\n    }(Observable);\n    /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence\n   * can be resubscribed to, even if all prior subscriptions have ended. (unlike `.publish().refCount()`)\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source.\n   */ observableProto.singleInstance = function() {\n        var source = this, hasObservable = false, observable;\n        function getObservable() {\n            if (!hasObservable) {\n                hasObservable = true;\n                observable = source[\"finally\"](function() {\n                    hasObservable = false;\n                }).publish().refCount();\n            }\n            return observable;\n        }\n        return new AnonymousObservable(function(o) {\n            return getObservable().subscribe(o);\n        });\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5iaW5kaW5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw2S0FBNkc7O0FBRTNHLFVBQVVBLE9BQU87SUFDakIsSUFBSUMsY0FBYztRQUNoQixZQUFZO1FBQ1osVUFBVTtJQUNaO0lBRUEsU0FBU0MsWUFBWUMsS0FBSztRQUN4QixPQUFPLFNBQVVBLE1BQU1DLE1BQU0sS0FBS0EsU0FBVUQsUUFBUTtJQUN0RDtJQUVBLElBQUlFLGNBQWMsV0FBWSxDQUFDLE9BQU9DLFFBQVEsSUFBSUEsV0FBVyxDQUFDQSxRQUFRQyxRQUFRLEdBQUlELFVBQVU7SUFDNUYsSUFBSUUsYUFBYSxXQUFZLENBQUMsUUFBYUMsQ0FBQyxJQUFJQSxVQUFVLENBQUNBLE9BQU9GLFFBQVEsR0FBSUUsU0FBUztJQUN2RixJQUFJQyxhQUFhUixZQUFZRyxlQUFlRyxjQUFjLE9BQU9HLFdBQVcsWUFBWUE7SUFDeEYsSUFBSUMsV0FBV1YsWUFBWUQsV0FBVyxDQUFDLE9BQU9ZLEtBQUssSUFBSUE7SUFDdkQsSUFBSUMsYUFBYVosWUFBWUQsV0FBVyxDQUFDLFlBQWMsSUFBSWM7SUFDM0QsSUFBSUMsZ0JBQWdCLGNBQWVSLFdBQVdGLE9BQU8sS0FBS0QsY0FBZUEsY0FBYztJQUN2RixJQUFJWSxhQUFhZixZQUFZRCxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJO0lBQzdELElBQUlpQixPQUFPUixjQUFlLGVBQWlCTyxDQUFBQSxjQUFjQSxXQUFXRixNQUFNLEtBQU1ELGNBQWVGLFlBQVlLLGNBQWNFLFNBQVM7SUFFbEksOEJBQThCO0lBQzlCLElBQUksSUFBMEMsRUFBRTtRQUM5Q0MsaUNBQU87WUFBQztTQUFPLG1DQUFFLFNBQVVFLEVBQUUsRUFBRWhCLFFBQU87WUFDcEMsT0FBT04sUUFBUWtCLE1BQU1aLFVBQVNnQjtRQUNoQyxDQUFDO0FBQUEsa0dBQUM7SUFDSixPQUFPLEVBSU47QUFDSCxHQUFFRSxJQUFJLENBQUMsUUFB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Q0FBQ3lFLFVBQVUsR0FBRyxTQUFVcEMsQ0FBQztZQUN0RCxPQUFPLElBQUksQ0FBQ3FFLFFBQVEsQ0FBQ2xFLFNBQVMsQ0FBQ0g7UUFDakM7UUFFQU8sc0JBQXNCNUMsU0FBUyxDQUFDK0MsUUFBUSxHQUFHO1lBQ3pDLE9BQU8sSUFBSWtELG1CQUFtQixJQUFJO1FBQ3BDO1FBRUEsT0FBT3JEO0lBQ1QsRUFBRTlDO0lBRUY7Ozs7R0FJQyxHQUNEQyxnQkFBZ0I4RyxjQUFjLEdBQUc7UUFDL0IsSUFBSTlFLFNBQVMsSUFBSSxFQUFFK0UsZ0JBQWdCLE9BQU9DO1FBRTFDLFNBQVNDO1lBQ1AsSUFBSSxDQUFDRixlQUFlO2dCQUNsQkEsZ0JBQWdCO2dCQUNoQkMsYUFBYWhGLE1BQU0sQ0FBQyxVQUFVLENBQUM7b0JBQWErRSxnQkFBZ0I7Z0JBQU8sR0FBR2pFLE9BQU8sR0FBR0UsUUFBUTtZQUMxRjtZQUNBLE9BQU9nRTtRQUNUO1FBRUEsT0FBTyxJQUFJOUcsb0JBQW9CLFNBQVNvQyxDQUFDO1lBQ3ZDLE9BQU8yRSxnQkFBZ0J4RSxTQUFTLENBQUNIO1FBQ25DO0lBQ0Y7SUFFQSxPQUFPNUM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3NlcnZlci1hY3Rpb24vLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5iaW5kaW5nLmpzPzcxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQsIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLk9iamVjdCA9PT0gT2JqZWN0KSA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIHZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkgPyBleHBvcnRzIDogbnVsbDtcbiAgdmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpID8gbW9kdWxlIDogbnVsbDtcbiAgdmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCk7XG4gIHZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcbiAgdmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IChmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpID8gZnJlZUV4cG9ydHMgOiBudWxsO1xuICB2YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLy8gQmVjYXVzZSBvZiBidWlsZCBvcHRpbWl6ZXJzXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWycuL3J4J10sIGZ1bmN0aW9uIChSeCwgZXhwb3J0cykge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgUngpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCwgbW9kdWxlLmV4cG9ydHMsIHJlcXVpcmUoJy4vcngnKSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5SeCA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuUngpO1xuICB9XG59LmNhbGwodGhpcywgZnVuY3Rpb24gKHJvb3QsIGV4cCwgUngsIHVuZGVmaW5lZCkge1xuXG4gIHZhciBPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZhYmxlUHJvdG8gPSBPYnNlcnZhYmxlLnByb3RvdHlwZSxcbiAgICBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSxcbiAgICBPYnNlcnZhYmxlQmFzZSA9IFJ4Lk9ic2VydmFibGVCYXNlLFxuICAgIFN1YmplY3QgPSBSeC5TdWJqZWN0LFxuICAgIEFzeW5jU3ViamVjdCA9IFJ4LkFzeW5jU3ViamVjdCxcbiAgICBPYnNlcnZlciA9IFJ4Lk9ic2VydmVyLFxuICAgIFNjaGVkdWxlZE9ic2VydmVyID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlZE9ic2VydmVyLFxuICAgIGRpc3Bvc2FibGVDcmVhdGUgPSBSeC5EaXNwb3NhYmxlLmNyZWF0ZSxcbiAgICBkaXNwb3NhYmxlRW1wdHkgPSBSeC5EaXNwb3NhYmxlLmVtcHR5LFxuICAgIEJpbmFyeURpc3Bvc2FibGUgPSBSeC5CaW5hcnlEaXNwb3NhYmxlLFxuICAgIGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIgPSBSeC5TY2hlZHVsZXIuY3VycmVudFRocmVhZCxcbiAgICBpc0Z1bmN0aW9uID0gUnguaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgIGluaGVyaXRzID0gUnguaW50ZXJuYWxzLmluaGVyaXRzLFxuICAgIGFkZFByb3BlcnRpZXMgPSBSeC5pbnRlcm5hbHMuYWRkUHJvcGVydGllcyxcbiAgICBjaGVja0Rpc3Bvc2VkID0gUnguRGlzcG9zYWJsZS5jaGVja0Rpc3Bvc2VkO1xuXG4gIC8vIFV0aWxpdGllc1xuICBmdW5jdGlvbiBjbG9uZUFycmF5KGFycikge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBhID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFbaV0gPSBhcnJbaV07IH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBNdWx0aWNhc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhNdWx0aWNhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE11bHRpY2FzdE9ic2VydmFibGUoc291cmNlLCBmbjEsIGZuMikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbjEgPSBmbjE7XG4gICAgICB0aGlzLl9mbjIgPSBmbjI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNdWx0aWNhc3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuc291cmNlLm11bHRpY2FzdCh0aGlzLl9mbjEoKSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUodGhpcy5fZm4yKGNvbm5lY3RhYmxlKS5zdWJzY3JpYmUobyksIGNvbm5lY3RhYmxlLmNvbm5lY3QoKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNdWx0aWNhc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIE11bHRpY2FzdHMgdGhlIHNvdXJjZSBzZXF1ZW5jZSBub3RpZmljYXRpb25zIHRocm91Z2ggYW4gaW5zdGFudGlhdGVkIHN1YmplY3QgaW50byBhbGwgdXNlcyBvZiB0aGUgc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uIEVhY2hcbiAgICogc3Vic2NyaXB0aW9uIHRvIHRoZSByZXN1bHRpbmcgc2VxdWVuY2UgY2F1c2VzIGEgc2VwYXJhdGUgbXVsdGljYXN0IGludm9jYXRpb24sIGV4cG9zaW5nIHRoZSBzZXF1ZW5jZSByZXN1bHRpbmcgZnJvbSB0aGUgc2VsZWN0b3IgZnVuY3Rpb24nc1xuICAgKiBpbnZvY2F0aW9uLiBGb3Igc3BlY2lhbGl6YXRpb25zIHdpdGggZml4ZWQgc3ViamVjdCB0eXBlcywgc2VlIFB1Ymxpc2gsIFB1Ymxpc2hMYXN0LCBhbmQgUmVwbGF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAxIC0gcmVzID0gc291cmNlLm11bHRpY2FzdChvYnNlcnZhYmxlKTtcbiAgICogMiAtIHJlcyA9IHNvdXJjZS5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3QoKTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN1YmplY3R9IHN1YmplY3RPclN1YmplY3RTZWxlY3RvclxuICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgc3ViamVjdCB0aHJvdWdoIHdoaWNoIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBlbGVtZW50cyB3aWxsIGJlIG11bHRpY2FzdCB0byB0aGUgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqIE9yOlxuICAgKiBTdWJqZWN0IHRvIHB1c2ggc291cmNlIGVsZW1lbnRzIGludG8uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIHN1YmplY3QgdG8gdGhlIHBvbGljaWVzIGVuZm9yY2VkIGJ5IHRoZSBjcmVhdGVkIHN1YmplY3QuIFNwZWNpZmllZCBvbmx5IGlmIDxwYXJhbXJlZiBuYW1lPVwic3ViamVjdE9yU3ViamVjdFNlbGVjdG9yXCIgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm11bHRpY2FzdCA9IGZ1bmN0aW9uIChzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oc3ViamVjdE9yU3ViamVjdFNlbGVjdG9yKSA/XG4gICAgICBuZXcgTXVsdGljYXN0T2JzZXJ2YWJsZSh0aGlzLCBzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IsIHNlbGVjdG9yKSA6XG4gICAgICBuZXcgQ29ubmVjdGFibGVPYnNlcnZhYmxlKHRoaXMsIHN1YmplY3RPclN1YmplY3RTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yIG9uIGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBNdWx0aWNhc3QgdXNpbmcgYSByZWd1bGFyIFN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXNyZXMgPSBzb3VyY2UucHVibGlzaCgpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIFNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IFN1YmplY3QoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoIHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCkucmVmQ291bnQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBjb250YWluaW5nIG9ubHkgdGhlIGxhc3Qgbm90aWZpY2F0aW9uLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgQXN5bmNTdWJqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hMYXN0KCk7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaExhc3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgW09wdGlvbmFsXSBTZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCBvbmx5IHJlY2VpdmUgdGhlIGxhc3Qgbm90aWZpY2F0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaExhc3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgJiYgaXNGdW5jdGlvbihzZWxlY3RvcikgP1xuICAgICAgdGhpcy5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFzeW5jU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IEFzeW5jU3ViamVjdCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzZXF1ZW5jZSBhbmQgc3RhcnRzIHdpdGggaW5pdGlhbFZhbHVlLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgTXVsdGljYXN0IHVzaW5nIGEgQmVoYXZpb3JTdWJqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcmVzID0gc291cmNlLnB1Ymxpc2hWYWx1ZSg0Mik7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucHVibGlzaFZhbHVlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNlbGVjdChmdW5jdGlvbiAoeSkgeyByZXR1cm4geSAqIHk7IH0pIH0sIDQyKTtcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGltbWVkaWF0ZWx5IHJlY2VpdmUgdGhlIGluaXRpYWwgdmFsdWUsIGZvbGxvd2VkIGJ5IGFsbCBub3RpZmljYXRpb25zIG9mIHRoZSBzb3VyY2UgZnJvbSB0aGUgdGltZSBvZiB0aGUgc3Vic2NyaXB0aW9uIG9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsVmFsdWUgSW5pdGlhbCB2YWx1ZSByZWNlaXZlZCBieSBvYnNlcnZlcnMgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aGluIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucHVibGlzaFZhbHVlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IsIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAyID9cbiAgICAgIHRoaXMubXVsdGljYXN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sIGluaXRpYWxWYWx1ZU9yU2VsZWN0b3IpIDpcbiAgICAgIHRoaXMubXVsdGljYXN0KG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlT3JTZWxlY3RvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIGFuZCBzdGFydHMgd2l0aCBhbiBpbml0aWFsVmFsdWUuXG4gICAqIFRoaXMgb3BlcmF0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBwdWJsaXNoVmFsdWUgd2hpY2ggY3JlYXRlcyBhIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIGdvZXMgZnJvbSB6ZXJvIHRvIG9uZSwgdGhlbiBzaGFyZXMgdGhhdCBzdWJzY3JpcHRpb24gd2l0aCBhbGwgc3Vic2VxdWVudCBvYnNlcnZlcnMgdW50aWwgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgcmV0dXJucyB0byB6ZXJvLCBhdCB3aGljaCBwb2ludCB0aGUgc3Vic2NyaXB0aW9uIGlzIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsVmFsdWUgSW5pdGlhbCB2YWx1ZSByZWNlaXZlZCBieSBvYnNlcnZlcnMgdXBvbiBzdWJzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2hhcmVWYWx1ZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoVmFsdWUoaW5pdGlhbFZhbHVlKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiBhIGNvbm5lY3RhYmxlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlIHJlcGxheWluZyBub3RpZmljYXRpb25zIHN1YmplY3QgdG8gYSBtYXhpbXVtIHRpbWUgbGVuZ3RoIGZvciB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIE11bHRpY2FzdCB1c2luZyBhIFJlcGxheVN1YmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KG51bGwsIDMpO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDApO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnJlcGxheShudWxsLCAzLCA1MDAsIHNjaGVkdWxlcik7XG4gICAqIHZhciByZXMgPSBzb3VyY2UucmVwbGF5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRha2UoNikucmVwZWF0KCk7IH0sIDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIFtPcHRpb25hbF0gU2VsZWN0b3IgZnVuY3Rpb24gd2hpY2ggY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgdGhlIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBzdWJqZWN0IHRvIHRoZSBzcGVjaWZpZWQgcmVwbGF5IGJ1ZmZlciB0cmltbWluZyBwb2xpY3kuXG4gICAqIEBwYXJhbSBidWZmZXJTaXplIFtPcHRpb25hbF0gTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gd2luZG93U2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gdGltZSBsZW5ndGggb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSBzY2hlZHVsZXIgW09wdGlvbmFsXSBTY2hlZHVsZXIgd2hlcmUgY29ubmVjdGVkIG9ic2VydmVycyB3aXRoaW4gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5yZXBsYXkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGJ1ZmZlclNpemUsIHdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBzZWxlY3RvciAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yKSA/XG4gICAgICB0aGlzLm11bHRpY2FzdChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgdGhpcy5tdWx0aWNhc3QobmV3IFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc2VxdWVuY2UgcmVwbGF5aW5nIG5vdGlmaWNhdGlvbnMgc3ViamVjdCB0byBhIG1heGltdW0gdGltZSBsZW5ndGggZm9yIHRoZSByZXBsYXkgYnVmZmVyLlxuICAgKiBUaGlzIG9wZXJhdG9yIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgcmVwbGF5IHdoaWNoIGNyZWF0ZXMgYSBzdWJzY3JpcHRpb24gd2hlbiB0aGUgbnVtYmVyIG9mIG9ic2VydmVycyBnb2VzIGZyb20gemVybyB0byBvbmUsIHRoZW4gc2hhcmVzIHRoYXQgc3Vic2NyaXB0aW9uIHdpdGggYWxsIHN1YnNlcXVlbnQgb2JzZXJ2ZXJzIHVudGlsIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXJzIHJldHVybnMgdG8gemVybywgYXQgd2hpY2ggcG9pbnQgdGhlIHN1YnNjcmlwdGlvbiBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZVJlcGxheSgzKTtcbiAgICogdmFyIHJlcyA9IHNvdXJjZS5zaGFyZVJlcGxheSgzLCA1MDApO1xuICAgKiB2YXIgcmVzID0gc291cmNlLnNoYXJlUmVwbGF5KDMsIDUwMCwgc2NoZWR1bGVyKTtcbiAgICpcblxuICAgKiBAcGFyYW0gYnVmZmVyU2l6ZSBbT3B0aW9uYWxdIE1heGltdW0gZWxlbWVudCBjb3VudCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIHdpbmRvdyBbT3B0aW9uYWxdIE1heGltdW0gdGltZSBsZW5ndGggb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAqIEBwYXJhbSBzY2hlZHVsZXIgW09wdGlvbmFsXSBTY2hlZHVsZXIgd2hlcmUgY29ubmVjdGVkIG9ic2VydmVycyB3aXRoaW4gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zaGFyZVJlcGxheSA9IGZ1bmN0aW9uIChidWZmZXJTaXplLCB3aW5kb3dTaXplLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYXkobnVsbCwgYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKS5yZWZDb3VudCgpO1xuICB9O1xuXG4gIHZhciBJbm5lclN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzLCBvKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fbyA9IG87XG4gIH07XG5cbiAgSW5uZXJTdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9zLmlzRGlzcG9zZWQgJiYgdGhpcy5fbyAhPT0gbnVsbCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuX3Mub2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5fbyk7XG4gICAgICB0aGlzLl9zLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHRoaXMuX28gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIFJlcHJlc2VudHMgYSB2YWx1ZSB0aGF0IGNoYW5nZXMgb3ZlciB0aW1lLlxuICAgKiAgT2JzZXJ2ZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlIHN1YmplY3QgdG8gcmVjZWl2ZSB0aGUgbGFzdCAob3IgaW5pdGlhbCkgdmFsdWUgYW5kIGFsbCBzdWJzZXF1ZW50IG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICB2YXIgQmVoYXZpb3JTdWJqZWN0ID0gUnguQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhCZWhhdmlvclN1YmplY3QsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQmVoYXZpb3JTdWJqZWN0KHZhbHVlKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkUHJvcGVydGllcyhCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgICAgIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTdWJzY3JpcHRpb24odGhpcywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICBvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgKiBWYWx1ZSBpcyBmcm96ZW4gYWZ0ZXIgb25Db21wbGV0ZWQgaXMgY2FsbGVkLlxuICAgICAgICogQWZ0ZXIgb25FcnJvciBpcyBjYWxsZWQgYWx3YXlzIHRocm93cyB0aGUgc3BlY2lmaWVkIGV4Y2VwdGlvbi5cbiAgICAgICAqIEFuIGV4Y2VwdGlvbiBpcyBhbHdheXMgdGhyb3duIGFmdGVyIGRpc3Bvc2UgaXMgY2FsbGVkLlxuICAgICAgICogQHJldHVybnMge01peGVkfSBUaGUgaW5pdGlhbCB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHVudGlsIG9uTmV4dCBpcyBjYWxsZWQ7IGFmdGVyIHdoaWNoLCB0aGUgbGFzdCB2YWx1ZSBwYXNzZWQgdG8gb25OZXh0LlxuICAgICAgICovXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikgeyB0aHJvd2VyKHRoaXMuZXJyb3IpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqL1xuICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7IGNoZWNrRGlzcG9zZWQodGhpcyk7IHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGggPiAwOyB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBvc1tpXS5vbk5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBVbnN1YnNjcmliZSBhbGwgb2JzZXJ2ZXJzIGFuZCByZWxlYXNlIHJlc291cmNlcy5cbiAgICAgICAqL1xuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGlzIGJvdGggYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyB3ZWxsIGFzIGFuIG9ic2VydmVyLlxuICAgKiBFYWNoIG5vdGlmaWNhdGlvbiBpcyBicm9hZGNhc3RlZCB0byBhbGwgc3Vic2NyaWJlZCBhbmQgZnV0dXJlIG9ic2VydmVycywgc3ViamVjdCB0byBidWZmZXIgdHJpbW1pbmcgcG9saWNpZXMuXG4gICAqL1xuICB2YXIgUmVwbGF5U3ViamVjdCA9IFJ4LlJlcGxheVN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuXG4gICAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUoc3ViamVjdCwgb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlQ3JlYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzcG9zZSgpO1xuICAgICAgICAhc3ViamVjdC5pc0Rpc3Bvc2VkICYmIHN1YmplY3Qub2JzZXJ2ZXJzLnNwbGljZShzdWJqZWN0Lm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhSZXBsYXlTdWJqZWN0LCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBSZXBsYXlTdWJqZWN0IGNsYXNzIHdpdGggdGhlIHNwZWNpZmllZCBidWZmZXIgc2l6ZSwgd2luZG93IHNpemUgYW5kIHNjaGVkdWxlci5cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtidWZmZXJTaXplXSBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgdGhlIHJlcGxheSBidWZmZXIuXG4gICAgICogIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZV0gTWF4aW11bSB0aW1lIGxlbmd0aCBvZiB0aGUgcmVwbGF5IGJ1ZmZlci5cbiAgICAgKiAgQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0aGUgb2JzZXJ2ZXJzIGFyZSBpbnZva2VkIG9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplID09IG51bGwgPyBtYXhTYWZlSW50ZWdlciA6IGJ1ZmZlclNpemU7XG4gICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplID09IG51bGwgPyBtYXhTYWZlSW50ZWdlciA6IHdpbmRvd1NpemU7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlciB8fCBjdXJyZW50VGhyZWFkU2NoZWR1bGVyO1xuICAgICAgdGhpcy5xID0gW107XG4gICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKFJlcGxheVN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIHZhciBzbyA9IG5ldyBTY2hlZHVsZWRPYnNlcnZlcih0aGlzLnNjaGVkdWxlciwgbyksIHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVJlbW92YWJsZURpc3Bvc2FibGUodGhpcywgc28pO1xuXG4gICAgICAgIHRoaXMuX3RyaW0odGhpcy5zY2hlZHVsZXIubm93KCkpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHNvKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5xLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc28ub25OZXh0KHRoaXMucVtpXS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgIHNvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICBzby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc28uZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICBfdHJpbTogZnVuY3Rpb24gKG5vdykge1xuICAgICAgICB3aGlsZSAodGhpcy5xLmxlbmd0aCA+IHRoaXMuYnVmZmVyU2l6ZSkge1xuICAgICAgICAgIHRoaXMucS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnEubGVuZ3RoID4gMCAmJiAobm93IC0gdGhpcy5xWzBdLmludGVydmFsKSA+IHRoaXMud2luZG93U2l6ZSkge1xuICAgICAgICAgIHRoaXMucS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGFycml2YWwgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLnEucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5fdHJpbShub3cpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG9zW2ldO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgb2JzZXJ2ZXIuZW5zdXJlQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIGV4Y2VwdGlvbiB0byBzZW5kIHRvIGFsbCBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLl90cmltKG5vdyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IG9zW2ldO1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIG9ic2VydmVyLmVuc3VyZUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKi9cbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHRoaXMuX3RyaW0obm93KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gb3NbaV07XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBvYnNlcnZlci5lbnN1cmVBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICAgKi9cbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlcGxheVN1YmplY3Q7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIHZhciBSZWZDb3VudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlZkNvdW50T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgIHRoaXMuX2Nvbm5lY3RhYmxlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFJlZkNvdW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG8pO1xuICAgICAgKyt0aGlzLl9jb3VudCA9PT0gMSAmJiAodGhpcy5fY29ubmVjdGFibGVTdWJzY3JpcHRpb24gPSB0aGlzLnNvdXJjZS5jb25uZWN0KCkpO1xuICAgICAgcmV0dXJuIG5ldyBSZWZDb3VudERpc3Bvc2FibGUodGhpcywgc3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmQ291bnREaXNwb3NhYmxlKHAsIHMpIHtcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBSZWZDb3VudERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zLmRpc3Bvc2UoKTtcbiAgICAgICAgLS10aGlzLl9wLl9jb3VudCA9PT0gMCAmJiB0aGlzLl9wLl9jb25uZWN0YWJsZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBSZWZDb3VudE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gUnguQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29ubmVjdERpc3Bvc2FibGUocGFyZW50LCBzdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3AgPSBwYXJlbnQ7XG4gICAgICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xuICAgIH1cblxuICAgIENvbm5lY3REaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3MpIHtcbiAgICAgICAgdGhpcy5fcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9wLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3NvdXJjZS5zdWJzY3JpYmUodGhpcy5fc3ViamVjdCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdERpc3Bvc2FibGUodGhpcywgc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uO1xuICAgIH07XG5cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Quc3Vic2NyaWJlKG8pO1xuICAgIH07XG5cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWZDb3VudE9ic2VydmFibGUodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHNlcXVlbmNlLiBUaGlzIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogY2FuIGJlIHJlc3Vic2NyaWJlZCB0bywgZXZlbiBpZiBhbGwgcHJpb3Igc3Vic2NyaXB0aW9ucyBoYXZlIGVuZGVkLiAodW5saWtlIGAucHVibGlzaCgpLnJlZkNvdW50KClgKVxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNpbmdsZUluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMsIGhhc09ic2VydmFibGUgPSBmYWxzZSwgb2JzZXJ2YWJsZTtcblxuICAgIGZ1bmN0aW9uIGdldE9ic2VydmFibGUoKSB7XG4gICAgICBpZiAoIWhhc09ic2VydmFibGUpIHtcbiAgICAgICAgaGFzT2JzZXJ2YWJsZSA9IHRydWU7XG4gICAgICAgIG9ic2VydmFibGUgPSBzb3VyY2VbJ2ZpbmFsbHknXShmdW5jdGlvbigpIHsgaGFzT2JzZXJ2YWJsZSA9IGZhbHNlOyB9KS5wdWJsaXNoKCkucmVmQ291bnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gZ2V0T2JzZXJ2YWJsZSgpLnN1YnNjcmliZShvKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVQcm90byIsInByb3RvdHlwZSIsIkFub255bW91c09ic2VydmFibGUiLCJPYnNlcnZhYmxlQmFzZSIsIlN1YmplY3QiLCJBc3luY1N1YmplY3QiLCJPYnNlcnZlciIsIlNjaGVkdWxlZE9ic2VydmVyIiwiaW50ZXJuYWxzIiwiZGlzcG9zYWJsZUNyZWF0ZSIsIkRpc3Bvc2FibGUiLCJjcmVhdGUiLCJkaXNwb3NhYmxlRW1wdHkiLCJlbXB0eSIsIkJpbmFyeURpc3Bvc2FibGUiLCJjdXJyZW50VGhyZWFkU2NoZWR1bGVyIiwiU2NoZWR1bGVyIiwiY3VycmVudFRocmVhZCIsImlzRnVuY3Rpb24iLCJoZWxwZXJzIiwiaW5oZXJpdHMiLCJhZGRQcm9wZXJ0aWVzIiwiY2hlY2tEaXNwb3NlZCIsImNsb25lQXJyYXkiLCJhcnIiLCJsZW4iLCJsZW5ndGgiLCJhIiwiQXJyYXkiLCJpIiwiTXVsdGljYXN0T2JzZXJ2YWJsZSIsIl9fc3VwZXJfXyIsInNvdXJjZSIsImZuMSIsImZuMiIsIl9mbjEiLCJfZm4yIiwic3Vic2NyaWJlQ29yZSIsIm8iLCJjb25uZWN0YWJsZSIsIm11bHRpY2FzdCIsInN1YnNjcmliZSIsImNvbm5lY3QiLCJzdWJqZWN0T3JTdWJqZWN0U2VsZWN0b3IiLCJzZWxlY3RvciIsIkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSIsInB1Ymxpc2giLCJzaGFyZSIsInJlZkNvdW50IiwicHVibGlzaExhc3QiLCJwdWJsaXNoVmFsdWUiLCJpbml0aWFsVmFsdWVPclNlbGVjdG9yIiwiaW5pdGlhbFZhbHVlIiwiYXJndW1lbnRzIiwiQmVoYXZpb3JTdWJqZWN0Iiwic2hhcmVWYWx1ZSIsInJlcGxheSIsImJ1ZmZlclNpemUiLCJ3aW5kb3dTaXplIiwic2NoZWR1bGVyIiwiUmVwbGF5U3ViamVjdCIsInNoYXJlUmVwbGF5IiwiSW5uZXJTdWJzY3JpcHRpb24iLCJzIiwiX3MiLCJfbyIsImRpc3Bvc2UiLCJpc0Rpc3Bvc2VkIiwiaWR4Iiwib2JzZXJ2ZXJzIiwiaW5kZXhPZiIsInNwbGljZSIsImlzU3RvcHBlZCIsImhhc0Vycm9yIiwiX3N1YnNjcmliZSIsInB1c2giLCJvbk5leHQiLCJvbkVycm9yIiwiZXJyb3IiLCJvbkNvbXBsZXRlZCIsImdldFZhbHVlIiwidGhyb3dlciIsImhhc09ic2VydmVycyIsIm9zIiwibWF4U2FmZUludGVnZXIiLCJNYXRoIiwicG93IiwiY3JlYXRlUmVtb3ZhYmxlRGlzcG9zYWJsZSIsInN1YmplY3QiLCJvYnNlcnZlciIsInEiLCJzbyIsInN1YnNjcmlwdGlvbiIsIl90cmltIiwibm93IiwiZW5zdXJlQWN0aXZlIiwic2hpZnQiLCJpbnRlcnZhbCIsIlJlZkNvdW50T2JzZXJ2YWJsZSIsIl9jb3VudCIsIl9jb25uZWN0YWJsZVN1YnNjcmlwdGlvbiIsIlJlZkNvdW50RGlzcG9zYWJsZSIsInAiLCJfcCIsIl9jb25uZWN0aW9uIiwiX3NvdXJjZSIsImFzT2JzZXJ2YWJsZSIsIl9zdWJqZWN0IiwiQ29ubmVjdERpc3Bvc2FibGUiLCJwYXJlbnQiLCJzaW5nbGVJbnN0YW5jZSIsImhhc09ic2VydmFibGUiLCJvYnNlcnZhYmxlIiwiZ2V0T2JzZXJ2YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.binding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.coincidence.js":
/*!************************************************!*\
  !*** ./node_modules/rx/dist/rx.coincidence.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    var Observable = Rx.Observable, ObservableBase = Rx.ObservableBase, AbstractObserver = Rx.internals.AbstractObserver, CompositeDisposable = Rx.CompositeDisposable, BinaryDisposable = Rx.BinaryDisposable, RefCountDisposable = Rx.RefCountDisposable, SingleAssignmentDisposable = Rx.SingleAssignmentDisposable, SerialDisposable = Rx.SerialDisposable, Subject = Rx.Subject, observableProto = Observable.prototype, observableEmpty = Observable.empty, observableNever = Observable.never, AnonymousObservable = Rx.AnonymousObservable, addRef = Rx.internals.addRef, inherits = Rx.internals.inherits, bindCallback = Rx.internals.bindCallback, noop = Rx.helpers.noop, isPromise = Rx.helpers.isPromise, isFunction = Rx.helpers.isFunction, observableFromPromise = Observable.fromPromise;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    var Map = root.Map || function() {\n        function Map() {\n            this.size = 0;\n            this._values = [];\n            this._keys = [];\n        }\n        Map.prototype[\"delete\"] = function(key) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                return false;\n            }\n            this._values.splice(i, 1);\n            this._keys.splice(i, 1);\n            this.size--;\n            return true;\n        };\n        Map.prototype.get = function(key) {\n            var i = this._keys.indexOf(key);\n            return i === -1 ? undefined : this._values[i];\n        };\n        Map.prototype.set = function(key, value) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                this._keys.push(key);\n                this._values.push(value);\n                this.size++;\n            } else {\n                this._values[i] = value;\n            }\n            return this;\n        };\n        Map.prototype.forEach = function(cb, thisArg) {\n            for(var i = 0; i < this.size; i++){\n                cb.call(thisArg, this._values[i], this._keys[i]);\n            }\n        };\n        return Map;\n    }();\n    /**\n   *  Correlates the elements of two sequences based on overlapping durations.\n   *\n   *  @param {Observable} right The right observable sequence to join elements for.\n   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.\n   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n   */ observableProto.join = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {\n        var left = this;\n        return new AnonymousObservable(function(o) {\n            var group = new CompositeDisposable();\n            var leftDone = false, rightDone = false;\n            var leftId = 0, rightId = 0;\n            var leftMap = new Map(), rightMap = new Map();\n            var handleError = function(e) {\n                o.onError(e);\n            };\n            group.add(left.subscribe(function(value) {\n                var id = leftId++, md = new SingleAssignmentDisposable();\n                leftMap.set(id, value);\n                group.add(md);\n                var duration = tryCatch(leftDurationSelector)(value);\n                if (duration === errorObj) {\n                    return o.onError(duration.e);\n                }\n                md.setDisposable(duration.take(1).subscribe(noop, handleError, function() {\n                    leftMap[\"delete\"](id) && leftMap.size === 0 && leftDone && o.onCompleted();\n                    group.remove(md);\n                }));\n                rightMap.forEach(function(v) {\n                    var result = tryCatch(resultSelector)(value, v);\n                    if (result === errorObj) {\n                        return o.onError(result.e);\n                    }\n                    o.onNext(result);\n                });\n            }, handleError, function() {\n                leftDone = true;\n                (rightDone || leftMap.size === 0) && o.onCompleted();\n            }));\n            group.add(right.subscribe(function(value) {\n                var id = rightId++, md = new SingleAssignmentDisposable();\n                rightMap.set(id, value);\n                group.add(md);\n                var duration = tryCatch(rightDurationSelector)(value);\n                if (duration === errorObj) {\n                    return o.onError(duration.e);\n                }\n                md.setDisposable(duration.take(1).subscribe(noop, handleError, function() {\n                    rightMap[\"delete\"](id) && rightMap.size === 0 && rightDone && o.onCompleted();\n                    group.remove(md);\n                }));\n                leftMap.forEach(function(v) {\n                    var result = tryCatch(resultSelector)(v, value);\n                    if (result === errorObj) {\n                        return o.onError(result.e);\n                    }\n                    o.onNext(result);\n                });\n            }, handleError, function() {\n                rightDone = true;\n                (leftDone || rightMap.size === 0) && o.onCompleted();\n            }));\n            return group;\n        }, left);\n    };\n    /**\n   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.\n   *\n   *  @param {Observable} right The right observable sequence to join elements for.\n   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.\n   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n   */ observableProto.groupJoin = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {\n        var left = this;\n        return new AnonymousObservable(function(o) {\n            var group = new CompositeDisposable();\n            var r = new RefCountDisposable(group);\n            var leftMap = new Map(), rightMap = new Map();\n            var leftId = 0, rightId = 0;\n            var handleError = function(e) {\n                return function(v) {\n                    v.onError(e);\n                };\n            };\n            function handleError(e) {}\n            ;\n            group.add(left.subscribe(function(value) {\n                var s = new Subject();\n                var id = leftId++;\n                leftMap.set(id, s);\n                var result = tryCatch(resultSelector)(value, addRef(s, r));\n                if (result === errorObj) {\n                    leftMap.forEach(handleError(result.e));\n                    return o.onError(result.e);\n                }\n                o.onNext(result);\n                rightMap.forEach(function(v) {\n                    s.onNext(v);\n                });\n                var md = new SingleAssignmentDisposable();\n                group.add(md);\n                var duration = tryCatch(leftDurationSelector)(value);\n                if (duration === errorObj) {\n                    leftMap.forEach(handleError(duration.e));\n                    return o.onError(duration.e);\n                }\n                md.setDisposable(duration.take(1).subscribe(noop, function(e) {\n                    leftMap.forEach(handleError(e));\n                    o.onError(e);\n                }, function() {\n                    leftMap[\"delete\"](id) && s.onCompleted();\n                    group.remove(md);\n                }));\n            }, function(e) {\n                leftMap.forEach(handleError(e));\n                o.onError(e);\n            }, function() {\n                o.onCompleted();\n            }));\n            group.add(right.subscribe(function(value) {\n                var id = rightId++;\n                rightMap.set(id, value);\n                var md = new SingleAssignmentDisposable();\n                group.add(md);\n                var duration = tryCatch(rightDurationSelector)(value);\n                if (duration === errorObj) {\n                    leftMap.forEach(handleError(duration.e));\n                    return o.onError(duration.e);\n                }\n                md.setDisposable(duration.take(1).subscribe(noop, function(e) {\n                    leftMap.forEach(handleError(e));\n                    o.onError(e);\n                }, function() {\n                    rightMap[\"delete\"](id);\n                    group.remove(md);\n                }));\n                leftMap.forEach(function(v) {\n                    v.onNext(value);\n                });\n            }, function(e) {\n                leftMap.forEach(handleError(e));\n                o.onError(e);\n            }));\n            return r;\n        }, left);\n    };\n    function toArray(x) {\n        return x.toArray();\n    }\n    /**\n   *  Projects each element of an observable sequence into zero or more buffers.\n   *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).\n   *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.\n   *  @returns {Observable} An observable sequence of windows.\n   */ observableProto.buffer = function() {\n        return this.window.apply(this, arguments).flatMap(toArray);\n    };\n    /**\n   *  Projects each element of an observable sequence into zero or more windows.\n   *\n   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).\n   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.\n   *  @returns {Observable} An observable sequence of windows.\n   */ observableProto.window = function(windowOpeningsOrClosingSelector, windowClosingSelector) {\n        if (arguments.length === 1 && typeof arguments[0] !== \"function\") {\n            return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);\n        }\n        return typeof windowOpeningsOrClosingSelector === \"function\" ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);\n    };\n    function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {\n        return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function(_, win) {\n            return win;\n        });\n    }\n    function observableWindowWithBoundaries(windowBoundaries) {\n        var source = this;\n        return new AnonymousObservable(function(observer) {\n            var win = new Subject(), d = new CompositeDisposable(), r = new RefCountDisposable(d);\n            observer.onNext(addRef(win, r));\n            d.add(source.subscribe(function(x) {\n                win.onNext(x);\n            }, function(err) {\n                win.onError(err);\n                observer.onError(err);\n            }, function() {\n                win.onCompleted();\n                observer.onCompleted();\n            }));\n            isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));\n            d.add(windowBoundaries.subscribe(function(w) {\n                win.onCompleted();\n                win = new Subject();\n                observer.onNext(addRef(win, r));\n            }, function(err) {\n                win.onError(err);\n                observer.onError(err);\n            }, function() {\n                win.onCompleted();\n                observer.onCompleted();\n            }));\n            return r;\n        }, source);\n    }\n    function observableWindowWithClosingSelector(windowClosingSelector) {\n        var source = this;\n        return new AnonymousObservable(function(observer) {\n            var m = new SerialDisposable(), d = new CompositeDisposable(m), r = new RefCountDisposable(d), win = new Subject();\n            observer.onNext(addRef(win, r));\n            d.add(source.subscribe(function(x) {\n                win.onNext(x);\n            }, function(err) {\n                win.onError(err);\n                observer.onError(err);\n            }, function() {\n                win.onCompleted();\n                observer.onCompleted();\n            }));\n            function createWindowClose() {\n                var windowClose;\n                try {\n                    windowClose = windowClosingSelector();\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));\n                var m1 = new SingleAssignmentDisposable();\n                m.setDisposable(m1);\n                m1.setDisposable(windowClose.take(1).subscribe(noop, function(err) {\n                    win.onError(err);\n                    observer.onError(err);\n                }, function() {\n                    win.onCompleted();\n                    win = new Subject();\n                    observer.onNext(addRef(win, r));\n                    createWindowClose();\n                }));\n            }\n            createWindowClose();\n            return r;\n        }, source);\n    }\n    var PairwiseObservable = function(__super__) {\n        inherits(PairwiseObservable, __super__);\n        function PairwiseObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        PairwiseObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new PairwiseObserver(o));\n        };\n        return PairwiseObservable;\n    }(ObservableBase);\n    var PairwiseObserver = function(__super__) {\n        inherits(PairwiseObserver, __super__);\n        function PairwiseObserver(o) {\n            this._o = o;\n            this._p = null;\n            this._hp = false;\n            __super__.call(this);\n        }\n        PairwiseObserver.prototype.next = function(x) {\n            if (this._hp) {\n                this._o.onNext([\n                    this._p,\n                    x\n                ]);\n            } else {\n                this._hp = true;\n            }\n            this._p = x;\n        };\n        PairwiseObserver.prototype.error = function(err) {\n            this._o.onError(err);\n        };\n        PairwiseObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return PairwiseObserver;\n    }(AbstractObserver);\n    /**\n   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.\n   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.\n   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.\n   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.\n   */ observableProto.pairwise = function() {\n        return new PairwiseObservable(this);\n    };\n    /**\n   * Returns two observables which partition the observations of the source by the given function.\n   * The first will trigger observations for those values for which the predicate returns true.\n   * The second will trigger observations for those values where the predicate returns false.\n   * The predicate is executed once for each subscribed observer.\n   * Both also propagate all error observations arising from the source and each completes\n   * when the source completes.\n   * @param {Function} predicate\n   *    The function to determine which output Observable will trigger a particular observation.\n   * @returns {Array}\n   *    An array of observables. The first triggers when the predicate returns true,\n   *    and the second triggers when the predicate returns false.\n  */ observableProto.partition = function(predicate, thisArg) {\n        var fn = bindCallback(predicate, thisArg, 3);\n        return [\n            this.filter(predicate, thisArg),\n            this.filter(function(x, i, o) {\n                return !fn(x, i, o);\n            })\n        ];\n    };\n    /**\n   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.\n   *\n   * @example\n   *  var res = observable.groupBy(function (x) { return x.id; });\n   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });\n   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });\n   * @param {Function} keySelector A function to extract the key for each element.\n   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.\n   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n   */ observableProto.groupBy = function(keySelector, elementSelector) {\n        return this.groupByUntil(keySelector, elementSelector, observableNever);\n    };\n    /**\n     *  Groups the elements of an observable sequence according to a specified key selector function.\n     *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n     *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n     *\n     * @example\n     *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n     *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n     *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n     * @param {Function} keySelector A function to extract the key for each element.\n     * @param {Function} durationSelector A function to signal the expiration of a group.\n     * @returns {Observable}\n     *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n     *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n     *\n     */ observableProto.groupByUntil = function(keySelector, elementSelector, durationSelector) {\n        var source = this;\n        return new AnonymousObservable(function(o) {\n            var map = new Map(), groupDisposable = new CompositeDisposable(), refCountDisposable = new RefCountDisposable(groupDisposable), handleError = function(e) {\n                return function(item) {\n                    item.onError(e);\n                };\n            };\n            groupDisposable.add(source.subscribe(function(x) {\n                var key = tryCatch(keySelector)(x);\n                if (key === errorObj) {\n                    map.forEach(handleError(key.e));\n                    return o.onError(key.e);\n                }\n                var fireNewMapEntry = false, writer = map.get(key);\n                if (writer === undefined) {\n                    writer = new Subject();\n                    map.set(key, writer);\n                    fireNewMapEntry = true;\n                }\n                if (fireNewMapEntry) {\n                    var group = new GroupedObservable(key, writer, refCountDisposable), durationGroup = new GroupedObservable(key, writer);\n                    var duration = tryCatch(durationSelector)(durationGroup);\n                    if (duration === errorObj) {\n                        map.forEach(handleError(duration.e));\n                        return o.onError(duration.e);\n                    }\n                    o.onNext(group);\n                    var md = new SingleAssignmentDisposable();\n                    groupDisposable.add(md);\n                    md.setDisposable(duration.take(1).subscribe(noop, function(e) {\n                        map.forEach(handleError(e));\n                        o.onError(e);\n                    }, function() {\n                        if (map[\"delete\"](key)) {\n                            writer.onCompleted();\n                        }\n                        groupDisposable.remove(md);\n                    }));\n                }\n                var element = x;\n                if (isFunction(elementSelector)) {\n                    element = tryCatch(elementSelector)(x);\n                    if (element === errorObj) {\n                        map.forEach(handleError(element.e));\n                        return o.onError(element.e);\n                    }\n                }\n                writer.onNext(element);\n            }, function(e) {\n                map.forEach(handleError(e));\n                o.onError(e);\n            }, function() {\n                map.forEach(function(item) {\n                    item.onCompleted();\n                });\n                o.onCompleted();\n            }));\n            return refCountDisposable;\n        }, source);\n    };\n    var UnderlyingObservable = function(__super__) {\n        inherits(UnderlyingObservable, __super__);\n        function UnderlyingObservable(m, u) {\n            this._m = m;\n            this._u = u;\n            __super__.call(this);\n        }\n        UnderlyingObservable.prototype.subscribeCore = function(o) {\n            return new BinaryDisposable(this._m.getDisposable(), this._u.subscribe(o));\n        };\n        return UnderlyingObservable;\n    }(ObservableBase);\n    var GroupedObservable = function(__super__) {\n        inherits(GroupedObservable, __super__);\n        function GroupedObservable(key, underlyingObservable, mergedDisposable) {\n            __super__.call(this);\n            this.key = key;\n            this.underlyingObservable = !mergedDisposable ? underlyingObservable : new UnderlyingObservable(mergedDisposable, underlyingObservable);\n        }\n        GroupedObservable.prototype._subscribe = function(o) {\n            return this.underlyingObservable.subscribe(o);\n        };\n        return GroupedObservable;\n    }(Observable);\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5jb2luY2lkZW5jZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsNktBQTZHOztBQUUzRyxVQUFVQSxPQUFPO0lBQ2pCLElBQUlDLGNBQWM7UUFDaEIsWUFBWTtRQUNaLFVBQVU7SUFDWjtJQUVBLFNBQVNDLFlBQVlDLEtBQUs7UUFDeEIsT0FBTyxTQUFVQSxNQUFNQyxNQUFNLEtBQUtBLFNBQVVELFFBQVE7SUFDdEQ7SUFFQSxJQUFJRSxjQUFjLFdBQVksQ0FBQyxPQUFPQyxRQUFRLElBQUlBLFdBQVcsQ0FBQ0EsUUFBUUMsUUFBUSxHQUFJRCxVQUFVO0lBQzVGLElBQUlFLGFBQWEsV0FBWSxDQUFDLFFBQWFDLENBQUMsSUFBSUEsVUFBVSxDQUFDQSxPQUFPRixRQUFRLEdBQUlFLFNBQVM7SUFDdkYsSUFBSUMsYUFBYVIsWUFBWUcsZUFBZUcsY0FBYyxPQUFPRyxXQUFXLFlBQVlBO0lBQ3hGLElBQUlDLFdBQVdWLFlBQVlELFdBQVcsQ0FBQyxPQUFPWSxLQUFLLElBQUlBO0lBQ3ZELElBQUlDLGFBQWFaLFlBQVlELFdBQVcsQ0FBQyxZQUFjLElBQUljO0lBQzNELElBQUlDLGdCQUFnQixjQUFlUixXQUFXRixPQUFPLEtBQUtELGNBQWVBLGNBQWM7SUFDdkYsSUFBSVksYUFBYWYsWUFBWUQsV0FBVyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksSUFBSTtJQUM3RCxJQUFJaUIsT0FBT1IsY0FBZSxlQUFpQk8sQ0FBQUEsY0FBY0EsV0FBV0YsTUFBTSxLQUFNRCxjQUFlRixZQUFZSyxjQUFjRSxTQUFTO0lBRWxJLDhCQUE4QjtJQUM5QixJQUFJLElBQTBDLEVBQUU7UUFDOUNDLGlDQUFPO1lBQUM7U0FBTyxtQ0FBRSxTQUFVRSxFQUFFLEVBQUVoQixRQUFPO1lBQ3BDLE9BQU9OLFFBQVFrQixNQUFNWixVQUFTZ0I7UUFDaEMsQ0FBQztBQUFBLGtHQUFDO0lBQ0osT0FBTyxFQUlOO0FBQ0gsR0FBRUUsSUFBSSxDQUFD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RSxDQUFDcEUsU0FBUyxDQUFDWDtRQUN6RTtRQUVBLE9BQU80RTtJQUNULEVBQUVwSTtJQUVGLElBQUlpSSxvQkFBcUIsU0FBVXhCLFNBQVM7UUFDMUN4RixTQUFTZ0gsbUJBQW1CeEI7UUFDNUIsU0FBU3dCLGtCQUFrQnpGLEdBQUcsRUFBRWlHLG9CQUFvQixFQUFFQyxnQkFBZ0I7WUFDcEVqQyxVQUFVN0csSUFBSSxDQUFDLElBQUk7WUFDbkIsSUFBSSxDQUFDNEMsR0FBRyxHQUFHQTtZQUNYLElBQUksQ0FBQ2lHLG9CQUFvQixHQUFHLENBQUNDLG1CQUMzQkQsdUJBQ0EsSUFBSUwscUJBQXFCTSxrQkFBa0JEO1FBQy9DO1FBRUFSLGtCQUFrQnZILFNBQVMsQ0FBQ2lJLFVBQVUsR0FBRyxTQUFVbkYsQ0FBQztZQUNsRCxPQUFPLElBQUksQ0FBQ2lGLG9CQUFvQixDQUFDdEUsU0FBUyxDQUFDWDtRQUM3QztRQUVBLE9BQU95RTtJQUNULEVBQUVsSTtJQUVGLE9BQU9MO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXJ2ZXItYWN0aW9uLy4vbm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguY29pbmNpZGVuY2UuanM/MjUwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCwgQWxsIHJpZ2h0cyByZXNlcnZlZC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0dsb2JhbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgdmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKSA/IGV4cG9ydHMgOiBudWxsO1xuICB2YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSkgPyBtb2R1bGUgOiBudWxsO1xuICB2YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcbiAgdmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuICB2YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG4gIHZhciBtb2R1bGVFeHBvcnRzID0gKGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykgPyBmcmVlRXhwb3J0cyA6IG51bGw7XG4gIHZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvLyBCZWNhdXNlIG9mIGJ1aWxkIG9wdGltaXplcnNcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJy4vcngnXSwgZnVuY3Rpb24gKFJ4LCBleHBvcnRzKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShyb290LCBleHBvcnRzLCBSeCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyb290LCBtb2R1bGUuZXhwb3J0cywgcmVxdWlyZSgnLi9yeCcpKTtcbiAgfSBlbHNlIHtcbiAgICByb290LlJ4ID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5SeCk7XG4gIH1cbn0uY2FsbCh0aGlzLCBmdW5jdGlvbiAocm9vdCwgZXhwLCBSeCwgdW5kZWZpbmVkKSB7XG5cbiAgdmFyIE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLFxuICAgIE9ic2VydmFibGVCYXNlID0gUnguT2JzZXJ2YWJsZUJhc2UsXG4gICAgQWJzdHJhY3RPYnNlcnZlciA9IFJ4LmludGVybmFscy5BYnN0cmFjdE9ic2VydmVyLFxuICAgIENvbXBvc2l0ZURpc3Bvc2FibGUgPSBSeC5Db21wb3NpdGVEaXNwb3NhYmxlLFxuICAgIEJpbmFyeURpc3Bvc2FibGUgPSBSeC5CaW5hcnlEaXNwb3NhYmxlLFxuICAgIFJlZkNvdW50RGlzcG9zYWJsZSA9IFJ4LlJlZkNvdW50RGlzcG9zYWJsZSxcbiAgICBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSA9IFJ4LlNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlLFxuICAgIFNlcmlhbERpc3Bvc2FibGUgPSBSeC5TZXJpYWxEaXNwb3NhYmxlLFxuICAgIFN1YmplY3QgPSBSeC5TdWJqZWN0LFxuICAgIG9ic2VydmFibGVQcm90byA9IE9ic2VydmFibGUucHJvdG90eXBlLFxuICAgIG9ic2VydmFibGVFbXB0eSA9IE9ic2VydmFibGUuZW1wdHksXG4gICAgb2JzZXJ2YWJsZU5ldmVyID0gT2JzZXJ2YWJsZS5uZXZlcixcbiAgICBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSxcbiAgICBhZGRSZWYgPSBSeC5pbnRlcm5hbHMuYWRkUmVmLFxuICAgIGluaGVyaXRzID0gUnguaW50ZXJuYWxzLmluaGVyaXRzLFxuICAgIGJpbmRDYWxsYmFjayA9IFJ4LmludGVybmFscy5iaW5kQ2FsbGJhY2ssXG4gICAgbm9vcCA9IFJ4LmhlbHBlcnMubm9vcCxcbiAgICBpc1Byb21pc2UgPSBSeC5oZWxwZXJzLmlzUHJvbWlzZSxcbiAgICBpc0Z1bmN0aW9uID0gUnguaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgIG9ic2VydmFibGVGcm9tUHJvbWlzZSA9IE9ic2VydmFibGUuZnJvbVByb21pc2U7XG5cbiAgdmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbiAgXG4gIGZ1bmN0aW9uIHRyeUNhdGNoZXJHZW4odHJ5Q2F0Y2hUYXJnZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgdHJ5Q2F0Y2ggPSBSeC5pbnRlcm5hbHMudHJ5Q2F0Y2ggPSBmdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignZm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7IH1cbiAgICByZXR1cm4gdHJ5Q2F0Y2hlckdlbihmbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIHZhciBNYXAgPSByb290Lk1hcCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB9XG5cbiAgICBNYXAucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICB0aGlzLl92YWx1ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fa2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLnNpemUtLTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICByZXR1cm4gaSA9PT0gLTEgPyB1bmRlZmluZWQgOiB0aGlzLl92YWx1ZXNbaV07XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IsIHRoaXNBcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCB0aGlzLl92YWx1ZXNbaV0sIHRoaXMuX2tleXNbaV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTWFwO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiAgQ29ycmVsYXRlcyB0aGUgZWxlbWVudHMgb2YgdHdvIHNlcXVlbmNlcyBiYXNlZCBvbiBvdmVybGFwcGluZyBkdXJhdGlvbnMuXG4gICAqXG4gICAqICBAcGFyYW0ge09ic2VydmFibGV9IHJpZ2h0IFRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGpvaW4gZWxlbWVudHMgZm9yLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gbGVmdER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSBsZWZ0IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzZWQgdG8gZGV0ZXJtaW5lIG92ZXJsYXAuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSByaWdodER1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIGR1cmF0aW9uIChleHByZXNzZWQgYXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSkgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSByaWdodCBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2VkIHRvIGRldGVybWluZSBvdmVybGFwLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgQSBmdW5jdGlvbiBpbnZva2VkIHRvIGNvbXB1dGUgYSByZXN1bHQgZWxlbWVudCBmb3IgYW55IHR3byBvdmVybGFwcGluZyBlbGVtZW50cyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuIFRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZCB3aXRoIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBzb3VyY2Ugc2VxdWVuY2VzIGZvciB3aGljaCBvdmVybGFwIG9jY3Vycy5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgcmVzdWx0IGVsZW1lbnRzIGNvbXB1dGVkIGZyb20gc291cmNlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhbiBvdmVybGFwcGluZyBkdXJhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5qb2luID0gZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0RHVyYXRpb25TZWxlY3RvciwgcmlnaHREdXJhdGlvblNlbGVjdG9yLCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHZhciBsZWZ0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICB2YXIgbGVmdERvbmUgPSBmYWxzZSwgcmlnaHREb25lID0gZmFsc2U7XG4gICAgICB2YXIgbGVmdElkID0gMCwgcmlnaHRJZCA9IDA7XG4gICAgICB2YXIgbGVmdE1hcCA9IG5ldyBNYXAoKSwgcmlnaHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH07XG5cbiAgICAgIGdyb3VwLmFkZChsZWZ0LnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGlkID0gbGVmdElkKyssIG1kID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgICAgICBsZWZ0TWFwLnNldChpZCwgdmFsdWUpO1xuICAgICAgICAgIGdyb3VwLmFkZChtZCk7XG5cbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChsZWZ0RHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTsgfVxuXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgbGVmdE1hcFsnZGVsZXRlJ10oaWQpICYmIGxlZnRNYXAuc2l6ZSA9PT0gMCAmJiBsZWZ0RG9uZSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICByaWdodE1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2gocmVzdWx0U2VsZWN0b3IpKHZhbHVlLCB2KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgICAgICBvLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxlZnREb25lID0gdHJ1ZTtcbiAgICAgICAgICAocmlnaHREb25lIHx8IGxlZnRNYXAuc2l6ZSA9PT0gMCkgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgZ3JvdXAuYWRkKHJpZ2h0LnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGlkID0gcmlnaHRJZCsrLCBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuXG4gICAgICAgICAgcmlnaHRNYXAuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1kKTtcblxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoKHJpZ2h0RHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihkdXJhdGlvbi5lKTsgfVxuXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmlnaHRNYXBbJ2RlbGV0ZSddKGlkKSAmJiByaWdodE1hcC5zaXplID09PSAwICYmIHJpZ2h0RG9uZSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShtZCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChyZXN1bHRTZWxlY3RvcikodiwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgICAgICAgIG8ub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmlnaHREb25lID0gdHJ1ZTtcbiAgICAgICAgICAobGVmdERvbmUgfHwgcmlnaHRNYXAuc2l6ZSA9PT0gMCkgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9LCBsZWZ0KTtcbiAgfTtcblxuICAvKipcbiAgICogIENvcnJlbGF0ZXMgdGhlIGVsZW1lbnRzIG9mIHR3byBzZXF1ZW5jZXMgYmFzZWQgb24gb3ZlcmxhcHBpbmcgZHVyYXRpb25zLCBhbmQgZ3JvdXBzIHRoZSByZXN1bHRzLlxuICAgKlxuICAgKiAgQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodCBUaGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBqb2luIGVsZW1lbnRzIGZvci5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IGxlZnREdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gc2VsZWN0IHRoZSBkdXJhdGlvbiAoZXhwcmVzc2VkIGFzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UpIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgbGVmdCBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2VkIHRvIGRldGVybWluZSBvdmVybGFwLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gcmlnaHREdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gc2VsZWN0IHRoZSBkdXJhdGlvbiAoZXhwcmVzc2VkIGFzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UpIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNlZCB0byBkZXRlcm1pbmUgb3ZlcmxhcC5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEEgZnVuY3Rpb24gaW52b2tlZCB0byBjb21wdXRlIGEgcmVzdWx0IGVsZW1lbnQgZm9yIGFueSBlbGVtZW50IG9mIHRoZSBsZWZ0IHNlcXVlbmNlIHdpdGggb3ZlcmxhcHBpbmcgZWxlbWVudHMgZnJvbSB0aGUgcmlnaHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVGhlIGZpcnN0IHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIGFuIGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VxdWVuY2UuIFRoZSBzZWNvbmQgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gaXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGVsZW1lbnRzIGZyb20gdGhlIHJpZ2h0IHNlcXVlbmNlIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSBsZWZ0IHNlcXVlbmNlJ3MgZWxlbWVudC5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgcmVzdWx0IGVsZW1lbnRzIGNvbXB1dGVkIGZyb20gc291cmNlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhbiBvdmVybGFwcGluZyBkdXJhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5ncm91cEpvaW4gPSBmdW5jdGlvbiAocmlnaHQsIGxlZnREdXJhdGlvblNlbGVjdG9yLCByaWdodER1cmF0aW9uU2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGdyb3VwID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIHZhciByID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cCk7XG4gICAgICB2YXIgbGVmdE1hcCA9IG5ldyBNYXAoKSwgcmlnaHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbGVmdElkID0gMCwgcmlnaHRJZCA9IDA7XG4gICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgdi5vbkVycm9yKGUpOyB9OyB9O1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlKSB7IH07XG5cbiAgICAgIGdyb3VwLmFkZChsZWZ0LnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgIHZhciBpZCA9IGxlZnRJZCsrO1xuICAgICAgICAgIGxlZnRNYXAuc2V0KGlkLCBzKTtcblxuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChyZXN1bHRTZWxlY3RvcikodmFsdWUsIGFkZFJlZihzLCByKSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihyZXN1bHQuZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihyZXN1bHQuZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG8ub25OZXh0KHJlc3VsdCk7XG5cbiAgICAgICAgICByaWdodE1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHMub25OZXh0KHYpOyB9KTtcblxuICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgIGdyb3VwLmFkZChtZCk7XG5cbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChsZWZ0RHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGxlZnRNYXAuZm9yRWFjaChoYW5kbGVFcnJvcihkdXJhdGlvbi5lKSk7XG4gICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1kLnNldERpc3Bvc2FibGUoZHVyYXRpb24udGFrZSgxKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBub29wLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgbGVmdE1hcFsnZGVsZXRlJ10oaWQpICYmIHMub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG1kKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyBvLm9uQ29tcGxldGVkKCk7IH0pXG4gICAgICApO1xuXG4gICAgICBncm91cC5hZGQocmlnaHQuc3Vic2NyaWJlKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaWQgPSByaWdodElkKys7XG4gICAgICAgICAgcmlnaHRNYXAuc2V0KGlkLCB2YWx1ZSk7XG5cbiAgICAgICAgICB2YXIgbWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICBncm91cC5hZGQobWQpO1xuXG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdHJ5Q2F0Y2gocmlnaHREdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGR1cmF0aW9uLmUpKTtcbiAgICAgICAgICAgIHJldHVybiBvLm9uRXJyb3IoZHVyYXRpb24uZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWQuc2V0RGlzcG9zYWJsZShkdXJhdGlvbi50YWtlKDEpLnN1YnNjcmliZShcbiAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBsZWZ0TWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByaWdodE1hcFsnZGVsZXRlJ10oaWQpO1xuICAgICAgICAgICAgICBncm91cC5yZW1vdmUobWQpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYub25OZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbGVmdE1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICBvLm9uRXJyb3IoZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBsZWZ0KTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0FycmF5KHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSBidWZmZXJzLlxuICAgKiAgQHBhcmFtIHtNaXhlZH0gYnVmZmVyT3BlbmluZ3NPckNsb3NpbmdTZWxlY3RvciBPYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGRlbm90ZSB0aGUgY3JlYXRpb24gb2YgbmV3IHdpbmRvd3MsIG9yLCBhIGZ1bmN0aW9uIGludm9rZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwcm9kdWNlZCB3aW5kb3dzIChhIG5ldyB3aW5kb3cgaXMgc3RhcnRlZCB3aGVuIHRoZSBwcmV2aW91cyBvbmUgaXMgY2xvc2VkLCByZXN1bHRpbmcgaW4gbm9uLW92ZXJsYXBwaW5nIHdpbmRvd3MpLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2J1ZmZlckNsb3NpbmdTZWxlY3Rvcl0gQSBmdW5jdGlvbiBpbnZva2VkIHRvIGRlZmluZSB0aGUgY2xvc2luZyBvZiBlYWNoIHByb2R1Y2VkIHdpbmRvdy4gSWYgYSBjbG9zaW5nIHNlbGVjdG9yIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlciwgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC5cbiAgICogIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHdpbmRvd3MuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndpbmRvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAuZmxhdE1hcCh0b0FycmF5KTtcbiAgfTtcblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gemVybyBvciBtb3JlIHdpbmRvd3MuXG4gICAqXG4gICAqICBAcGFyYW0ge01peGVkfSB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yIE9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgZGVub3RlIHRoZSBjcmVhdGlvbiBvZiBuZXcgd2luZG93cywgb3IsIGEgZnVuY3Rpb24gaW52b2tlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHByb2R1Y2VkIHdpbmRvd3MgKGEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWQsIHJlc3VsdGluZyBpbiBub24tb3ZlcmxhcHBpbmcgd2luZG93cykuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbd2luZG93Q2xvc2luZ1NlbGVjdG9yXSBBIGZ1bmN0aW9uIGludm9rZWQgdG8gZGVmaW5lIHRoZSBjbG9zaW5nIG9mIGVhY2ggcHJvZHVjZWQgd2luZG93LiBJZiBhIGNsb3Npbmcgc2VsZWN0b3IgZnVuY3Rpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyLCB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3cgPSBmdW5jdGlvbiAod2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3Rvciwgd2luZG93Q2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9ic2VydmFibGVXaW5kb3dXaXRoQm91bmRhcmllcy5jYWxsKHRoaXMsIHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvd09wZW5pbmdzT3JDbG9zaW5nU2VsZWN0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgb2JzZXJ2YWJsZVdpbmRvd1dpdGhDbG9zaW5nU2VsZWN0b3IuY2FsbCh0aGlzLCB3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yKSA6XG4gICAgICBvYnNlcnZhYmxlV2luZG93V2l0aE9wZW5pbmdzLmNhbGwodGhpcywgd2luZG93T3BlbmluZ3NPckNsb3NpbmdTZWxlY3Rvciwgd2luZG93Q2xvc2luZ1NlbGVjdG9yKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlV2luZG93V2l0aE9wZW5pbmdzKHdpbmRvd09wZW5pbmdzLCB3aW5kb3dDbG9zaW5nU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gd2luZG93T3BlbmluZ3MuZ3JvdXBKb2luKHRoaXMsIHdpbmRvd0Nsb3NpbmdTZWxlY3Rvciwgb2JzZXJ2YWJsZUVtcHR5LCBmdW5jdGlvbiAoXywgd2luKSB7XG4gICAgICByZXR1cm4gd2luO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVdpbmRvd1dpdGhCb3VuZGFyaWVzKHdpbmRvd0JvdW5kYXJpZXMpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgd2luID0gbmV3IFN1YmplY3QoKSxcbiAgICAgICAgZCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgIHIgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGQpO1xuXG4gICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHdpbiwgcikpO1xuXG4gICAgICBkLmFkZChzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHdpbi5vbk5leHQoeCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHdpbi5vbkVycm9yKGVycik7XG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGlzUHJvbWlzZSh3aW5kb3dCb3VuZGFyaWVzKSAmJiAod2luZG93Qm91bmRhcmllcyA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh3aW5kb3dCb3VuZGFyaWVzKSk7XG5cbiAgICAgIGQuYWRkKHdpbmRvd0JvdW5kYXJpZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB3aW4gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHdpbiwgcikpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB3aW4ub25FcnJvcihlcnIpO1xuICAgICAgICBvYnNlcnZlci5vbkVycm9yKGVycik7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBzb3VyY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVdpbmRvd1dpdGhDbG9zaW5nU2VsZWN0b3Iod2luZG93Q2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIG0gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUobSksXG4gICAgICAgIHIgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGQpLFxuICAgICAgICB3aW4gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZih3aW4sIHIpKTtcbiAgICAgIGQuYWRkKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB3aW4ub25OZXh0KHgpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHdpbi5vbkVycm9yKGVycik7XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdpbi5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvd0Nsb3NlICgpIHtcbiAgICAgICAgdmFyIHdpbmRvd0Nsb3NlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvd0Nsb3NlID0gd2luZG93Q2xvc2luZ1NlbGVjdG9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzUHJvbWlzZSh3aW5kb3dDbG9zZSkgJiYgKHdpbmRvd0Nsb3NlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHdpbmRvd0Nsb3NlKSk7XG5cbiAgICAgICAgdmFyIG0xID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIG0uc2V0RGlzcG9zYWJsZShtMSk7XG4gICAgICAgIG0xLnNldERpc3Bvc2FibGUod2luZG93Q2xvc2UudGFrZSgxKS5zdWJzY3JpYmUobm9vcCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHdpbi5vbkVycm9yKGVycik7XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlcnIpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2luLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgd2luID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHdpbiwgcikpO1xuICAgICAgICAgIGNyZWF0ZVdpbmRvd0Nsb3NlKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlV2luZG93Q2xvc2UoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICB2YXIgUGFpcndpc2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhQYWlyd2lzZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUGFpcndpc2VPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBQYWlyd2lzZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgUGFpcndpc2VPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYWlyd2lzZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgUGFpcndpc2VPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhQYWlyd2lzZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2hwID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBQYWlyd2lzZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9ocCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dChbdGhpcy5fcCwgeF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faHAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fcCA9IHg7XG4gICAgfTtcbiAgICBQYWlyd2lzZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgdGhpcy5fby5vbkVycm9yKGVycik7IH07XG4gICAgUGFpcndpc2VPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gUGFpcndpc2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgb2JzZXJ2YWJsZSB0aGF0IHRyaWdnZXJzIG9uIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnQgdHJpZ2dlcmluZ3Mgb2YgdGhlIGlucHV0IG9ic2VydmFibGUuXG4gICAqIFRoZSBOdGggdHJpZ2dlcmluZyBvZiB0aGUgaW5wdXQgb2JzZXJ2YWJsZSBwYXNzZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBOLTF0aCBhbmQgTnRoIHRyaWdnZXJpbmcgYXMgYSBwYWlyLlxuICAgKiBUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBOLTF0aCB0cmlnZ2VyaW5nIGlzIGhlbGQgaW4gaGlkZGVuIGludGVybmFsIHN0YXRlIHVudGlsIHRoZSBOdGggdHJpZ2dlcmluZyBvY2N1cnMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHRoYXQgdHJpZ2dlcnMgb24gc3VjY2Vzc2l2ZSBwYWlycyBvZiBvYnNlcnZhdGlvbnMgZnJvbSB0aGUgaW5wdXQgb2JzZXJ2YWJsZSBhcyBhbiBhcnJheS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5wYWlyd2lzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFBhaXJ3aXNlT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0d28gb2JzZXJ2YWJsZXMgd2hpY2ggcGFydGl0aW9uIHRoZSBvYnNlcnZhdGlvbnMgb2YgdGhlIHNvdXJjZSBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAqIFRoZSBmaXJzdCB3aWxsIHRyaWdnZXIgb2JzZXJ2YXRpb25zIGZvciB0aG9zZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgKiBUaGUgc2Vjb25kIHdpbGwgdHJpZ2dlciBvYnNlcnZhdGlvbnMgZm9yIHRob3NlIHZhbHVlcyB3aGVyZSB0aGUgcHJlZGljYXRlIHJldHVybnMgZmFsc2UuXG4gICAqIFRoZSBwcmVkaWNhdGUgaXMgZXhlY3V0ZWQgb25jZSBmb3IgZWFjaCBzdWJzY3JpYmVkIG9ic2VydmVyLlxuICAgKiBCb3RoIGFsc28gcHJvcGFnYXRlIGFsbCBlcnJvciBvYnNlcnZhdGlvbnMgYXJpc2luZyBmcm9tIHRoZSBzb3VyY2UgYW5kIGVhY2ggY29tcGxldGVzXG4gICAqIHdoZW4gdGhlIHNvdXJjZSBjb21wbGV0ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICAgKiAgICBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgdHJpZ2dlciBhIHBhcnRpY3VsYXIgb2JzZXJ2YXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogICAgQW4gYXJyYXkgb2Ygb2JzZXJ2YWJsZXMuIFRoZSBmaXJzdCB0cmlnZ2VycyB3aGVuIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLFxuICAgKiAgICBhbmQgdGhlIHNlY29uZCB0cmlnZ2VycyB3aGVuIHRoZSBwcmVkaWNhdGUgcmV0dXJucyBmYWxzZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLmZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpLFxuICAgICAgdGhpcy5maWx0ZXIoZnVuY3Rpb24gKHgsIGksIG8pIHsgcmV0dXJuICFmbih4LCBpLCBvKTsgfSlcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBrZXkgc2VsZWN0b3IgZnVuY3Rpb24gYW5kIGNvbXBhcmVyIGFuZCBzZWxlY3RzIHRoZSByZXN1bHRpbmcgZWxlbWVudHMgYnkgdXNpbmcgYSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gb2JzZXJ2YWJsZS5ncm91cEJ5KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcbiAgICogIDIgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9KTtcbiAgICogIDMgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5U2VsZWN0b3IgQSBmdW5jdGlvbiB0byBleHRyYWN0IHRoZSBrZXkgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2VsZW1lbnRTZWxlY3Rvcl0gIEEgZnVuY3Rpb24gdG8gbWFwIGVhY2ggc291cmNlIGVsZW1lbnQgdG8gYW4gZWxlbWVudCBpbiBhbiBvYnNlcnZhYmxlIGdyb3VwLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIGdyb3VwcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUsIGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIHRoYXQgc2hhcmUgdGhhdCBzYW1lIGtleSB2YWx1ZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5ncm91cEJ5ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cEJ5VW50aWwoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3Rvciwgb2JzZXJ2YWJsZU5ldmVyKTtcbiAgfTtcblxuICAgIC8qKlxuICAgICAqICBHcm91cHMgdGhlIGVsZW1lbnRzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYWNjb3JkaW5nIHRvIGEgc3BlY2lmaWVkIGtleSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICAgKiAgQSBkdXJhdGlvbiBzZWxlY3RvciBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIGxpZmV0aW1lIG9mIGdyb3Vwcy4gV2hlbiBhIGdyb3VwIGV4cGlyZXMsIGl0IHJlY2VpdmVzIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi4gV2hlbiBhIG5ldyBlbGVtZW50IHdpdGggdGhlIHNhbWVcbiAgICAgKiAga2V5IHZhbHVlIGFzIGEgcmVjbGFpbWVkIGdyb3VwIG9jY3VycywgdGhlIGdyb3VwIHdpbGwgYmUgcmVib3JuIHdpdGggYSBuZXcgbGlmZXRpbWUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHZhciByZXMgPSBvYnNlcnZhYmxlLmdyb3VwQnlVbnRpbChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSwgbnVsbCwgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ4Lk9ic2VydmFibGUubmV2ZXIoKTsgfSk7XG4gICAgICogIDIgLSBvYnNlcnZhYmxlLmdyb3VwQnkoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9LCAgZnVuY3Rpb24gKCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5uZXZlcigpOyB9KTtcbiAgICAgKiAgMyAtIG9ic2VydmFibGUuZ3JvdXBCeShmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSksIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0sICBmdW5jdGlvbiAoKSB7IHJldHVybiBSeC5PYnNlcnZhYmxlLm5ldmVyKCk7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH0pO1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdG8gZXh0cmFjdCB0aGUga2V5IGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRvIHNpZ25hbCB0aGUgZXhwaXJhdGlvbiBvZiBhIGdyb3VwLlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfVxuICAgICAqICBBIHNlcXVlbmNlIG9mIG9ic2VydmFibGUgZ3JvdXBzLCBlYWNoIG9mIHdoaWNoIGNvcnJlc3BvbmRzIHRvIGEgdW5pcXVlIGtleSB2YWx1ZSwgY29udGFpbmluZyBhbGwgZWxlbWVudHMgdGhhdCBzaGFyZSB0aGF0IHNhbWUga2V5IHZhbHVlLlxuICAgICAqICBJZiBhIGdyb3VwJ3MgbGlmZXRpbWUgZXhwaXJlcywgYSBuZXcgZ3JvdXAgd2l0aCB0aGUgc2FtZSBrZXkgdmFsdWUgY2FuIGJlIGNyZWF0ZWQgb25jZSBhbiBlbGVtZW50IHdpdGggc3VjaCBhIGtleSB2YWx1ZSBpcyBlbmNvdXRlcmVkLlxuICAgICAqXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLmdyb3VwQnlVbnRpbCA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcCgpLFxuICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgICAgcmVmQ291bnREaXNwb3NhYmxlID0gbmV3IFJlZkNvdW50RGlzcG9zYWJsZShncm91cERpc3Bvc2FibGUpLFxuICAgICAgICAgIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0ub25FcnJvcihlKTsgfTsgfTtcblxuICAgICAgICBncm91cERpc3Bvc2FibGUuYWRkKFxuICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0cnlDYXRjaChrZXlTZWxlY3RvcikoeCk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICBtYXAuZm9yRWFjaChoYW5kbGVFcnJvcihrZXkuZSkpO1xuICAgICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKGtleS5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpcmVOZXdNYXBFbnRyeSA9IGZhbHNlLCB3cml0ZXIgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAod3JpdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgd3JpdGVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICAgICAgbWFwLnNldChrZXksIHdyaXRlcik7XG4gICAgICAgICAgICAgIGZpcmVOZXdNYXBFbnRyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJlTmV3TWFwRW50cnkpIHtcbiAgICAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgd3JpdGVyLCByZWZDb3VudERpc3Bvc2FibGUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uR3JvdXAgPSBuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCB3cml0ZXIpO1xuICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaChkdXJhdGlvblNlbGVjdG9yKShkdXJhdGlvbkdyb3VwKTtcbiAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGR1cmF0aW9uLmUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5vbkVycm9yKGR1cmF0aW9uLmUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgby5vbk5leHQoZ3JvdXApO1xuXG4gICAgICAgICAgICAgIHZhciBtZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgICAgICBncm91cERpc3Bvc2FibGUuYWRkKG1kKTtcblxuICAgICAgICAgICAgICBtZC5zZXREaXNwb3NhYmxlKGR1cmF0aW9uLnRha2UoMSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIG1hcC5mb3JFYWNoKGhhbmRsZUVycm9yKGUpKTtcbiAgICAgICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXBbJ2RlbGV0ZSddKGtleSkpIHsgd3JpdGVyLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICAgICAgICAgICAgIGdyb3VwRGlzcG9zYWJsZS5yZW1vdmUobWQpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB4O1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZWxlbWVudFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gdHJ5Q2F0Y2goZWxlbWVudFNlbGVjdG9yKSh4KTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgbWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZWxlbWVudC5lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8ub25FcnJvcihlbGVtZW50LmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyaXRlci5vbk5leHQoZWxlbWVudCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbWFwLmZvckVhY2goaGFuZGxlRXJyb3IoZSkpO1xuICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0ub25Db21wbGV0ZWQoKTsgfSk7XG4gICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KSk7XG5cbiAgICAgIHJldHVybiByZWZDb3VudERpc3Bvc2FibGU7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgVW5kZXJseWluZ09ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFVuZGVybHlpbmdPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFVuZGVybHlpbmdPYnNlcnZhYmxlKG0sIHUpIHtcbiAgICAgIHRoaXMuX20gPSBtO1xuICAgICAgdGhpcy5fdSA9IHU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBVbmRlcmx5aW5nT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUodGhpcy5fbS5nZXREaXNwb3NhYmxlKCksIHRoaXMuX3Uuc3Vic2NyaWJlKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFVuZGVybHlpbmdPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEdyb3VwZWRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhHcm91cGVkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBHcm91cGVkT2JzZXJ2YWJsZShrZXksIHVuZGVybHlpbmdPYnNlcnZhYmxlLCBtZXJnZWREaXNwb3NhYmxlKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdGhpcy51bmRlcmx5aW5nT2JzZXJ2YWJsZSA9ICFtZXJnZWREaXNwb3NhYmxlID9cbiAgICAgICAgdW5kZXJseWluZ09ic2VydmFibGUgOlxuICAgICAgICBuZXcgVW5kZXJseWluZ09ic2VydmFibGUobWVyZ2VkRGlzcG9zYWJsZSwgdW5kZXJseWluZ09ic2VydmFibGUpO1xuICAgIH1cblxuICAgIEdyb3VwZWRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZGVybHlpbmdPYnNlcnZhYmxlLnN1YnNjcmliZShvKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdyb3VwZWRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGUpKTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiT2JzZXJ2YWJsZSIsIk9ic2VydmFibGVCYXNlIiwiQWJzdHJhY3RPYnNlcnZlciIsImludGVybmFscyIsIkNvbXBvc2l0ZURpc3Bvc2FibGUiLCJCaW5hcnlEaXNwb3NhYmxlIiwiUmVmQ291bnREaXNwb3NhYmxlIiwiU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUiLCJTZXJpYWxEaXNwb3NhYmxlIiwiU3ViamVjdCIsIm9ic2VydmFibGVQcm90byIsInByb3RvdHlwZSIsIm9ic2VydmFibGVFbXB0eSIsImVtcHR5Iiwib2JzZXJ2YWJsZU5ldmVyIiwibmV2ZXIiLCJBbm9ueW1vdXNPYnNlcnZhYmxlIiwiYWRkUmVmIiwiaW5oZXJpdHMiLCJiaW5kQ2FsbGJhY2siLCJub29wIiwiaGVscGVycyIsImlzUHJvbWlzZSIsImlzRnVuY3Rpb24iLCJvYnNlcnZhYmxlRnJvbVByb21pc2UiLCJmcm9tUHJvbWlzZSIsImVycm9yT2JqIiwiZSIsInRyeUNhdGNoZXJHZW4iLCJ0cnlDYXRjaFRhcmdldCIsInRyeUNhdGNoZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyeUNhdGNoIiwiZm4iLCJUeXBlRXJyb3IiLCJ0aHJvd2VyIiwiTWFwIiwic2l6ZSIsIl92YWx1ZXMiLCJfa2V5cyIsImtleSIsImkiLCJpbmRleE9mIiwic3BsaWNlIiwiZ2V0Iiwic2V0IiwicHVzaCIsImZvckVhY2giLCJjYiIsInRoaXNBcmciLCJqb2luIiwicmlnaHQiLCJsZWZ0RHVyYXRpb25TZWxlY3RvciIsInJpZ2h0RHVyYXRpb25TZWxlY3RvciIsInJlc3VsdFNlbGVjdG9yIiwibGVmdCIsIm8iLCJncm91cCIsImxlZnREb25lIiwicmlnaHREb25lIiwibGVmdElkIiwicmlnaHRJZCIsImxlZnRNYXAiLCJyaWdodE1hcCIsImhhbmRsZUVycm9yIiwib25FcnJvciIsImFkZCIsInN1YnNjcmliZSIsImlkIiwibWQiLCJkdXJhdGlvbiIsInNldERpc3Bvc2FibGUiLCJ0YWtlIiwib25Db21wbGV0ZWQiLCJyZW1vdmUiLCJ2IiwicmVzdWx0Iiwib25OZXh0IiwiZ3JvdXBKb2luIiwiciIsInMiLCJ0b0FycmF5IiwieCIsImJ1ZmZlciIsImZsYXRNYXAiLCJ3aW5kb3dPcGVuaW5nc09yQ2xvc2luZ1NlbGVjdG9yIiwid2luZG93Q2xvc2luZ1NlbGVjdG9yIiwibGVuZ3RoIiwib2JzZXJ2YWJsZVdpbmRvd1dpdGhCb3VuZGFyaWVzIiwib2JzZXJ2YWJsZVdpbmRvd1dpdGhDbG9zaW5nU2VsZWN0b3IiLCJvYnNlcnZhYmxlV2luZG93V2l0aE9wZW5pbmdzIiwid2luZG93T3BlbmluZ3MiLCJfIiwid2luIiwid2luZG93Qm91bmRhcmllcyIsInNvdXJjZSIsIm9ic2VydmVyIiwiZCIsImVyciIsInciLCJtIiwiY3JlYXRlV2luZG93Q2xvc2UiLCJ3aW5kb3dDbG9zZSIsIm0xIiwiUGFpcndpc2VPYnNlcnZhYmxlIiwiX19zdXBlcl9fIiwic3Vic2NyaWJlQ29yZSIsIlBhaXJ3aXNlT2JzZXJ2ZXIiLCJfbyIsIl9wIiwiX2hwIiwibmV4dCIsImVycm9yIiwiY29tcGxldGVkIiwicGFpcndpc2UiLCJwYXJ0aXRpb24iLCJwcmVkaWNhdGUiLCJmaWx0ZXIiLCJncm91cEJ5Iiwia2V5U2VsZWN0b3IiLCJlbGVtZW50U2VsZWN0b3IiLCJncm91cEJ5VW50aWwiLCJkdXJhdGlvblNlbGVjdG9yIiwibWFwIiwiZ3JvdXBEaXNwb3NhYmxlIiwicmVmQ291bnREaXNwb3NhYmxlIiwiaXRlbSIsImZpcmVOZXdNYXBFbnRyeSIsIndyaXRlciIsIkdyb3VwZWRPYnNlcnZhYmxlIiwiZHVyYXRpb25Hcm91cCIsImVsZW1lbnQiLCJVbmRlcmx5aW5nT2JzZXJ2YWJsZSIsInUiLCJfbSIsIl91IiwiZ2V0RGlzcG9zYWJsZSIsInVuZGVybHlpbmdPYnNlcnZhYmxlIiwibWVyZ2VkRGlzcG9zYWJsZSIsIl9zdWJzY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.coincidence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.experimental.js":
/*!*************************************************!*\
  !*** ./node_modules/rx/dist/rx.experimental.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // Aliases\n    var Observable = Rx.Observable, observableProto = Observable.prototype, ObservableBase = Rx.ObservableBase, AbstractObserver = Rx.internals.AbstractObserver, FlatMapObservable = Rx.FlatMapObservable, observableConcat = Observable.concat, observableDefer = Observable.defer, observableEmpty = Observable.empty, disposableEmpty = Rx.Disposable.empty, CompositeDisposable = Rx.CompositeDisposable, SerialDisposable = Rx.SerialDisposable, SingleAssignmentDisposable = Rx.SingleAssignmentDisposable, Enumerable = Rx.internals.Enumerable, enumerableOf = Enumerable.of, currentThreadScheduler = Rx.Scheduler.currentThread, AsyncSubject = Rx.AsyncSubject, Observer = Rx.Observer, inherits = Rx.internals.inherits, addProperties = Rx.internals.addProperties, helpers = Rx.helpers, noop = helpers.noop, isPromise = helpers.isPromise, isFunction = helpers.isFunction, isIterable = Rx.helpers.isIterable, isArrayLike = Rx.helpers.isArrayLike, isScheduler = Rx.Scheduler.isScheduler, observableFromPromise = Observable.fromPromise;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    // Shim in iterator support\n    var $iterator$ = typeof Symbol === \"function\" && Symbol.iterator || \"_es6shim_iterator_\";\n    // Bug for mozilla version\n    if (root.Set && typeof new root.Set()[\"@@iterator\"] === \"function\") {\n        $iterator$ = \"@@iterator\";\n    }\n    var doneEnumerator = Rx.doneEnumerator = {\n        done: true,\n        value: undefined\n    };\n    var isIterable = Rx.helpers.isIterable = function(o) {\n        return o && o[$iterator$] !== undefined;\n    };\n    var isArrayLike = Rx.helpers.isArrayLike = function(o) {\n        return o && o.length !== undefined;\n    };\n    Rx.helpers.iterator = $iterator$;\n    var WhileEnumerable = function(__super__) {\n        inherits(WhileEnumerable, __super__);\n        function WhileEnumerable(c, s) {\n            this.c = c;\n            this.s = s;\n        }\n        WhileEnumerable.prototype[$iterator$] = function() {\n            var self1 = this;\n            return {\n                next: function() {\n                    return self1.c() ? {\n                        done: false,\n                        value: self1.s\n                    } : {\n                        done: true,\n                        value: void 0\n                    };\n                }\n            };\n        };\n        return WhileEnumerable;\n    }(Enumerable);\n    function enumerableWhile(condition, source) {\n        return new WhileEnumerable(condition, source);\n    }\n    /**\n   *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.\n   *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.\n   *\n   * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */ observableProto.letBind = observableProto[\"let\"] = function(func) {\n        return func(this);\n    };\n    /**\n   *  Determines whether an observable collection contains values. \n   *\n   * @example\n   *  1 - res = Rx.Observable.if(condition, obs1);\n   *  2 - res = Rx.Observable.if(condition, obs1, obs2);\n   *  3 - res = Rx.Observable.if(condition, obs1, scheduler);\n   * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.\n   * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.\n   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.\n   * @returns {Observable} An observable sequence which is either the thenSource or elseSource.\n   */ Observable[\"if\"] = function(condition, thenSource, elseSourceOrScheduler) {\n        return observableDefer(function() {\n            elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());\n            isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));\n            isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));\n            // Assume a scheduler for empty only\n            typeof elseSourceOrScheduler.now === \"function\" && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));\n            return condition() ? thenSource : elseSourceOrScheduler;\n        });\n    };\n    /**\n   *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.\n   * There is an alias for this method called 'forIn' for browsers <IE9\n   * @param {Array} sources An array of values to turn into an observable sequence.\n   * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.\n   * @returns {Observable} An observable sequence from the concatenated observable sequences.\n   */ Observable[\"for\"] = Observable.forIn = function(sources, resultSelector, thisArg) {\n        return enumerableOf(sources, resultSelector, thisArg).concat();\n    };\n    /**\n   *  Repeats source as long as condition holds emulating a while loop.\n   * There is an alias for this method called 'whileDo' for browsers <IE9\n   *\n   * @param {Function} condition The condition which determines if the source will be repeated.\n   * @param {Observable} source The observable sequence that will be run if the condition function returns true.\n   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.\n   */ var observableWhileDo = Observable[\"while\"] = Observable.whileDo = function(condition, source) {\n        isPromise(source) && (source = observableFromPromise(source));\n        return enumerableWhile(condition, source).concat();\n    };\n    /**\n   *  Repeats source as long as condition holds emulating a do while loop.\n   *\n   * @param {Function} condition The condition which determines if the source will be repeated.\n   * @param {Observable} source The observable sequence that will be run if the condition function returns true.\n   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.\n   */ observableProto.doWhile = function(condition) {\n        return observableConcat([\n            this,\n            observableWhileDo(condition, this)\n        ]);\n    };\n    /**\n   *  Uses selector to determine which source in sources to use.\n   * @param {Function} selector The function which extracts the value for to test in a case statement.\n   * @param {Array} sources A object which has keys which correspond to the case statement labels.\n   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.\n   *\n   * @returns {Observable} An observable sequence which is determined by a case statement.\n   */ Observable[\"case\"] = function(selector, sources, defaultSourceOrScheduler) {\n        return observableDefer(function() {\n            isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));\n            defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());\n            isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));\n            var result = sources[selector()];\n            isPromise(result) && (result = observableFromPromise(result));\n            return result || defaultSourceOrScheduler;\n        });\n    };\n    var ExpandObservable = function(__super__) {\n        inherits(ExpandObservable, __super__);\n        function ExpandObservable(source, fn, scheduler) {\n            this.source = source;\n            this._fn = fn;\n            this._scheduler = scheduler;\n            __super__.call(this);\n        }\n        function scheduleRecursive(args, recurse) {\n            var state = args[0], self1 = args[1];\n            var work;\n            if (state.q.length > 0) {\n                work = state.q.shift();\n            } else {\n                state.isAcquired = false;\n                return;\n            }\n            var m1 = new SingleAssignmentDisposable();\n            state.d.add(m1);\n            m1.setDisposable(work.subscribe(new ExpandObserver(state, self1, m1)));\n            recurse([\n                state,\n                self1\n            ]);\n        }\n        ExpandObservable.prototype._ensureActive = function(state) {\n            var isOwner = false;\n            if (state.q.length > 0) {\n                isOwner = !state.isAcquired;\n                state.isAcquired = true;\n            }\n            isOwner && state.m.setDisposable(this._scheduler.scheduleRecursive([\n                state,\n                this\n            ], scheduleRecursive));\n        };\n        ExpandObservable.prototype.subscribeCore = function(o) {\n            var m = new SerialDisposable(), d = new CompositeDisposable(m), state = {\n                q: [],\n                m: m,\n                d: d,\n                activeCount: 0,\n                isAcquired: false,\n                o: o\n            };\n            state.q.push(this.source);\n            state.activeCount++;\n            this._ensureActive(state);\n            return d;\n        };\n        return ExpandObservable;\n    }(ObservableBase);\n    var ExpandObserver = function(__super__) {\n        inherits(ExpandObserver, __super__);\n        function ExpandObserver(state, parent, m1) {\n            this._s = state;\n            this._p = parent;\n            this._m1 = m1;\n            __super__.call(this);\n        }\n        ExpandObserver.prototype.next = function(x) {\n            this._s.o.onNext(x);\n            var result = tryCatch(this._p._fn)(x);\n            if (result === errorObj) {\n                return this._s.o.onError(result.e);\n            }\n            this._s.q.push(result);\n            this._s.activeCount++;\n            this._p._ensureActive(this._s);\n        };\n        ExpandObserver.prototype.error = function(e) {\n            this._s.o.onError(e);\n        };\n        ExpandObserver.prototype.completed = function() {\n            this._s.d.remove(this._m1);\n            this._s.activeCount--;\n            this._s.activeCount === 0 && this._s.o.onCompleted();\n        };\n        return ExpandObserver;\n    }(AbstractObserver);\n    /**\n   *  Expands an observable sequence by recursively invoking selector.\n   *\n   * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.\n   * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.\n   * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.\n   */ observableProto.expand = function(selector, scheduler) {\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new ExpandObservable(this, selector, scheduler);\n    };\n    function argumentsToArray() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        return args;\n    }\n    var ForkJoinObservable = function(__super__) {\n        inherits(ForkJoinObservable, __super__);\n        function ForkJoinObservable(sources, cb) {\n            this._sources = sources;\n            this._cb = cb;\n            __super__.call(this);\n        }\n        ForkJoinObservable.prototype.subscribeCore = function(o) {\n            if (this._sources.length === 0) {\n                o.onCompleted();\n                return disposableEmpty;\n            }\n            var count = this._sources.length;\n            var state = {\n                finished: false,\n                hasResults: new Array(count),\n                hasCompleted: new Array(count),\n                results: new Array(count)\n            };\n            var subscriptions = new CompositeDisposable();\n            for(var i = 0, len = this._sources.length; i < len; i++){\n                var source = this._sources[i];\n                isPromise(source) && (source = observableFromPromise(source));\n                subscriptions.add(source.subscribe(new ForkJoinObserver(o, state, i, this._cb, subscriptions)));\n            }\n            return subscriptions;\n        };\n        return ForkJoinObservable;\n    }(ObservableBase);\n    var ForkJoinObserver = function(__super__) {\n        inherits(ForkJoinObserver, __super__);\n        function ForkJoinObserver(o, s, i, cb, subs) {\n            this._o = o;\n            this._s = s;\n            this._i = i;\n            this._cb = cb;\n            this._subs = subs;\n            __super__.call(this);\n        }\n        ForkJoinObserver.prototype.next = function(x) {\n            if (!this._s.finished) {\n                this._s.hasResults[this._i] = true;\n                this._s.results[this._i] = x;\n            }\n        };\n        ForkJoinObserver.prototype.error = function(e) {\n            this._s.finished = true;\n            this._o.onError(e);\n            this._subs.dispose();\n        };\n        ForkJoinObserver.prototype.completed = function() {\n            if (!this._s.finished) {\n                if (!this._s.hasResults[this._i]) {\n                    return this._o.onCompleted();\n                }\n                this._s.hasCompleted[this._i] = true;\n                for(var i = 0; i < this._s.results.length; i++){\n                    if (!this._s.hasCompleted[i]) {\n                        return;\n                    }\n                }\n                this._s.finished = true;\n                var res = tryCatch(this._cb).apply(null, this._s.results);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                this._o.onNext(res);\n                this._o.onCompleted();\n            }\n        };\n        return ForkJoinObserver;\n    }(AbstractObserver);\n    /**\n   *  Runs all observable sequences in parallel and collect their last elements.\n   *\n   * @example\n   *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);\n   *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);\n   * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.\n   */ Observable.forkJoin = function() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n        Array.isArray(args[0]) && (args = args[0]);\n        return new ForkJoinObservable(args, resultSelector);\n    };\n    /**\n   *  Runs two observable sequences in parallel and combines their last elemenets.\n   * @param {Observable} second Second observable sequence.\n   * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.\n   * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.\n   */ observableProto.forkJoin = function() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        if (Array.isArray(args[0])) {\n            args[0].unshift(this);\n        } else {\n            args.unshift(this);\n        }\n        return Observable.forkJoin.apply(null, args);\n    };\n    /**\n   * Comonadic bind operator.\n   * @param {Function} selector A transform function to apply to each element.\n   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.\n   * @returns {Observable} An observable sequence which results from the comonadic bind operation.\n   */ observableProto.manySelect = observableProto.extend = function(selector, scheduler) {\n        isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);\n        var source = this;\n        return observableDefer(function() {\n            var chain;\n            return source.map(function(x) {\n                var curr = new ChainObservable(x);\n                chain && chain.onNext(x);\n                chain = curr;\n                return curr;\n            }).tap(noop, function(e) {\n                chain && chain.onError(e);\n            }, function() {\n                chain && chain.onCompleted();\n            }).observeOn(scheduler).map(selector);\n        }, source);\n    };\n    var ChainObservable = function(__super__) {\n        inherits(ChainObservable, __super__);\n        function ChainObservable(head) {\n            __super__.call(this);\n            this.head = head;\n            this.tail = new AsyncSubject();\n        }\n        addProperties(ChainObservable.prototype, Observer, {\n            _subscribe: function(o) {\n                var g = new CompositeDisposable();\n                g.add(currentThreadScheduler.schedule(this, function(_, self1) {\n                    o.onNext(self1.head);\n                    g.add(self1.tail.mergeAll().subscribe(o));\n                }));\n                return g;\n            },\n            onCompleted: function() {\n                this.onNext(Observable.empty());\n            },\n            onError: function(e) {\n                this.onNext(Observable[\"throw\"](e));\n            },\n            onNext: function(v) {\n                this.tail.onNext(v);\n                this.tail.onCompleted();\n            }\n        });\n        return ChainObservable;\n    }(Observable);\n    var SwitchFirstObservable = function(__super__) {\n        inherits(SwitchFirstObservable, __super__);\n        function SwitchFirstObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        SwitchFirstObservable.prototype.subscribeCore = function(o) {\n            var m = new SingleAssignmentDisposable(), g = new CompositeDisposable(), state = {\n                hasCurrent: false,\n                isStopped: false,\n                o: o,\n                g: g\n            };\n            g.add(m);\n            m.setDisposable(this.source.subscribe(new SwitchFirstObserver(state)));\n            return g;\n        };\n        return SwitchFirstObservable;\n    }(ObservableBase);\n    var SwitchFirstObserver = function(__super__) {\n        inherits(SwitchFirstObserver, __super__);\n        function SwitchFirstObserver(state) {\n            this._s = state;\n            __super__.call(this);\n        }\n        SwitchFirstObserver.prototype.next = function(x) {\n            if (!this._s.hasCurrent) {\n                this._s.hasCurrent = true;\n                isPromise(x) && (x = observableFromPromise(x));\n                var inner = new SingleAssignmentDisposable();\n                this._s.g.add(inner);\n                inner.setDisposable(x.subscribe(new InnerObserver(this._s, inner)));\n            }\n        };\n        SwitchFirstObserver.prototype.error = function(e) {\n            this._s.o.onError(e);\n        };\n        SwitchFirstObserver.prototype.completed = function() {\n            this._s.isStopped = true;\n            !this._s.hasCurrent && this._s.g.length === 1 && this._s.o.onCompleted();\n        };\n        inherits(InnerObserver, __super__);\n        function InnerObserver(state, inner) {\n            this._s = state;\n            this._i = inner;\n            __super__.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            this._s.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this._s.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this._s.g.remove(this._i);\n            this._s.hasCurrent = false;\n            this._s.isStopped && this._s.g.length === 1 && this._s.o.onCompleted();\n        };\n        return SwitchFirstObserver;\n    }(AbstractObserver);\n    /**\n   * Performs a exclusive waiting for the first to finish before subscribing to another observable.\n   * Observables that come in between subscriptions will be dropped on the floor.\n   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.\n   */ observableProto.switchFirst = function() {\n        return new SwitchFirstObservable(this);\n    };\n    observableProto.flatMapFirst = observableProto.exhaustMap = function(selector, resultSelector, thisArg) {\n        return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();\n    };\n    observableProto.flatMapWithMaxConcurrent = observableProto.flatMapMaxConcurrent = function(limit, selector, resultSelector, thisArg) {\n        return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5leHBlcmltZW50YWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLDZLQUE2Rzs7QUFFM0csVUFBVUEsT0FBTztJQUNqQixJQUFJQyxjQUFjO1FBQ2hCLFlBQVk7UUFDWixVQUFVO0lBQ1o7SUFFQSxTQUFTQyxZQUFZQyxLQUFLO1FBQ3hCLE9BQU8sU0FBVUEsTUFBTUMsTUFBTSxLQUFLQSxTQUFVRCxRQUFRO0lBQ3REO0lBRUEsSUFBSUUsY0FBYyxXQUFZLENBQUMsT0FBT0MsUUFBUSxJQUFJQSxXQUFXLENBQUNBLFFBQVFDLFFBQVEsR0FBSUQsVUFBVTtJQUM1RixJQUFJRSxhQUFhLFdBQVksQ0FBQyxRQUFhQyxDQUFDLElBQUlBLFVBQVUsQ0FBQ0EsT0FBT0YsUUFBUSxHQUFJRSxTQUFTO0lBQ3ZGLElBQUlDLGFBQWFSLFlBQVlHLGVBQWVHLGNBQWMsT0FBT0csV0FBVyxZQUFZQTtJQUN4RixJQUFJQyxXQUFXVixZQUFZRCxXQUFXLENBQUMsT0FBT1ksS0FBSyxJQUFJQTtJQUN2RCxJQUFJQyxhQUFhWixZQUFZRCxXQUFXLENBQUMsWUFBYyxJQUFJYztJQUMzRCxJQUFJQyxnQkFBZ0IsY0FBZVIsV0FBV0YsT0FBTyxLQUFLRCxjQUFlQSxjQUFjO0lBQ3ZGLElBQUlZLGFBQWFmLFlBQVlELFdBQVcsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLElBQUk7SUFDN0QsSUFBSWlCLE9BQU9SLGNBQWUsZUFBaUJPLENBQUFBLGNBQWNBLFdBQVdGLE1BQU0sS0FBTUQsY0FBZUYsWUFBWUssY0FBY0UsU0FBUztJQUVsSSw4QkFBOEI7SUFDOUIsSUFBSSxJQUEwQyxFQUFFO1FBQzlDQyxpQ0FBTztZQUFDO1NBQU8sbUNBQUUsU0FBVUUsRUFBRSxFQUFFaEIsUUFBTztZQUNwQyxPQUFPTixRQUFRa0IsTUFBTVosVUFBU2dCO1FBQ2hDLENBQUM7QUFBQSxrR0FBQztJQUNKLE9BQU8sRUFJTjtBQUNILEdBQUVFLElBQUksQ0FBQyxRQUFNLFNBQVVOLElBQUksRUFBRU8sR0FBRyxFQUFFSCxFQUFFLEVBQUVJLFNBQVM7SUFFN0MsVUFBVTtJQUNWLElBQUlDLGFBQWFMLEdBQUdLLFVBQVUsRUFDNUJDLGtCQUFrQkQsV0FBV0UsU0FBUyxFQUN0Q0MsaUJBQWlCUixHQUFHUSxjQUFjLEVBQ2xDQyxtQkFBbUJULEdBQUdVLFNBQVMsQ0FBQ0QsZ0JBQWdCLEVBQ2hERSxvQkFBb0JYLEdBQUdXLGlCQUFpQixFQUN4Q0MsbUJBQW1CUCxXQUFXUSxNQUFNLEVBQ3BDQyxrQkFBa0JULFdBQVdVLEtBQUssRUFDbENDLGtCQUFrQlgsV0FBV1ksS0FBSyxFQUNsQ0Msa0JBQWtCbEIsR0FBR21CLFVBQVUsQ0FBQ0YsS0FBSyxFQUNyQ0csc0JBQXNCcEIsR0FBR29CLG1CQUFtQixFQUM1Q0MsbUJBQW1CckIsR0FBR3FCLGdCQUFnQixFQUN0Q0MsNkJBQTZCdEIsR0FBR3NCLDBCQUEwQixFQUMxREMsYUFBYXZCLEdBQUdVLFNBQVMsQ0FBQ2EsVUFBVSxFQUNwQ0MsZUFBZUQsV0FBV0UsRUFBRSxFQUM1QkMseUJBQXlCMUIsR0FBRzJCLFNBQVMsQ0FBQ0MsYUFBYSxFQUNuREMsZUFBZTdCLEdBQUc2QixZQUFZLEVBQzlCQyxXQUFXOUIsR0FBRzhCLFFBQVEsRUFDdEJDLFdBQVcvQixHQUFHVSxTQUFTLENBQUNxQixRQUFRLEVBQ2hDQyxnQkFBZ0JoQyxHQUFHVSxTQUFTLENBQUNzQixhQUFhLEVBQzFDQyxVQUFVakMsR0FBR2lDLE9BQU8sRUFDcEJDLE9BQU9ELFFBQVFDLElBQUksRUFDbkJDLFlBQVlGLFFBQVFFLFNBQVMsRUFDN0JDLGFBQWFILFFBQVFHLFVBQVUsRUFDL0JDLGFBQWFyQyxHQUFHaUMsT0FBTyxDQUFDSSxVQUFVLEVBQ2xDQyxjQUFjdEMsR0FBR2lDLE9BQU8sQ0FBQ0ssV0FBVyxFQUNwQ0MsY0FBY3ZDLEdBQUcyQixTQUFTLENBQUNZLFdBQVcsRUFDdENDLHdCQUF3Qm5DLFdBQVdvQyxXQUFXO0lBRWhELElBQUlDLFdBQVc7UUFBQ0MsR0FBRyxDQUFDO0lBQUM7SUFFckIsU0FBU0MsY0FBY0MsY0FBYztRQUNuQyxPQUFPLFNBQVNDO1lBQ2QsSUFBSTtnQkFDRixPQUFPRCxlQUFlRSxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUNwQyxFQUFFLE9BQU9MLEdBQUc7Z0JBQ1ZELFNBQVNDLENBQUMsR0FBR0E7Z0JBQ2IsT0FBT0Q7WUFDVDtRQUNGO0lBQ0Y7SUFFQSxJQUFJTyxXQUFXakQsR0FBR1UsU0FBUyxDQUFDdUMsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLEVBQUU7UUFDekQsSUFBSSxDQUFDZCxXQUFXYyxLQUFLO1lBQUUsTUFBTSxJQUFJQyxVQUFVO1FBQTBCO1FBQ3JFLE9BQU9QLGNBQWNNO0lBQ3ZCO0lBRUEsU0FBU0UsUUFBUVQsQ0FBQztRQUNoQixNQUFNQTtJQUNSO0lBRUEsMkJBQTJCO0lBQzNCLElBQUlVLGFBQWEsT0FBUUMsV0FBVyxjQUFjQSxPQUFPQyxRQUFRLElBQy9EO0lBQ0YsMEJBQTBCO0lBQzFCLElBQUkzRCxLQUFLNEQsR0FBRyxJQUFJLE9BQU8sSUFBSTVELEtBQUs0RCxHQUFHLEVBQUUsQ0FBQyxhQUFhLEtBQUssWUFBWTtRQUNsRUgsYUFBYTtJQUNmO0lBRUEsSUFBSUksaUJBQWlCekQsR0FBR3lELGNBQWMsR0FBRztRQUFFQyxNQUFNO1FBQU03RSxPQUFPdUI7SUFBVTtJQUV4RSxJQUFJaUMsYUFBYXJDLEdBQUdpQyxPQUFPLENBQUNJLFVBQVUsR0FBRyxTQUFVc0IsQ0FBQztRQUNsRCxPQUFPQSxLQUFLQSxDQUFDLENBQUNOLFdBQVcsS0FBS2pEO0lBQ2hDO0lBRUEsSUFBSWtDLGNBQWN0QyxHQUFHaUMsT0FBTyxDQUFDSyxXQUFXLEdBQUcsU0FBVXFCLENBQUM7UUFDcEQsT0FBT0EsS0FBS0EsRUFBRUMsTUFBTSxLQUFLeEQ7SUFDM0I7SUFFQUosR0FBR2lDLE9BQU8sQ0FBQ3NCLFFBQVEsR0FBR0Y7SUFFdEIsSUFBSVEsa0JBQW1CLFNBQVNDLFNBQVM7UUFDdkMvQixTQUFTOEIsaUJBQWlCQztRQUMxQixTQUFTRCxnQkFBZ0JFLENBQUMsRUFBRUMsQ0FBQztZQUMzQixJQUFJLENBQUNELENBQUMsR0FBR0E7WUFDVCxJQUFJLENBQUNDLENBQUMsR0FBR0E7UUFDWDtRQUNBSCxnQkFBZ0J0RCxTQUFTLENBQUM4QyxXQUFXLEdBQUc7WUFDdEMsSUFBSTlELFFBQU8sSUFBSTtZQUNmLE9BQU87Z0JBQ0wwRSxNQUFNO29CQUNKLE9BQU8xRSxNQUFLd0UsQ0FBQyxLQUNaO3dCQUFFTCxNQUFNO3dCQUFPN0UsT0FBT1UsTUFBS3lFLENBQUM7b0JBQUMsSUFDN0I7d0JBQUVOLE1BQU07d0JBQU03RSxPQUFPLEtBQUs7b0JBQUU7Z0JBQy9CO1lBQ0Y7UUFDRjtRQUNBLE9BQU9nRjtJQUNULEVBQUV0QztJQUVGLFNBQVMyQyxnQkFBZ0JDLFNBQVMsRUFBRUMsTUFBTTtRQUN4QyxPQUFPLElBQUlQLGdCQUFnQk0sV0FBV0M7SUFDeEM7SUFFQzs7Ozs7O0dBTUEsR0FDRDlELGdCQUFnQitELE9BQU8sR0FBRy9ELGVBQWUsQ0FBQyxNQUFNLEdBQUcsU0FBVWdFLElBQUk7UUFDL0QsT0FBT0EsS0FBSyxJQUFJO0lBQ2xCO0lBRUM7Ozs7Ozs7Ozs7O0dBV0EsR0FDRGpFLFVBQVUsQ0FBQyxLQUFLLEdBQUcsU0FBVThELFNBQVMsRUFBRUksVUFBVSxFQUFFQyxxQkFBcUI7UUFDdkUsT0FBTzFELGdCQUFnQjtZQUNyQjBELHlCQUEwQkEsQ0FBQUEsd0JBQXdCeEQsaUJBQWdCO1lBRWxFbUIsVUFBVW9DLGVBQWdCQSxDQUFBQSxhQUFhL0Isc0JBQXNCK0IsV0FBVTtZQUN2RXBDLFVBQVVxQywwQkFBMkJBLENBQUFBLHdCQUF3QmhDLHNCQUFzQmdDLHNCQUFxQjtZQUV4RyxvQ0FBb0M7WUFDcEMsT0FBT0Esc0JBQXNCQyxHQUFHLEtBQUssY0FBZUQsQ0FBQUEsd0JBQXdCeEQsZ0JBQWdCd0Qsc0JBQXFCO1lBQ2pILE9BQU9MLGNBQWNJLGFBQWFDO1FBQ3BDO0lBQ0Y7SUFFQzs7Ozs7O0dBTUEsR0FDRG5FLFVBQVUsQ0FBQyxNQUFNLEdBQUdBLFdBQVdxRSxLQUFLLEdBQUcsU0FBVUMsT0FBTyxFQUFFQyxjQUFjLEVBQUVDLE9BQU87UUFDL0UsT0FBT3JELGFBQWFtRCxTQUFTQyxnQkFBZ0JDLFNBQVNoRSxNQUFNO0lBQzlEO0lBRUM7Ozs7Ozs7R0FPQSxHQUNELElBQUlpRSxvQkFBb0J6RSxVQUFVLENBQUMsUUFBUSxHQUFHQSxXQUFXMEUsT0FBTyxHQUFHLFNBQVVaLFNBQVMsRUFBRUMsTUFBTTtRQUM1RmpDLFVBQVVpQyxXQUFZQSxDQUFBQSxTQUFTNUIsc0JBQXNCNEIsT0FBTTtRQUMzRCxPQUFPRixnQkFBZ0JDLFdBQVdDLFFBQVF2RCxNQUFNO0lBQ2xEO0lBRUM7Ozs7OztHQU1BLEdBQ0RQLGdCQUFnQjBFLE9BQU8sR0FBRyxTQUFVYixTQUFTO1FBQzNDLE9BQU92RCxpQkFBaUI7WUFBQyxJQUFJO1lBQUVrRSxrQkFBa0JYLFdBQVcsSUFBSTtTQUFFO0lBQ3BFO0lBRUM7Ozs7Ozs7R0FPQSxHQUNEOUQsVUFBVSxDQUFDLE9BQU8sR0FBRyxTQUFVNEUsUUFBUSxFQUFFTixPQUFPLEVBQUVPLHdCQUF3QjtRQUN4RSxPQUFPcEUsZ0JBQWdCO1lBQ3JCcUIsVUFBVStDLDZCQUE4QkEsQ0FBQUEsMkJBQTJCMUMsc0JBQXNCMEMseUJBQXdCO1lBQ2pIQSw0QkFBNkJBLENBQUFBLDJCQUEyQmxFLGlCQUFnQjtZQUV4RXVCLFlBQVkyQyw2QkFBOEJBLENBQUFBLDJCQUEyQmxFLGdCQUFnQmtFLHlCQUF3QjtZQUU3RyxJQUFJQyxTQUFTUixPQUFPLENBQUNNLFdBQVc7WUFDaEM5QyxVQUFVZ0QsV0FBWUEsQ0FBQUEsU0FBUzNDLHNCQUFzQjJDLE9BQU07WUFFM0QsT0FBT0EsVUFBVUQ7UUFDbkI7SUFDRjtJQUVBLElBQUlFLG1CQUFvQixTQUFTdEIsU0FBUztRQUN4Qy9CLFNBQVNxRCxrQkFBa0J0QjtRQUMzQixTQUFTc0IsaUJBQWlCaEIsTUFBTSxFQUFFbEIsRUFBRSxFQUFFbUMsU0FBUztZQUM3QyxJQUFJLENBQUNqQixNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDa0IsR0FBRyxHQUFHcEM7WUFDWCxJQUFJLENBQUNxQyxVQUFVLEdBQUdGO1lBQ2xCdkIsVUFBVTVELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUEsU0FBU3NGLGtCQUFrQkMsSUFBSSxFQUFFQyxPQUFPO1lBQ3RDLElBQUlDLFFBQVFGLElBQUksQ0FBQyxFQUFFLEVBQUVsRyxRQUFPa0csSUFBSSxDQUFDLEVBQUU7WUFDbkMsSUFBSUc7WUFDSixJQUFJRCxNQUFNRSxDQUFDLENBQUNqQyxNQUFNLEdBQUcsR0FBRztnQkFDdEJnQyxPQUFPRCxNQUFNRSxDQUFDLENBQUNDLEtBQUs7WUFDdEIsT0FBTztnQkFDTEgsTUFBTUksVUFBVSxHQUFHO2dCQUNuQjtZQUNGO1lBQ0EsSUFBSUMsS0FBSyxJQUFJMUU7WUFDYnFFLE1BQU1NLENBQUMsQ0FBQ0MsR0FBRyxDQUFDRjtZQUNaQSxHQUFHRyxhQUFhLENBQUNQLEtBQUtRLFNBQVMsQ0FBQyxJQUFJQyxlQUFlVixPQUFPcEcsT0FBTXlHO1lBQ2hFTixRQUFRO2dCQUFDQztnQkFBT3BHO2FBQUs7UUFDdkI7UUFFQTZGLGlCQUFpQjdFLFNBQVMsQ0FBQytGLGFBQWEsR0FBRyxTQUFVWCxLQUFLO1lBQ3hELElBQUlZLFVBQVU7WUFDZCxJQUFJWixNQUFNRSxDQUFDLENBQUNqQyxNQUFNLEdBQUcsR0FBRztnQkFDdEIyQyxVQUFVLENBQUNaLE1BQU1JLFVBQVU7Z0JBQzNCSixNQUFNSSxVQUFVLEdBQUc7WUFDckI7WUFDQVEsV0FBV1osTUFBTWEsQ0FBQyxDQUFDTCxhQUFhLENBQUMsSUFBSSxDQUFDWixVQUFVLENBQUNDLGlCQUFpQixDQUFDO2dCQUFDRztnQkFBTyxJQUFJO2FBQUMsRUFBRUg7UUFDcEY7UUFFQUosaUJBQWlCN0UsU0FBUyxDQUFDa0csYUFBYSxHQUFHLFNBQVU5QyxDQUFDO1lBQ3BELElBQUk2QyxJQUFJLElBQUluRixvQkFDVjRFLElBQUksSUFBSTdFLG9CQUFvQm9GLElBQzVCYixRQUFRO2dCQUNORSxHQUFHLEVBQUU7Z0JBQ0xXLEdBQUdBO2dCQUNIUCxHQUFHQTtnQkFDSFMsYUFBYTtnQkFDYlgsWUFBWTtnQkFDWnBDLEdBQUdBO1lBQ0w7WUFFRmdDLE1BQU1FLENBQUMsQ0FBQ2MsSUFBSSxDQUFDLElBQUksQ0FBQ3ZDLE1BQU07WUFDeEJ1QixNQUFNZSxXQUFXO1lBQ2pCLElBQUksQ0FBQ0osYUFBYSxDQUFDWDtZQUNuQixPQUFPTTtRQUNUO1FBRUEsT0FBT2I7SUFDVCxFQUFFNUU7SUFFRixJQUFJNkYsaUJBQWtCLFNBQVN2QyxTQUFTO1FBQ3RDL0IsU0FBU3NFLGdCQUFnQnZDO1FBQ3pCLFNBQVN1QyxlQUFlVixLQUFLLEVBQUVpQixNQUFNLEVBQUVaLEVBQUU7WUFDdkMsSUFBSSxDQUFDYSxFQUFFLEdBQUdsQjtZQUNWLElBQUksQ0FBQ21CLEVBQUUsR0FBR0Y7WUFDVixJQUFJLENBQUNHLEdBQUcsR0FBR2Y7WUFDWGxDLFVBQVU1RCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBbUcsZUFBZTlGLFNBQVMsQ0FBQzBELElBQUksR0FBRyxTQUFVK0MsQ0FBQztZQUN6QyxJQUFJLENBQUNILEVBQUUsQ0FBQ2xELENBQUMsQ0FBQ3NELE1BQU0sQ0FBQ0Q7WUFDakIsSUFBSTdCLFNBQVNsQyxTQUFTLElBQUksQ0FBQzZELEVBQUUsQ0FBQ3hCLEdBQUcsRUFBRTBCO1lBQ25DLElBQUk3QixXQUFXekMsVUFBVTtnQkFBRSxPQUFPLElBQUksQ0FBQ21FLEVBQUUsQ0FBQ2xELENBQUMsQ0FBQ3VELE9BQU8sQ0FBQy9CLE9BQU94QyxDQUFDO1lBQUc7WUFDL0QsSUFBSSxDQUFDa0UsRUFBRSxDQUFDaEIsQ0FBQyxDQUFDYyxJQUFJLENBQUN4QjtZQUNmLElBQUksQ0FBQzBCLEVBQUUsQ0FBQ0gsV0FBVztZQUNuQixJQUFJLENBQUNJLEVBQUUsQ0FBQ1IsYUFBYSxDQUFDLElBQUksQ0FBQ08sRUFBRTtRQUMvQjtRQUVBUixlQUFlOUYsU0FBUyxDQUFDNEcsS0FBSyxHQUFHLFNBQVV4RSxDQUFDO1lBQzFDLElBQUksQ0FBQ2tFLEVBQUUsQ0FBQ2xELENBQUMsQ0FBQ3VELE9BQU8sQ0FBQ3ZFO1FBQ3BCO1FBRUEwRCxlQUFlOUYsU0FBUyxDQUFDNkcsU0FBUyxHQUFHO1lBQ25DLElBQUksQ0FBQ1AsRUFBRSxDQUFDWixDQUFDLENBQUNvQixNQUFNLENBQUMsSUFBSSxDQUFDTixHQUFHO1lBQ3pCLElBQUksQ0FBQ0YsRUFBRSxDQUFDSCxXQUFXO1lBQ25CLElBQUksQ0FBQ0csRUFBRSxDQUFDSCxXQUFXLEtBQUssS0FBSyxJQUFJLENBQUNHLEVBQUUsQ0FBQ2xELENBQUMsQ0FBQzJELFdBQVc7UUFDcEQ7UUFFQSxPQUFPakI7SUFDVCxFQUFFNUY7SUFFRDs7Ozs7O0dBTUEsR0FDREgsZ0JBQWdCaUgsTUFBTSxHQUFHLFNBQVV0QyxRQUFRLEVBQUVJLFNBQVM7UUFDcEQ5QyxZQUFZOEMsY0FBZUEsQ0FBQUEsWUFBWTNELHNCQUFxQjtRQUM1RCxPQUFPLElBQUkwRCxpQkFBaUIsSUFBSSxFQUFFSCxVQUFVSTtJQUM5QztJQUVBLFNBQVNtQztRQUNQLElBQUlDLE1BQU16RSxVQUFVWSxNQUFNLEVBQUU2QixPQUFPLElBQUlpQyxNQUFNRDtRQUM3QyxJQUFJLElBQUlFLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztZQUFFbEMsSUFBSSxDQUFDa0MsRUFBRSxHQUFHM0UsU0FBUyxDQUFDMkUsRUFBRTtRQUFFO1FBQ3ZELE9BQU9sQztJQUNUO0lBRUEsSUFBSW1DLHFCQUFzQixTQUFVOUQsU0FBUztRQUMzQy9CLFNBQVM2RixvQkFBb0I5RDtRQUM3QixTQUFTOEQsbUJBQW1CakQsT0FBTyxFQUFFa0QsRUFBRTtZQUNyQyxJQUFJLENBQUNDLFFBQVEsR0FBR25EO1lBQ2hCLElBQUksQ0FBQ29ELEdBQUcsR0FBR0Y7WUFDWC9ELFVBQVU1RCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBMEgsbUJBQW1CckgsU0FBUyxDQUFDa0csYUFBYSxHQUFHLFNBQVU5QyxDQUFDO1lBQ3RELElBQUksSUFBSSxDQUFDbUUsUUFBUSxDQUFDbEUsTUFBTSxLQUFLLEdBQUc7Z0JBQzlCRCxFQUFFMkQsV0FBVztnQkFDYixPQUFPcEc7WUFDVDtZQUVBLElBQUk4RyxRQUFRLElBQUksQ0FBQ0YsUUFBUSxDQUFDbEUsTUFBTTtZQUNoQyxJQUFJK0IsUUFBUTtnQkFDVnNDLFVBQVU7Z0JBQ1ZDLFlBQVksSUFBSVIsTUFBTU07Z0JBQ3RCRyxjQUFjLElBQUlULE1BQU1NO2dCQUN4QkksU0FBUyxJQUFJVixNQUFNTTtZQUNyQjtZQUVBLElBQUlLLGdCQUFnQixJQUFJakg7WUFDeEIsSUFBSyxJQUFJdUcsSUFBSSxHQUFHRixNQUFNLElBQUksQ0FBQ0ssUUFBUSxDQUFDbEUsTUFBTSxFQUFFK0QsSUFBSUYsS0FBS0UsSUFBSztnQkFDeEQsSUFBSXZELFNBQVMsSUFBSSxDQUFDMEQsUUFBUSxDQUFDSCxFQUFFO2dCQUM3QnhGLFVBQVVpQyxXQUFZQSxDQUFBQSxTQUFTNUIsc0JBQXNCNEIsT0FBTTtnQkFDM0RpRSxjQUFjbkMsR0FBRyxDQUFDOUIsT0FBT2dDLFNBQVMsQ0FBQyxJQUFJa0MsaUJBQWlCM0UsR0FBR2dDLE9BQU9nQyxHQUFHLElBQUksQ0FBQ0ksR0FBRyxFQUFFTTtZQUNqRjtZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxPQUFPVDtJQUNULEVBQUVwSDtJQUVGLElBQUk4SCxtQkFBb0IsU0FBU3hFLFNBQVM7UUFDeEMvQixTQUFTdUcsa0JBQWtCeEU7UUFDM0IsU0FBU3dFLGlCQUFpQjNFLENBQUMsRUFBRUssQ0FBQyxFQUFFMkQsQ0FBQyxFQUFFRSxFQUFFLEVBQUVVLElBQUk7WUFDekMsSUFBSSxDQUFDQyxFQUFFLEdBQUc3RTtZQUNWLElBQUksQ0FBQ2tELEVBQUUsR0FBRzdDO1lBQ1YsSUFBSSxDQUFDeUUsRUFBRSxHQUFHZDtZQUNWLElBQUksQ0FBQ0ksR0FBRyxHQUFHRjtZQUNYLElBQUksQ0FBQ2EsS0FBSyxHQUFHSDtZQUNiekUsVUFBVTVELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUFvSSxpQkFBaUIvSCxTQUFTLENBQUMwRCxJQUFJLEdBQUcsU0FBVStDLENBQUM7WUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQ0gsRUFBRSxDQUFDb0IsUUFBUSxFQUFFO2dCQUNyQixJQUFJLENBQUNwQixFQUFFLENBQUNxQixVQUFVLENBQUMsSUFBSSxDQUFDTyxFQUFFLENBQUMsR0FBRztnQkFDOUIsSUFBSSxDQUFDNUIsRUFBRSxDQUFDdUIsT0FBTyxDQUFDLElBQUksQ0FBQ0ssRUFBRSxDQUFDLEdBQUd6QjtZQUM3QjtRQUNGO1FBRUFzQixpQkFBaUIvSCxTQUFTLENBQUM0RyxLQUFLLEdBQUcsU0FBVXhFLENBQUM7WUFDNUMsSUFBSSxDQUFDa0UsRUFBRSxDQUFDb0IsUUFBUSxHQUFHO1lBQ25CLElBQUksQ0FBQ08sRUFBRSxDQUFDdEIsT0FBTyxDQUFDdkU7WUFDaEIsSUFBSSxDQUFDK0YsS0FBSyxDQUFDQyxPQUFPO1FBQ3BCO1FBRUFMLGlCQUFpQi9ILFNBQVMsQ0FBQzZHLFNBQVMsR0FBRztZQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxFQUFFLENBQUNvQixRQUFRLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUNwQixFQUFFLENBQUNxQixVQUFVLENBQUMsSUFBSSxDQUFDTyxFQUFFLENBQUMsRUFBRTtvQkFDaEMsT0FBTyxJQUFJLENBQUNELEVBQUUsQ0FBQ2xCLFdBQVc7Z0JBQzVCO2dCQUNBLElBQUksQ0FBQ1QsRUFBRSxDQUFDc0IsWUFBWSxDQUFDLElBQUksQ0FBQ00sRUFBRSxDQUFDLEdBQUc7Z0JBQ2hDLElBQUssSUFBSWQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2QsRUFBRSxDQUFDdUIsT0FBTyxDQUFDeEUsTUFBTSxFQUFFK0QsSUFBSztvQkFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQ2QsRUFBRSxDQUFDc0IsWUFBWSxDQUFDUixFQUFFLEVBQUU7d0JBQUU7b0JBQVE7Z0JBQzFDO2dCQUNBLElBQUksQ0FBQ2QsRUFBRSxDQUFDb0IsUUFBUSxHQUFHO2dCQUVuQixJQUFJVyxNQUFNM0YsU0FBUyxJQUFJLENBQUM4RSxHQUFHLEVBQUVoRixLQUFLLENBQUMsTUFBTSxJQUFJLENBQUM4RCxFQUFFLENBQUN1QixPQUFPO2dCQUN4RCxJQUFJUSxRQUFRbEcsVUFBVTtvQkFBRSxPQUFPLElBQUksQ0FBQzhGLEVBQUUsQ0FBQ3RCLE9BQU8sQ0FBQzBCLElBQUlqRyxDQUFDO2dCQUFHO2dCQUV2RCxJQUFJLENBQUM2RixFQUFFLENBQUN2QixNQUFNLENBQUMyQjtnQkFDZixJQUFJLENBQUNKLEVBQUUsQ0FBQ2xCLFdBQVc7WUFDckI7UUFDRjtRQUVBLE9BQU9nQjtJQUNULEVBQUU3SDtJQUVEOzs7Ozs7O0dBT0EsR0FDREosV0FBV3dJLFFBQVEsR0FBRztRQUNwQixJQUFJcEIsTUFBTXpFLFVBQVVZLE1BQU0sRUFBRTZCLE9BQU8sSUFBSWlDLE1BQU1EO1FBQzdDLElBQUksSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1lBQUVsQyxJQUFJLENBQUNrQyxFQUFFLEdBQUczRSxTQUFTLENBQUMyRSxFQUFFO1FBQUU7UUFDdkQsSUFBSS9DLGlCQUFpQnhDLFdBQVdxRCxJQUFJLENBQUNnQyxNQUFNLEVBQUUsSUFBSWhDLEtBQUtxRCxHQUFHLEtBQUt0QjtRQUM5REUsTUFBTXFCLE9BQU8sQ0FBQ3RELElBQUksQ0FBQyxFQUFFLEtBQU1BLENBQUFBLE9BQU9BLElBQUksQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sSUFBSW1DLG1CQUFtQm5DLE1BQU1iO0lBQ3RDO0lBRUM7Ozs7O0dBS0EsR0FDRHRFLGdCQUFnQnVJLFFBQVEsR0FBRztRQUN6QixJQUFJcEIsTUFBTXpFLFVBQVVZLE1BQU0sRUFBRTZCLE9BQU8sSUFBSWlDLE1BQU1EO1FBQzdDLElBQUksSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1lBQUVsQyxJQUFJLENBQUNrQyxFQUFFLEdBQUczRSxTQUFTLENBQUMyRSxFQUFFO1FBQUU7UUFDdkQsSUFBSUQsTUFBTXFCLE9BQU8sQ0FBQ3RELElBQUksQ0FBQyxFQUFFLEdBQUc7WUFDMUJBLElBQUksQ0FBQyxFQUFFLENBQUN1RCxPQUFPLENBQUMsSUFBSTtRQUN0QixPQUFPO1lBQ0x2RCxLQUFLdUQsT0FBTyxDQUFDLElBQUk7UUFDbkI7UUFDQSxPQUFPM0ksV0FBV3dJLFFBQVEsQ0FBQzlGLEtBQUssQ0FBQyxNQUFNMEM7SUFDekM7SUFFQTs7Ozs7R0FLQyxHQUNEbkYsZ0JBQWdCMkksVUFBVSxHQUFHM0ksZ0JBQWdCNEksTUFBTSxHQUFHLFNBQVVqRSxRQUFRLEVBQUVJLFNBQVM7UUFDakY5QyxZQUFZOEMsY0FBZUEsQ0FBQUEsWUFBWXJGLEdBQUcyQixTQUFTLENBQUN3SCxTQUFTO1FBQzdELElBQUkvRSxTQUFTLElBQUk7UUFDakIsT0FBT3RELGdCQUFnQjtZQUNyQixJQUFJc0k7WUFFSixPQUFPaEYsT0FDSmlGLEdBQUcsQ0FBQyxTQUFVckMsQ0FBQztnQkFDZCxJQUFJc0MsT0FBTyxJQUFJQyxnQkFBZ0J2QztnQkFFL0JvQyxTQUFTQSxNQUFNbkMsTUFBTSxDQUFDRDtnQkFDdEJvQyxRQUFRRTtnQkFFUixPQUFPQTtZQUNULEdBQ0NFLEdBQUcsQ0FDRnRILE1BQ0EsU0FBVVMsQ0FBQztnQkFBSXlHLFNBQVNBLE1BQU1sQyxPQUFPLENBQUN2RTtZQUFJLEdBQzFDO2dCQUFjeUcsU0FBU0EsTUFBTTlCLFdBQVc7WUFBSSxHQUU3Q21DLFNBQVMsQ0FBQ3BFLFdBQ1ZnRSxHQUFHLENBQUNwRTtRQUNULEdBQUdiO0lBQ0w7SUFFQSxJQUFJbUYsa0JBQW1CLFNBQVV6RixTQUFTO1FBQ3hDL0IsU0FBU3dILGlCQUFpQnpGO1FBQzFCLFNBQVN5RixnQkFBZ0JHLElBQUk7WUFDM0I1RixVQUFVNUQsSUFBSSxDQUFDLElBQUk7WUFDbkIsSUFBSSxDQUFDd0osSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUk5SDtRQUNsQjtRQUVBRyxjQUFjdUgsZ0JBQWdCaEosU0FBUyxFQUFFdUIsVUFBVTtZQUNqRDhILFlBQVksU0FBVWpHLENBQUM7Z0JBQ3JCLElBQUlrRyxJQUFJLElBQUl6STtnQkFDWnlJLEVBQUUzRCxHQUFHLENBQUN4RSx1QkFBdUJvSSxRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVVDLENBQUMsRUFBRXhLLEtBQUk7b0JBQzNEb0UsRUFBRXNELE1BQU0sQ0FBQzFILE1BQUttSyxJQUFJO29CQUNsQkcsRUFBRTNELEdBQUcsQ0FBQzNHLE1BQUtvSyxJQUFJLENBQUNLLFFBQVEsR0FBRzVELFNBQVMsQ0FBQ3pDO2dCQUN2QztnQkFFQSxPQUFPa0c7WUFDVDtZQUNBdkMsYUFBYTtnQkFDWCxJQUFJLENBQUNMLE1BQU0sQ0FBQzVHLFdBQVdZLEtBQUs7WUFDOUI7WUFDQWlHLFNBQVMsU0FBVXZFLENBQUM7Z0JBQ2xCLElBQUksQ0FBQ3NFLE1BQU0sQ0FBQzVHLFVBQVUsQ0FBQyxRQUFRLENBQUNzQztZQUNsQztZQUNBc0UsUUFBUSxTQUFVZ0QsQ0FBQztnQkFDakIsSUFBSSxDQUFDTixJQUFJLENBQUMxQyxNQUFNLENBQUNnRDtnQkFDakIsSUFBSSxDQUFDTixJQUFJLENBQUNyQyxXQUFXO1lBQ3ZCO1FBQ0Y7UUFFQSxPQUFPaUM7SUFFVCxFQUFFbEo7SUFFRixJQUFJNkosd0JBQXlCLFNBQVVwRyxTQUFTO1FBQzlDL0IsU0FBU21JLHVCQUF1QnBHO1FBQ2hDLFNBQVNvRyxzQkFBc0I5RixNQUFNO1lBQ25DLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtZQUNkTixVQUFVNUQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQWdLLHNCQUFzQjNKLFNBQVMsQ0FBQ2tHLGFBQWEsR0FBRyxTQUFVOUMsQ0FBQztZQUN6RCxJQUFJNkMsSUFBSSxJQUFJbEYsOEJBQ1Z1SSxJQUFJLElBQUl6SSx1QkFDUnVFLFFBQVE7Z0JBQ053RSxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYekcsR0FBR0E7Z0JBQ0hrRyxHQUFHQTtZQUNMO1lBRUZBLEVBQUUzRCxHQUFHLENBQUNNO1lBQ05BLEVBQUVMLGFBQWEsQ0FBQyxJQUFJLENBQUMvQixNQUFNLENBQUNnQyxTQUFTLENBQUMsSUFBSWlFLG9CQUFvQjFFO1lBQzlELE9BQU9rRTtRQUNUO1FBRUEsT0FBT0s7SUFDVCxFQUFFMUo7SUFFRixJQUFJNkosc0JBQXVCLFNBQVN2RyxTQUFTO1FBQzNDL0IsU0FBU3NJLHFCQUFxQnZHO1FBQzlCLFNBQVN1RyxvQkFBb0IxRSxLQUFLO1lBQ2hDLElBQUksQ0FBQ2tCLEVBQUUsR0FBR2xCO1lBQ1Y3QixVQUFVNUQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQW1LLG9CQUFvQjlKLFNBQVMsQ0FBQzBELElBQUksR0FBRyxTQUFVK0MsQ0FBQztZQUM5QyxJQUFJLENBQUMsSUFBSSxDQUFDSCxFQUFFLENBQUNzRCxVQUFVLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQ3RELEVBQUUsQ0FBQ3NELFVBQVUsR0FBRztnQkFDckJoSSxVQUFVNkUsTUFBT0EsQ0FBQUEsSUFBSXhFLHNCQUFzQndFLEVBQUM7Z0JBQzVDLElBQUlzRCxRQUFRLElBQUloSjtnQkFDaEIsSUFBSSxDQUFDdUYsRUFBRSxDQUFDZ0QsQ0FBQyxDQUFDM0QsR0FBRyxDQUFDb0U7Z0JBQ2RBLE1BQU1uRSxhQUFhLENBQUNhLEVBQUVaLFNBQVMsQ0FBQyxJQUFJbUUsY0FBYyxJQUFJLENBQUMxRCxFQUFFLEVBQUV5RDtZQUM3RDtRQUNGO1FBRUFELG9CQUFvQjlKLFNBQVMsQ0FBQzRHLEtBQUssR0FBRyxTQUFVeEUsQ0FBQztZQUMvQyxJQUFJLENBQUNrRSxFQUFFLENBQUNsRCxDQUFDLENBQUN1RCxPQUFPLENBQUN2RTtRQUNwQjtRQUVBMEgsb0JBQW9COUosU0FBUyxDQUFDNkcsU0FBUyxHQUFHO1lBQ3hDLElBQUksQ0FBQ1AsRUFBRSxDQUFDdUQsU0FBUyxHQUFHO1lBQ3BCLENBQUMsSUFBSSxDQUFDdkQsRUFBRSxDQUFDc0QsVUFBVSxJQUFJLElBQUksQ0FBQ3RELEVBQUUsQ0FBQ2dELENBQUMsQ0FBQ2pHLE1BQU0sS0FBSyxLQUFLLElBQUksQ0FBQ2lELEVBQUUsQ0FBQ2xELENBQUMsQ0FBQzJELFdBQVc7UUFDeEU7UUFFQXZGLFNBQVN3SSxlQUFlekc7UUFDeEIsU0FBU3lHLGNBQWM1RSxLQUFLLEVBQUUyRSxLQUFLO1lBQ2pDLElBQUksQ0FBQ3pELEVBQUUsR0FBR2xCO1lBQ1YsSUFBSSxDQUFDOEMsRUFBRSxHQUFHNkI7WUFDVnhHLFVBQVU1RCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBcUssY0FBY2hLLFNBQVMsQ0FBQzBELElBQUksR0FBRyxTQUFVK0MsQ0FBQztZQUFJLElBQUksQ0FBQ0gsRUFBRSxDQUFDbEQsQ0FBQyxDQUFDc0QsTUFBTSxDQUFDRDtRQUFJO1FBQ25FdUQsY0FBY2hLLFNBQVMsQ0FBQzRHLEtBQUssR0FBRyxTQUFVeEUsQ0FBQztZQUFJLElBQUksQ0FBQ2tFLEVBQUUsQ0FBQ2xELENBQUMsQ0FBQ3VELE9BQU8sQ0FBQ3ZFO1FBQUk7UUFDckU0SCxjQUFjaEssU0FBUyxDQUFDNkcsU0FBUyxHQUFHO1lBQ2xDLElBQUksQ0FBQ1AsRUFBRSxDQUFDZ0QsQ0FBQyxDQUFDeEMsTUFBTSxDQUFDLElBQUksQ0FBQ29CLEVBQUU7WUFDeEIsSUFBSSxDQUFDNUIsRUFBRSxDQUFDc0QsVUFBVSxHQUFHO1lBQ3JCLElBQUksQ0FBQ3RELEVBQUUsQ0FBQ3VELFNBQVMsSUFBSSxJQUFJLENBQUN2RCxFQUFFLENBQUNnRCxDQUFDLENBQUNqRyxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUNpRCxFQUFFLENBQUNsRCxDQUFDLENBQUMyRCxXQUFXO1FBQ3RFO1FBRUEsT0FBTytDO0lBQ1QsRUFBRTVKO0lBRUY7Ozs7R0FJQyxHQUNESCxnQkFBZ0JrSyxXQUFXLEdBQUc7UUFDNUIsT0FBTyxJQUFJTixzQkFBc0IsSUFBSTtJQUN2QztJQUVGNUosZ0JBQWdCbUssWUFBWSxHQUFHbkssZ0JBQWdCb0ssVUFBVSxHQUFHLFNBQVN6RixRQUFRLEVBQUVMLGNBQWMsRUFBRUMsT0FBTztRQUNsRyxPQUFPLElBQUlsRSxrQkFBa0IsSUFBSSxFQUFFc0UsVUFBVUwsZ0JBQWdCQyxTQUFTMkYsV0FBVztJQUNyRjtJQUVBbEssZ0JBQWdCcUssd0JBQXdCLEdBQUdySyxnQkFBZ0JzSyxvQkFBb0IsR0FBRyxTQUFTQyxLQUFLLEVBQUU1RixRQUFRLEVBQUVMLGNBQWMsRUFBRUMsT0FBTztRQUMvSCxPQUFPLElBQUlsRSxrQkFBa0IsSUFBSSxFQUFFc0UsVUFBVUwsZ0JBQWdCQyxTQUFTaUcsS0FBSyxDQUFDRDtJQUNoRjtJQUVFLE9BQU83SztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9kaXN0L3J4LmV4cGVyaW1lbnRhbC5qcz8xZjkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LCBBbGwgcmlnaHRzIHJlc2VydmVkLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpID8gZXhwb3J0cyA6IG51bGw7XG4gIHZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKSA/IG1vZHVsZSA6IG51bGw7XG4gIHZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuICB2YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG4gIHZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSAoZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSA/IGZyZWVFeHBvcnRzIDogbnVsbDtcbiAgdmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8vIEJlY2F1c2Ugb2YgYnVpbGQgb3B0aW1pemVyc1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnLi9yeCddLCBmdW5jdGlvbiAoUngsIGV4cG9ydHMpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIFJ4KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QsIG1vZHVsZS5leHBvcnRzLCByZXF1aXJlKCcuL3J4JykpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUnggPSBmYWN0b3J5KHJvb3QsIHt9LCByb290LlJ4KTtcbiAgfVxufS5jYWxsKHRoaXMsIGZ1bmN0aW9uIChyb290LCBleHAsIFJ4LCB1bmRlZmluZWQpIHtcblxuICAvLyBBbGlhc2VzXG4gIHZhciBPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZhYmxlUHJvdG8gPSBPYnNlcnZhYmxlLnByb3RvdHlwZSxcbiAgICBPYnNlcnZhYmxlQmFzZSA9IFJ4Lk9ic2VydmFibGVCYXNlLFxuICAgIEFic3RyYWN0T2JzZXJ2ZXIgPSBSeC5pbnRlcm5hbHMuQWJzdHJhY3RPYnNlcnZlcixcbiAgICBGbGF0TWFwT2JzZXJ2YWJsZSA9IFJ4LkZsYXRNYXBPYnNlcnZhYmxlLFxuICAgIG9ic2VydmFibGVDb25jYXQgPSBPYnNlcnZhYmxlLmNvbmNhdCxcbiAgICBvYnNlcnZhYmxlRGVmZXIgPSBPYnNlcnZhYmxlLmRlZmVyLFxuICAgIG9ic2VydmFibGVFbXB0eSA9IE9ic2VydmFibGUuZW1wdHksXG4gICAgZGlzcG9zYWJsZUVtcHR5ID0gUnguRGlzcG9zYWJsZS5lbXB0eSxcbiAgICBDb21wb3NpdGVEaXNwb3NhYmxlID0gUnguQ29tcG9zaXRlRGlzcG9zYWJsZSxcbiAgICBTZXJpYWxEaXNwb3NhYmxlID0gUnguU2VyaWFsRGlzcG9zYWJsZSxcbiAgICBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSA9IFJ4LlNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlLFxuICAgIEVudW1lcmFibGUgPSBSeC5pbnRlcm5hbHMuRW51bWVyYWJsZSxcbiAgICBlbnVtZXJhYmxlT2YgPSBFbnVtZXJhYmxlLm9mLFxuICAgIGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIgPSBSeC5TY2hlZHVsZXIuY3VycmVudFRocmVhZCxcbiAgICBBc3luY1N1YmplY3QgPSBSeC5Bc3luY1N1YmplY3QsXG4gICAgT2JzZXJ2ZXIgPSBSeC5PYnNlcnZlcixcbiAgICBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyxcbiAgICBhZGRQcm9wZXJ0aWVzID0gUnguaW50ZXJuYWxzLmFkZFByb3BlcnRpZXMsXG4gICAgaGVscGVycyA9IFJ4LmhlbHBlcnMsXG4gICAgbm9vcCA9IGhlbHBlcnMubm9vcCxcbiAgICBpc1Byb21pc2UgPSBoZWxwZXJzLmlzUHJvbWlzZSxcbiAgICBpc0Z1bmN0aW9uID0gaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgIGlzSXRlcmFibGUgPSBSeC5oZWxwZXJzLmlzSXRlcmFibGUsXG4gICAgaXNBcnJheUxpa2UgPSBSeC5oZWxwZXJzLmlzQXJyYXlMaWtlLFxuICAgIGlzU2NoZWR1bGVyID0gUnguU2NoZWR1bGVyLmlzU2NoZWR1bGVyLFxuICAgIG9ic2VydmFibGVGcm9tUHJvbWlzZSA9IE9ic2VydmFibGUuZnJvbVByb21pc2U7XG5cbiAgdmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbiAgXG4gIGZ1bmN0aW9uIHRyeUNhdGNoZXJHZW4odHJ5Q2F0Y2hUYXJnZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgdHJ5Q2F0Y2ggPSBSeC5pbnRlcm5hbHMudHJ5Q2F0Y2ggPSBmdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignZm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7IH1cbiAgICByZXR1cm4gdHJ5Q2F0Y2hlckdlbihmbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIC8vIFNoaW0gaW4gaXRlcmF0b3Igc3VwcG9ydFxuICB2YXIgJGl0ZXJhdG9yJCA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcikgfHxcbiAgICAnX2VzNnNoaW1faXRlcmF0b3JfJztcbiAgLy8gQnVnIGZvciBtb3ppbGxhIHZlcnNpb25cbiAgaWYgKHJvb3QuU2V0ICYmIHR5cGVvZiBuZXcgcm9vdC5TZXQoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgJGl0ZXJhdG9yJCA9ICdAQGl0ZXJhdG9yJztcbiAgfVxuXG4gIHZhciBkb25lRW51bWVyYXRvciA9IFJ4LmRvbmVFbnVtZXJhdG9yID0geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cbiAgdmFyIGlzSXRlcmFibGUgPSBSeC5oZWxwZXJzLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIG9bJGl0ZXJhdG9yJF0gIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgaXNBcnJheUxpa2UgPSBSeC5oZWxwZXJzLmlzQXJyYXlMaWtlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBvLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFJ4LmhlbHBlcnMuaXRlcmF0b3IgPSAkaXRlcmF0b3IkO1xuXG4gIHZhciBXaGlsZUVudW1lcmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoV2hpbGVFbnVtZXJhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFdoaWxlRW51bWVyYWJsZShjLCBzKSB7XG4gICAgICB0aGlzLmMgPSBjO1xuICAgICAgdGhpcy5zID0gcztcbiAgICB9XG4gICAgV2hpbGVFbnVtZXJhYmxlLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5jKCkgP1xuICAgICAgICAgICB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogc2VsZi5zIH0gOlxuICAgICAgICAgICB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBXaGlsZUVudW1lcmFibGU7XG4gIH0oRW51bWVyYWJsZSkpO1xuICBcbiAgZnVuY3Rpb24gZW51bWVyYWJsZVdoaWxlKGNvbmRpdGlvbiwgc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBXaGlsZUVudW1lcmFibGUoY29uZGl0aW9uLCBzb3VyY2UpO1xuICB9ICBcblxuICAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiB0aGUgc291cmNlIHNlcXVlbmNlLCB3aXRob3V0IHNoYXJpbmcgc3Vic2NyaXB0aW9ucy5cbiAgICogIFRoaXMgb3BlcmF0b3IgYWxsb3dzIGZvciBhIGZsdWVudCBzdHlsZSBvZiB3cml0aW5nIHF1ZXJpZXMgdGhhdCB1c2UgdGhlIHNhbWUgc2VxdWVuY2UgbXVsdGlwbGUgdGltZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIGNhbiB1c2UgdGhlIHNvdXJjZSBzZXF1ZW5jZSBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBzaGFyaW5nIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgYSBzZXF1ZW5jZSBwcm9kdWNlZCBieSBtdWx0aWNhc3RpbmcgdGhlIHNvdXJjZSBzZXF1ZW5jZSB3aXRoaW4gYSBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5sZXRCaW5kID0gb2JzZXJ2YWJsZVByb3RvWydsZXQnXSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmModGhpcyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBjb250YWlucyB2YWx1ZXMuIFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaWYoY29uZGl0aW9uLCBvYnMxKTtcbiAgICogIDIgLSByZXMgPSBSeC5PYnNlcnZhYmxlLmlmKGNvbmRpdGlvbiwgb2JzMSwgb2JzMik7XG4gICAqICAzIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pZihjb25kaXRpb24sIG9iczEsIHNjaGVkdWxlcik7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHRoZW5Tb3VyY2Ugb3IgZWxzZVNvdXJjZSB3aWxsIGJlIHJ1bi5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSB0aGVuU291cmNlIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZWxzZVNvdXJjZV0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBjb25kaXRpb24gZnVuY3Rpb24gcmV0dXJucyBmYWxzZS4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIFJ4Lk9ic2VydmFiZS5FbXB0eSB3aXRoIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyBlaXRoZXIgdGhlIHRoZW5Tb3VyY2Ugb3IgZWxzZVNvdXJjZS5cbiAgICovXG4gIE9ic2VydmFibGVbJ2lmJ10gPSBmdW5jdGlvbiAoY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlT3JTY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsc2VTb3VyY2VPclNjaGVkdWxlciB8fCAoZWxzZVNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUVtcHR5KCkpO1xuXG4gICAgICBpc1Byb21pc2UodGhlblNvdXJjZSkgJiYgKHRoZW5Tb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UodGhlblNvdXJjZSkpO1xuICAgICAgaXNQcm9taXNlKGVsc2VTb3VyY2VPclNjaGVkdWxlcikgJiYgKGVsc2VTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShlbHNlU291cmNlT3JTY2hlZHVsZXIpKTtcblxuICAgICAgLy8gQXNzdW1lIGEgc2NoZWR1bGVyIGZvciBlbXB0eSBvbmx5XG4gICAgICB0eXBlb2YgZWxzZVNvdXJjZU9yU2NoZWR1bGVyLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJiAoZWxzZVNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUVtcHR5KGVsc2VTb3VyY2VPclNjaGVkdWxlcikpO1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbigpID8gdGhlblNvdXJjZSA6IGVsc2VTb3VyY2VPclNjaGVkdWxlcjtcbiAgICB9KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBDb25jYXRlbmF0ZXMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9idGFpbmVkIGJ5IHJ1bm5pbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZm9yIGVhY2ggZWxlbWVudCBpbiBzb3VyY2UuXG4gICAqIFRoZXJlIGlzIGFuIGFsaWFzIGZvciB0aGlzIG1ldGhvZCBjYWxsZWQgJ2ZvckluJyBmb3IgYnJvd3NlcnMgPElFOVxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIEFuIGFycmF5IG9mIHZhbHVlcyB0byB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gdGhlIHNvdXJjZXMgYXJyYXkgdG8gdHVybiBpdCBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gdGhlIGNvbmNhdGVuYXRlZCBvYnNlcnZhYmxlIHNlcXVlbmNlcy5cbiAgICovXG4gIE9ic2VydmFibGVbJ2ZvciddID0gT2JzZXJ2YWJsZS5mb3JJbiA9IGZ1bmN0aW9uIChzb3VyY2VzLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBlbnVtZXJhYmxlT2Yoc291cmNlcywgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpLmNvbmNhdCgpO1xuICB9O1xuXG4gICAvKipcbiAgICogIFJlcGVhdHMgc291cmNlIGFzIGxvbmcgYXMgY29uZGl0aW9uIGhvbGRzIGVtdWxhdGluZyBhIHdoaWxlIGxvb3AuXG4gICAqIFRoZXJlIGlzIGFuIGFsaWFzIGZvciB0aGlzIG1ldGhvZCBjYWxsZWQgJ3doaWxlRG8nIGZvciBicm93c2VycyA8SUU5XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIHNvdXJjZSB3aWxsIGJlIHJlcGVhdGVkLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNvdXJjZSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHdpbGwgYmUgcnVuIGlmIHRoZSBjb25kaXRpb24gZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aGljaCBpcyByZXBlYXRlZCBhcyBsb25nIGFzIHRoZSBjb25kaXRpb24gaG9sZHMuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZVdoaWxlRG8gPSBPYnNlcnZhYmxlWyd3aGlsZSddID0gT2JzZXJ2YWJsZS53aGlsZURvID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgc291cmNlKSB7XG4gICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcbiAgICByZXR1cm4gZW51bWVyYWJsZVdoaWxlKGNvbmRpdGlvbiwgc291cmNlKS5jb25jYXQoKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBSZXBlYXRzIHNvdXJjZSBhcyBsb25nIGFzIGNvbmRpdGlvbiBob2xkcyBlbXVsYXRpbmcgYSBkbyB3aGlsZSBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBzb3VyY2Ugd2lsbCBiZSByZXBlYXRlZC5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzb3VyY2UgVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgY29uZGl0aW9uIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgcmVwZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY29uZGl0aW9uIGhvbGRzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRvV2hpbGUgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVDb25jYXQoW3RoaXMsIG9ic2VydmFibGVXaGlsZURvKGNvbmRpdGlvbiwgdGhpcyldKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICBVc2VzIHNlbGVjdG9yIHRvIGRldGVybWluZSB3aGljaCBzb3VyY2UgaW4gc291cmNlcyB0byB1c2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIFRoZSBmdW5jdGlvbiB3aGljaCBleHRyYWN0cyB0aGUgdmFsdWUgZm9yIHRvIHRlc3QgaW4gYSBjYXNlIHN0YXRlbWVudC5cbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlcyBBIG9iamVjdCB3aGljaCBoYXMga2V5cyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjYXNlIHN0YXRlbWVudCBsYWJlbHMuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gW2Vsc2VTb3VyY2VdIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB3aWxsIGJlIHJ1biBpZiB0aGUgc291cmNlcyBhcmUgbm90IG1hdGNoZWQuIElmIHRoaXMgaXMgbm90IHByb3ZpZGVkLCBpdCBkZWZhdWx0cyB0byBSeC5PYnNlcnZhYmUuZW1wdHkgd2l0aCB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci5cbiAgICpcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggaXMgZGV0ZXJtaW5lZCBieSBhIGNhc2Ugc3RhdGVtZW50LlxuICAgKi9cbiAgT2JzZXJ2YWJsZVsnY2FzZSddID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzb3VyY2VzLCBkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzUHJvbWlzZShkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIpICYmIChkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSk7XG4gICAgICBkZWZhdWx0U291cmNlT3JTY2hlZHVsZXIgfHwgKGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlciA9IG9ic2VydmFibGVFbXB0eSgpKTtcblxuICAgICAgaXNTY2hlZHVsZXIoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyKSAmJiAoZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyID0gb2JzZXJ2YWJsZUVtcHR5KGRlZmF1bHRTb3VyY2VPclNjaGVkdWxlcikpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gc291cmNlc1tzZWxlY3RvcigpXTtcbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgfHwgZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBFeHBhbmRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEV4cGFuZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRXhwYW5kT2JzZXJ2YWJsZShzb3VyY2UsIGZuLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlKGFyZ3MsIHJlY3Vyc2UpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbMF0sIHNlbGYgPSBhcmdzWzFdO1xuICAgICAgdmFyIHdvcms7XG4gICAgICBpZiAoc3RhdGUucS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdvcmsgPSBzdGF0ZS5xLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5pc0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtMSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgc3RhdGUuZC5hZGQobTEpO1xuICAgICAgbTEuc2V0RGlzcG9zYWJsZSh3b3JrLnN1YnNjcmliZShuZXcgRXhwYW5kT2JzZXJ2ZXIoc3RhdGUsIHNlbGYsIG0xKSkpO1xuICAgICAgcmVjdXJzZShbc3RhdGUsIHNlbGZdKTtcbiAgICB9XG5cbiAgICBFeHBhbmRPYnNlcnZhYmxlLnByb3RvdHlwZS5fZW5zdXJlQWN0aXZlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICB2YXIgaXNPd25lciA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLnEubGVuZ3RoID4gMCkge1xuICAgICAgICBpc093bmVyID0gIXN0YXRlLmlzQWNxdWlyZWQ7XG4gICAgICAgIHN0YXRlLmlzQWNxdWlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaXNPd25lciAmJiBzdGF0ZS5tLnNldERpc3Bvc2FibGUodGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKFtzdGF0ZSwgdGhpc10sIHNjaGVkdWxlUmVjdXJzaXZlKSk7XG4gICAgfTtcblxuICAgIEV4cGFuZE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG0gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBkID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUobSksXG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIHE6IFtdLFxuICAgICAgICAgIG06IG0sXG4gICAgICAgICAgZDogZCxcbiAgICAgICAgICBhY3RpdmVDb3VudDogMCxcbiAgICAgICAgICBpc0FjcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICBvOiBvXG4gICAgICAgIH07XG5cbiAgICAgIHN0YXRlLnEucHVzaCh0aGlzLnNvdXJjZSk7XG4gICAgICBzdGF0ZS5hY3RpdmVDb3VudCsrO1xuICAgICAgdGhpcy5fZW5zdXJlQWN0aXZlKHN0YXRlKTtcbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXhwYW5kT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBFeHBhbmRPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFeHBhbmRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBFeHBhbmRPYnNlcnZlcihzdGF0ZSwgcGFyZW50LCBtMSkge1xuICAgICAgdGhpcy5fcyA9IHN0YXRlO1xuICAgICAgdGhpcy5fcCA9IHBhcmVudDtcbiAgICAgIHRoaXMuX20xID0gbTE7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFeHBhbmRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zLm8ub25OZXh0KHgpO1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX3AuX2ZuKSh4KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLl9zLm8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIHRoaXMuX3MucS5wdXNoKHJlc3VsdCk7XG4gICAgICB0aGlzLl9zLmFjdGl2ZUNvdW50Kys7XG4gICAgICB0aGlzLl9wLl9lbnN1cmVBY3RpdmUodGhpcy5fcyk7XG4gICAgfTtcblxuICAgIEV4cGFuZE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgRXhwYW5kT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3MuZC5yZW1vdmUodGhpcy5fbTEpO1xuICAgICAgdGhpcy5fcy5hY3RpdmVDb3VudC0tO1xuICAgICAgdGhpcy5fcy5hY3RpdmVDb3VudCA9PT0gMCAmJiB0aGlzLl9zLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV4cGFuZE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAgLyoqXG4gICAqICBFeHBhbmRzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgcmVjdXJzaXZlbHkgaW52b2tpbmcgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBwcm9kdWNlZCBlbGVtZW50LCByZXN1bHRpbmcgaW4gYW5vdGhlciBzZXF1ZW5jZSB0byB3aGljaCB0aGUgc2VsZWN0b3Igd2lsbCBiZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IGFnYWluLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHBlcmZvcm0gdGhlIGV4cGFuc2lvbi4gSWYgbm90IHByb3ZpZGVkLCB0aGlzIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHRocmVhZCBzY2hlZHVsZXIuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBwcm9kdWNlZCBieSB0aGUgcmVjdXJzaXZlIGV4cGFuc2lvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5leHBhbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRXhwYW5kT2JzZXJ2YWJsZSh0aGlzLCBzZWxlY3Rvciwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcmd1bWVudHNUb0FycmF5KCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIHZhciBGb3JrSm9pbk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZvcmtKb2luT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBGb3JrSm9pbk9ic2VydmFibGUoc291cmNlcywgY2IpIHtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgdGhpcy5fY2IgPSBjYjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEZvcmtKb2luT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAodGhpcy5fc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgZmluaXNoZWQ6IGZhbHNlLFxuICAgICAgICBoYXNSZXN1bHRzOiBuZXcgQXJyYXkoY291bnQpLFxuICAgICAgICBoYXNDb21wbGV0ZWQ6IG5ldyBBcnJheShjb3VudCksXG4gICAgICAgIHJlc3VsdHM6IG5ldyBBcnJheShjb3VudClcbiAgICAgIH07XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzW2ldO1xuICAgICAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgICAgICBzdWJzY3JpcHRpb25zLmFkZChzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGb3JrSm9pbk9ic2VydmVyKG8sIHN0YXRlLCBpLCB0aGlzLl9jYiwgc3Vic2NyaXB0aW9ucykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbnM7XG4gICAgfTtcblxuICAgIHJldHVybiBGb3JrSm9pbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRm9ya0pvaW5PYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGb3JrSm9pbk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZvcmtKb2luT2JzZXJ2ZXIobywgcywgaSwgY2IsIHN1YnMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9pID0gaTtcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICB0aGlzLl9zdWJzID0gc3VicztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEZvcmtKb2luT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF0aGlzLl9zLmZpbmlzaGVkKSB7XG4gICAgICAgIHRoaXMuX3MuaGFzUmVzdWx0c1t0aGlzLl9pXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3MucmVzdWx0c1t0aGlzLl9pXSA9IHg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEZvcmtKb2luT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3MuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgICAgdGhpcy5fc3Vicy5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIEZvcmtKb2luT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fcy5maW5pc2hlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3MuaGFzUmVzdWx0c1t0aGlzLl9pXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcy5oYXNDb21wbGV0ZWRbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3MucmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghdGhpcy5fcy5oYXNDb21wbGV0ZWRbaV0pIHsgcmV0dXJuOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcy5maW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX2NiKS5hcHBseShudWxsLCB0aGlzLl9zLnJlc3VsdHMpO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuXG4gICAgICAgIHRoaXMuX28ub25OZXh0KHJlcyk7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcmtKb2luT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gICAvKipcbiAgICogIFJ1bnMgYWxsIG9ic2VydmFibGUgc2VxdWVuY2VzIGluIHBhcmFsbGVsIGFuZCBjb2xsZWN0IHRoZWlyIGxhc3QgZWxlbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5mb3JrSm9pbihbb2JzMSwgb2JzMl0pO1xuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuZm9ya0pvaW4ob2JzMSwgb2JzMiwgLi4uKTtcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhbiBhcnJheSBjb2xsZWN0aW5nIHRoZSBsYXN0IGVsZW1lbnRzIG9mIGFsbCB0aGUgaW5wdXQgc2VxdWVuY2VzLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5mb3JrSm9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihhcmdzW2xlbiAtIDFdKSA/IGFyZ3MucG9wKCkgOiBhcmd1bWVudHNUb0FycmF5O1xuICAgIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgKGFyZ3MgPSBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV3IEZvcmtKb2luT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAgUnVucyB0d28gb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gcGFyYWxsZWwgYW5kIGNvbWJpbmVzIHRoZWlyIGxhc3QgZWxlbWVuZXRzLlxuICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHNlY29uZCBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgUmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uIHRvIGludm9rZSB3aXRoIHRoZSBsYXN0IGVsZW1lbnRzIG9mIGJvdGggc2VxdWVuY2VzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgbGFzdCBlbGVtZW50cyBvZiBib3RoIGlucHV0IHNlcXVlbmNlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5mb3JrSm9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGFyZ3NbMF0udW5zaGlmdCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5mb3JrSm9pbi5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29tb25hZGljIGJpbmQgb3BlcmF0b3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVkdWxlciBTY2hlZHVsZXIgdXNlZCB0byBleGVjdXRlIHRoZSBvcGVyYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBJbW1lZGlhdGVTY2hlZHVsZXIuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGUgY29tb25hZGljIGJpbmQgb3BlcmF0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1hbnlTZWxlY3QgPSBvYnNlcnZhYmxlUHJvdG8uZXh0ZW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBSeC5TY2hlZHVsZXIuaW1tZWRpYXRlKTtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGFpbjtcblxuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIGN1cnIgPSBuZXcgQ2hhaW5PYnNlcnZhYmxlKHgpO1xuXG4gICAgICAgICAgY2hhaW4gJiYgY2hhaW4ub25OZXh0KHgpO1xuICAgICAgICAgIGNoYWluID0gY3VycjtcblxuICAgICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgICB9KVxuICAgICAgICAudGFwKFxuICAgICAgICAgIG5vb3AsXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHsgY2hhaW4gJiYgY2hhaW4ub25FcnJvcihlKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IGNoYWluICYmIGNoYWluLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICAgKVxuICAgICAgICAub2JzZXJ2ZU9uKHNjaGVkdWxlcilcbiAgICAgICAgLm1hcChzZWxlY3Rvcik7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgQ2hhaW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDaGFpbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ2hhaW5PYnNlcnZhYmxlKGhlYWQpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICAgIHRoaXMudGFpbCA9IG5ldyBBc3luY1N1YmplY3QoKTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKENoYWluT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9ic2VydmVyLCB7XG4gICAgICBfc3Vic2NyaWJlOiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICAgIGcuYWRkKGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGUodGhpcywgZnVuY3Rpb24gKF8sIHNlbGYpIHtcbiAgICAgICAgICBvLm9uTmV4dChzZWxmLmhlYWQpO1xuICAgICAgICAgIGcuYWRkKHNlbGYudGFpbC5tZXJnZUFsbCgpLnN1YnNjcmliZShvKSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXR1cm4gZztcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uTmV4dChPYnNlcnZhYmxlLmVtcHR5KCkpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMub25OZXh0KE9ic2VydmFibGVbJ3Rocm93J10oZSkpO1xuICAgICAgfSxcbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpcy50YWlsLm9uTmV4dCh2KTtcbiAgICAgICAgdGhpcy50YWlsLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ2hhaW5PYnNlcnZhYmxlO1xuXG4gIH0oT2JzZXJ2YWJsZSkpO1xuXG4gIHZhciBTd2l0Y2hGaXJzdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN3aXRjaEZpcnN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaEZpcnN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICBnID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSxcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgaGFzQ3VycmVudDogZmFsc2UsXG4gICAgICAgICAgaXNTdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICBvOiBvLFxuICAgICAgICAgIGc6IGdcbiAgICAgICAgfTtcblxuICAgICAgZy5hZGQobSk7XG4gICAgICBtLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hGaXJzdE9ic2VydmVyKHN0YXRlKSkpO1xuICAgICAgcmV0dXJuIGc7XG4gICAgfTtcblxuICAgIHJldHVybiBTd2l0Y2hGaXJzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU3dpdGNoRmlyc3RPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hGaXJzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0T2JzZXJ2ZXIoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3MgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaEZpcnN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF0aGlzLl9zLmhhc0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5fcy5oYXNDdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNQcm9taXNlKHgpICYmICh4ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHgpKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX3MuZy5hZGQoaW5uZXIpO1xuICAgICAgICBpbm5lci5zZXREaXNwb3NhYmxlKHguc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMuX3MsIGlubmVyKSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTd2l0Y2hGaXJzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU3dpdGNoRmlyc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgIXRoaXMuX3MuaGFzQ3VycmVudCAmJiB0aGlzLl9zLmcubGVuZ3RoID09PSAxICYmIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIoc3RhdGUsIGlubmVyKSB7XG4gICAgICB0aGlzLl9zID0gc3RhdGU7XG4gICAgICB0aGlzLl9pID0gaW5uZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcy5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3MuZy5yZW1vdmUodGhpcy5faSk7XG4gICAgICB0aGlzLl9zLmhhc0N1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3MuaXNTdG9wcGVkICYmIHRoaXMuX3MuZy5sZW5ndGggPT09IDEgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTd2l0Y2hGaXJzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBleGNsdXNpdmUgd2FpdGluZyBmb3IgdGhlIGZpcnN0IHRvIGZpbmlzaCBiZWZvcmUgc3Vic2NyaWJpbmcgdG8gYW5vdGhlciBvYnNlcnZhYmxlLlxuICAgKiBPYnNlcnZhYmxlcyB0aGF0IGNvbWUgaW4gYmV0d2VlbiBzdWJzY3JpcHRpb25zIHdpbGwgYmUgZHJvcHBlZCBvbiB0aGUgZmxvb3IuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBIGV4Y2x1c2l2ZSBvYnNlcnZhYmxlIHdpdGggb25seSB0aGUgcmVzdWx0cyB0aGF0IGhhcHBlbiB3aGVuIHN1YnNjcmliZWQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3dpdGNoRmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTd2l0Y2hGaXJzdE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwRmlyc3QgPSBvYnNlcnZhYmxlUHJvdG8uZXhoYXVzdE1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5zd2l0Y2hGaXJzdCgpO1xufTtcblxub2JzZXJ2YWJsZVByb3RvLmZsYXRNYXBXaXRoTWF4Q29uY3VycmVudCA9IG9ic2VydmFibGVQcm90by5mbGF0TWFwTWF4Q29uY3VycmVudCA9IGZ1bmN0aW9uKGxpbWl0LCBzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykubWVyZ2UobGltaXQpO1xufTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVQcm90byIsInByb3RvdHlwZSIsIk9ic2VydmFibGVCYXNlIiwiQWJzdHJhY3RPYnNlcnZlciIsImludGVybmFscyIsIkZsYXRNYXBPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZUNvbmNhdCIsImNvbmNhdCIsIm9ic2VydmFibGVEZWZlciIsImRlZmVyIiwib2JzZXJ2YWJsZUVtcHR5IiwiZW1wdHkiLCJkaXNwb3NhYmxlRW1wdHkiLCJEaXNwb3NhYmxlIiwiQ29tcG9zaXRlRGlzcG9zYWJsZSIsIlNlcmlhbERpc3Bvc2FibGUiLCJTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSIsIkVudW1lcmFibGUiLCJlbnVtZXJhYmxlT2YiLCJvZiIsImN1cnJlbnRUaHJlYWRTY2hlZHVsZXIiLCJTY2hlZHVsZXIiLCJjdXJyZW50VGhyZWFkIiwiQXN5bmNTdWJqZWN0IiwiT2JzZXJ2ZXIiLCJpbmhlcml0cyIsImFkZFByb3BlcnRpZXMiLCJoZWxwZXJzIiwibm9vcCIsImlzUHJvbWlzZSIsImlzRnVuY3Rpb24iLCJpc0l0ZXJhYmxlIiwiaXNBcnJheUxpa2UiLCJpc1NjaGVkdWxlciIsIm9ic2VydmFibGVGcm9tUHJvbWlzZSIsImZyb21Qcm9taXNlIiwiZXJyb3JPYmoiLCJlIiwidHJ5Q2F0Y2hlckdlbiIsInRyeUNhdGNoVGFyZ2V0IiwidHJ5Q2F0Y2hlciIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJ5Q2F0Y2giLCJmbiIsIlR5cGVFcnJvciIsInRocm93ZXIiLCIkaXRlcmF0b3IkIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJTZXQiLCJkb25lRW51bWVyYXRvciIsImRvbmUiLCJvIiwibGVuZ3RoIiwiV2hpbGVFbnVtZXJhYmxlIiwiX19zdXBlcl9fIiwiYyIsInMiLCJuZXh0IiwiZW51bWVyYWJsZVdoaWxlIiwiY29uZGl0aW9uIiwic291cmNlIiwibGV0QmluZCIsImZ1bmMiLCJ0aGVuU291cmNlIiwiZWxzZVNvdXJjZU9yU2NoZWR1bGVyIiwibm93IiwiZm9ySW4iLCJzb3VyY2VzIiwicmVzdWx0U2VsZWN0b3IiLCJ0aGlzQXJnIiwib2JzZXJ2YWJsZVdoaWxlRG8iLCJ3aGlsZURvIiwiZG9XaGlsZSIsInNlbGVjdG9yIiwiZGVmYXVsdFNvdXJjZU9yU2NoZWR1bGVyIiwicmVzdWx0IiwiRXhwYW5kT2JzZXJ2YWJsZSIsInNjaGVkdWxlciIsIl9mbiIsIl9zY2hlZHVsZXIiLCJzY2hlZHVsZVJlY3Vyc2l2ZSIsImFyZ3MiLCJyZWN1cnNlIiwic3RhdGUiLCJ3b3JrIiwicSIsInNoaWZ0IiwiaXNBY3F1aXJlZCIsIm0xIiwiZCIsImFkZCIsInNldERpc3Bvc2FibGUiLCJzdWJzY3JpYmUiLCJFeHBhbmRPYnNlcnZlciIsIl9lbnN1cmVBY3RpdmUiLCJpc093bmVyIiwibSIsInN1YnNjcmliZUNvcmUiLCJhY3RpdmVDb3VudCIsInB1c2giLCJwYXJlbnQiLCJfcyIsIl9wIiwiX20xIiwieCIsIm9uTmV4dCIsIm9uRXJyb3IiLCJlcnJvciIsImNvbXBsZXRlZCIsInJlbW92ZSIsIm9uQ29tcGxldGVkIiwiZXhwYW5kIiwiYXJndW1lbnRzVG9BcnJheSIsImxlbiIsIkFycmF5IiwiaSIsIkZvcmtKb2luT2JzZXJ2YWJsZSIsImNiIiwiX3NvdXJjZXMiLCJfY2IiLCJjb3VudCIsImZpbmlzaGVkIiwiaGFzUmVzdWx0cyIsImhhc0NvbXBsZXRlZCIsInJlc3VsdHMiLCJzdWJzY3JpcHRpb25zIiwiRm9ya0pvaW5PYnNlcnZlciIsInN1YnMiLCJfbyIsIl9pIiwiX3N1YnMiLCJkaXNwb3NlIiwicmVzIiwiZm9ya0pvaW4iLCJwb3AiLCJpc0FycmF5IiwidW5zaGlmdCIsIm1hbnlTZWxlY3QiLCJleHRlbmQiLCJpbW1lZGlhdGUiLCJjaGFpbiIsIm1hcCIsImN1cnIiLCJDaGFpbk9ic2VydmFibGUiLCJ0YXAiLCJvYnNlcnZlT24iLCJoZWFkIiwidGFpbCIsIl9zdWJzY3JpYmUiLCJnIiwic2NoZWR1bGUiLCJfIiwibWVyZ2VBbGwiLCJ2IiwiU3dpdGNoRmlyc3RPYnNlcnZhYmxlIiwiaGFzQ3VycmVudCIsImlzU3RvcHBlZCIsIlN3aXRjaEZpcnN0T2JzZXJ2ZXIiLCJpbm5lciIsIklubmVyT2JzZXJ2ZXIiLCJzd2l0Y2hGaXJzdCIsImZsYXRNYXBGaXJzdCIsImV4aGF1c3RNYXAiLCJmbGF0TWFwV2l0aE1heENvbmN1cnJlbnQiLCJmbGF0TWFwTWF4Q29uY3VycmVudCIsImxpbWl0IiwibWVyZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.joinpatterns.js":
/*!*************************************************!*\
  !*** ./node_modules/rx/dist/rx.joinpatterns.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // Aliases\n    var Observable = Rx.Observable, observableProto = Observable.prototype, AnonymousObservable = Rx.AnonymousObservable, observableThrow = Observable.throwError, observerCreate = Rx.Observer.create, SingleAssignmentDisposable = Rx.SingleAssignmentDisposable, CompositeDisposable = Rx.CompositeDisposable, AbstractObserver = Rx.internals.AbstractObserver, noop = Rx.helpers.noop, inherits = Rx.internals.inherits, isFunction = Rx.helpers.isFunction;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    var Map = root.Map || function() {\n        function Map() {\n            this.size = 0;\n            this._values = [];\n            this._keys = [];\n        }\n        Map.prototype[\"delete\"] = function(key) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                return false;\n            }\n            this._values.splice(i, 1);\n            this._keys.splice(i, 1);\n            this.size--;\n            return true;\n        };\n        Map.prototype.get = function(key) {\n            var i = this._keys.indexOf(key);\n            return i === -1 ? undefined : this._values[i];\n        };\n        Map.prototype.set = function(key, value) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                this._keys.push(key);\n                this._values.push(value);\n                this.size++;\n            } else {\n                this._values[i] = value;\n            }\n            return this;\n        };\n        Map.prototype.forEach = function(cb, thisArg) {\n            for(var i = 0; i < this.size; i++){\n                cb.call(thisArg, this._values[i], this._keys[i]);\n            }\n        };\n        return Map;\n    }();\n    /**\n   * @constructor\n   * Represents a join pattern over observable sequences.\n   */ function Pattern(patterns) {\n        this.patterns = patterns;\n    }\n    /**\n   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.\n   *  @param other Observable sequence to match in addition to the current pattern.\n   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.\n   */ Pattern.prototype.and = function(other) {\n        return new Pattern(this.patterns.concat(other));\n    };\n    /**\n   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.\n   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.\n   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n   */ Pattern.prototype.thenDo = function(selector) {\n        return new Plan(this, selector);\n    };\n    function Plan(expression, selector) {\n        this.expression = expression;\n        this.selector = selector;\n    }\n    function handleOnError(o) {\n        return function(e) {\n            o.onError(e);\n        };\n    }\n    function handleOnNext(self1, observer) {\n        return function onNext() {\n            var result = tryCatch(self1.selector).apply(self1, arguments);\n            if (result === errorObj) {\n                return observer.onError(result.e);\n            }\n            observer.onNext(result);\n        };\n    }\n    Plan.prototype.activate = function(externalSubscriptions, observer, deactivate) {\n        var joinObservers = [], errHandler = handleOnError(observer);\n        for(var i = 0, len = this.expression.patterns.length; i < len; i++){\n            joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], errHandler));\n        }\n        var activePlan = new ActivePlan(joinObservers, handleOnNext(this, observer), function() {\n            for(var j = 0, jlen = joinObservers.length; j < jlen; j++){\n                joinObservers[j].removeActivePlan(activePlan);\n            }\n            deactivate(activePlan);\n        });\n        for(i = 0, len = joinObservers.length; i < len; i++){\n            joinObservers[i].addActivePlan(activePlan);\n        }\n        return activePlan;\n    };\n    function planCreateObserver(externalSubscriptions, observable, onError) {\n        var entry = externalSubscriptions.get(observable);\n        if (!entry) {\n            var observer = new JoinObserver(observable, onError);\n            externalSubscriptions.set(observable, observer);\n            return observer;\n        }\n        return entry;\n    }\n    function ActivePlan(joinObserverArray, onNext, onCompleted) {\n        this.joinObserverArray = joinObserverArray;\n        this.onNext = onNext;\n        this.onCompleted = onCompleted;\n        this.joinObservers = new Map();\n        for(var i = 0, len = this.joinObserverArray.length; i < len; i++){\n            var joinObserver = this.joinObserverArray[i];\n            this.joinObservers.set(joinObserver, joinObserver);\n        }\n    }\n    ActivePlan.prototype.dequeue = function() {\n        this.joinObservers.forEach(function(v) {\n            v.queue.shift();\n        });\n    };\n    ActivePlan.prototype.match = function() {\n        var i, len, hasValues = true;\n        for(i = 0, len = this.joinObserverArray.length; i < len; i++){\n            if (this.joinObserverArray[i].queue.length === 0) {\n                hasValues = false;\n                break;\n            }\n        }\n        if (hasValues) {\n            var firstValues = [], isCompleted = false;\n            for(i = 0, len = this.joinObserverArray.length; i < len; i++){\n                firstValues.push(this.joinObserverArray[i].queue[0]);\n                this.joinObserverArray[i].queue[0].kind === \"C\" && (isCompleted = true);\n            }\n            if (isCompleted) {\n                this.onCompleted();\n            } else {\n                this.dequeue();\n                var values = [];\n                for(i = 0, len = firstValues.length; i < firstValues.length; i++){\n                    values.push(firstValues[i].value);\n                }\n                this.onNext.apply(this, values);\n            }\n        }\n    };\n    var JoinObserver = function(__super__) {\n        inherits(JoinObserver, __super__);\n        function JoinObserver(source, onError) {\n            __super__.call(this);\n            this.source = source;\n            this.onError = onError;\n            this.queue = [];\n            this.activePlans = [];\n            this.subscription = new SingleAssignmentDisposable();\n            this.isDisposed = false;\n        }\n        var JoinObserverPrototype = JoinObserver.prototype;\n        JoinObserverPrototype.next = function(notification) {\n            if (!this.isDisposed) {\n                if (notification.kind === \"E\") {\n                    return this.onError(notification.error);\n                }\n                this.queue.push(notification);\n                var activePlans = this.activePlans.slice(0);\n                for(var i = 0, len = activePlans.length; i < len; i++){\n                    activePlans[i].match();\n                }\n            }\n        };\n        JoinObserverPrototype.error = noop;\n        JoinObserverPrototype.completed = noop;\n        JoinObserverPrototype.addActivePlan = function(activePlan) {\n            this.activePlans.push(activePlan);\n        };\n        JoinObserverPrototype.subscribe = function() {\n            this.subscription.setDisposable(this.source.materialize().subscribe(this));\n        };\n        JoinObserverPrototype.removeActivePlan = function(activePlan) {\n            this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);\n            this.activePlans.length === 0 && this.dispose();\n        };\n        JoinObserverPrototype.dispose = function() {\n            __super__.prototype.dispose.call(this);\n            if (!this.isDisposed) {\n                this.isDisposed = true;\n                this.subscription.dispose();\n            }\n        };\n        return JoinObserver;\n    }(AbstractObserver);\n    /**\n   *  Creates a pattern that matches when both observable sequences have an available value.\n   *\n   *  @param right Observable sequence to match with the current sequence.\n   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.\n   */ observableProto.and = function(right) {\n        return new Pattern([\n            this,\n            right\n        ]);\n    };\n    /**\n   *  Matches when the observable sequence has an available value and projects the value.\n   *\n   *  @param {Function} selector Selector that will be invoked for values in the source sequence.\n   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n   */ observableProto.thenDo = function(selector) {\n        return new Pattern([\n            this\n        ]).thenDo(selector);\n    };\n    /**\n   *  Joins together the results from several patterns.\n   *\n   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.\n   *  @returns {Observable} Observable sequence with the results form matching several patterns.\n   */ Observable.when = function() {\n        var len = arguments.length, plans;\n        if (Array.isArray(arguments[0])) {\n            plans = arguments[0];\n        } else {\n            plans = new Array(len);\n            for(var i = 0; i < len; i++){\n                plans[i] = arguments[i];\n            }\n        }\n        return new AnonymousObservable(function(o) {\n            var activePlans = [], externalSubscriptions = new Map();\n            var outObserver = observerCreate(function(x) {\n                o.onNext(x);\n            }, function(err) {\n                externalSubscriptions.forEach(function(v) {\n                    v.onError(err);\n                });\n                o.onError(err);\n            }, function(x) {\n                o.onCompleted();\n            });\n            try {\n                for(var i = 0, len = plans.length; i < len; i++){\n                    activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function(activePlan) {\n                        var idx = activePlans.indexOf(activePlan);\n                        activePlans.splice(idx, 1);\n                        activePlans.length === 0 && o.onCompleted();\n                    }));\n                }\n            } catch (e) {\n                return observableThrow(e).subscribe(o);\n            }\n            var group = new CompositeDisposable();\n            externalSubscriptions.forEach(function(joinObserver) {\n                joinObserver.subscribe();\n                group.add(joinObserver);\n            });\n            return group;\n        });\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5qb2lucGF0dGVybnMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLDZLQUE2Rzs7QUFFM0csVUFBVUEsT0FBTztJQUNqQixJQUFJQyxjQUFjO1FBQ2hCLFlBQVk7UUFDWixVQUFVO0lBQ1o7SUFFQSxTQUFTQyxZQUFZQyxLQUFLO1FBQ3hCLE9BQU8sU0FBVUEsTUFBTUMsTUFBTSxLQUFLQSxTQUFVRCxRQUFRO0lBQ3REO0lBRUEsSUFBSUUsY0FBYyxXQUFZLENBQUMsT0FBT0MsUUFBUSxJQUFJQSxXQUFXLENBQUNBLFFBQVFDLFFBQVEsR0FBSUQsVUFBVTtJQUM1RixJQUFJRSxhQUFhLFdBQVksQ0FBQyxRQUFhQyxDQUFDLElBQUlBLFVBQVUsQ0FBQ0EsT0FBT0YsUUFBUSxHQUFJRSxTQUFTO0lBQ3ZGLElBQUlDLGFBQWFSLFlBQVlHLGVBQWVHLGNBQWMsT0FBT0csV0FBVyxZQUFZQTtJQUN4RixJQUFJQyxXQUFXVixZQUFZRCxXQUFXLENBQUMsT0FBT1ksS0FBSyxJQUFJQTtJQUN2RCxJQUFJQyxhQUFhWixZQUFZRCxXQUFXLENBQUMsWUFBYyxJQUFJYztJQUMzRCxJQUFJQyxnQkFBZ0IsY0FBZVIsV0FBV0YsT0FBTyxLQUFLRCxjQUFlQSxjQUFjO0lBQ3ZGLElBQUlZLGFBQWFmLFlBQVlELFdBQVcsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLElBQUk7SUFDN0QsSUFBSWlCLE9BQU9SLGNBQWUsZUFBaUJPLENBQUFBLGNBQWNBLFdBQVdGLE1BQU0sS0FBTUQsY0FBZUYsWUFBWUssY0FBY0UsU0FBUztJQUVsSSw4QkFBOEI7SUFDOUIsSUFBSSxJQUEwQyxFQUFFO1FBQzlDQyxpQ0FBTztZQUFDO1NBQU8sbUNBQUUsU0FBVUUsRUFBRSxFQUFFaEIsUUFBTztZQUNwQyxPQUFPTixRQUFRa0IsTUFBTVosVUFBU2dCO1FBQ2hDLENBQUM7QUFBQSxrR0FBQztJQUNKLE9BQU8sRUFJTjtBQUNILEdBQUVFLElBQUksQ0FB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STZDLE1BQU1yQixZQUFZeEQsT0FBTyxDQUFDZ0M7d0JBQzlCd0IsWUFBWXZELE1BQU0sQ0FBQzRFLEtBQUs7d0JBQ3hCckIsWUFBWTFCLE1BQU0sS0FBSyxLQUFLWixFQUFFd0IsV0FBVztvQkFDM0M7Z0JBQ0Y7WUFDRixFQUFFLE9BQU8xRCxHQUFHO2dCQUNWLE9BQU9kLGdCQUFnQmMsR0FBR2lGLFNBQVMsQ0FBQy9DO1lBQ3RDO1lBQ0EsSUFBSTRELFFBQVEsSUFBSXRHO1lBQ2hCaUQsc0JBQXNCcEIsT0FBTyxDQUFDLFNBQVVzQyxZQUFZO2dCQUNsREEsYUFBYXNCLFNBQVM7Z0JBQ3RCYSxNQUFNQyxHQUFHLENBQUNwQztZQUNaO1lBRUEsT0FBT21DO1FBQ1Q7SUFDRjtJQUVBLE9BQU9ySDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9kaXN0L3J4LmpvaW5wYXR0ZXJucy5qcz9jOWZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LCBBbGwgcmlnaHRzIHJlc2VydmVkLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpID8gZXhwb3J0cyA6IG51bGw7XG4gIHZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKSA/IG1vZHVsZSA6IG51bGw7XG4gIHZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuICB2YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG4gIHZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSAoZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSA/IGZyZWVFeHBvcnRzIDogbnVsbDtcbiAgdmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8vIEJlY2F1c2Ugb2YgYnVpbGQgb3B0aW1pemVyc1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnLi9yeCddLCBmdW5jdGlvbiAoUngsIGV4cG9ydHMpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIFJ4KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QsIG1vZHVsZS5leHBvcnRzLCByZXF1aXJlKCcuL3J4JykpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUnggPSBmYWN0b3J5KHJvb3QsIHt9LCByb290LlJ4KTtcbiAgfVxufS5jYWxsKHRoaXMsIGZ1bmN0aW9uIChyb290LCBleHAsIFJ4LCB1bmRlZmluZWQpIHtcblxuICAvLyBBbGlhc2VzXG4gIHZhciBPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZhYmxlUHJvdG8gPSBPYnNlcnZhYmxlLnByb3RvdHlwZSxcbiAgICBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZhYmxlVGhyb3cgPSBPYnNlcnZhYmxlLnRocm93RXJyb3IsXG4gICAgb2JzZXJ2ZXJDcmVhdGUgPSBSeC5PYnNlcnZlci5jcmVhdGUsXG4gICAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUgPSBSeC5TaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSxcbiAgICBDb21wb3NpdGVEaXNwb3NhYmxlID0gUnguQ29tcG9zaXRlRGlzcG9zYWJsZSxcbiAgICBBYnN0cmFjdE9ic2VydmVyID0gUnguaW50ZXJuYWxzLkFic3RyYWN0T2JzZXJ2ZXIsXG4gICAgbm9vcCA9IFJ4LmhlbHBlcnMubm9vcCxcbiAgICBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyxcbiAgICBpc0Z1bmN0aW9uID0gUnguaGVscGVycy5pc0Z1bmN0aW9uO1xuXG4gIHZhciBlcnJvck9iaiA9IHtlOiB7fX07XG4gIFxuICBmdW5jdGlvbiB0cnlDYXRjaGVyR2VuKHRyeUNhdGNoVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyeUNhdGNoID0gUnguaW50ZXJuYWxzLnRyeUNhdGNoID0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZuIG11c3QgYmUgYSBmdW5jdGlvbicpOyB9XG4gICAgcmV0dXJuIHRyeUNhdGNoZXJHZW4oZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgIHRocm93IGU7XG4gIH1cblxuICB2YXIgTWFwID0gcm9vdC5NYXAgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuXG4gICAgTWFwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgdGhpcy5fdmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5zaXplLS07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgcmV0dXJuIGkgPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5fdmFsdWVzW2ldO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5fdmFsdWVzW2ldLCB0aGlzLl9rZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcDtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIFJlcHJlc2VudHMgYSBqb2luIHBhdHRlcm4gb3ZlciBvYnNlcnZhYmxlIHNlcXVlbmNlcy5cbiAgICovXG4gIGZ1bmN0aW9uIFBhdHRlcm4ocGF0dGVybnMpIHtcbiAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gIH1cblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBwbGFuIG1hdGNoZXMgYW5kIHdoZW4gdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXMgYW4gYXZhaWxhYmxlIHZhbHVlLlxuICAgKiAgQHBhcmFtIG90aGVyIE9ic2VydmFibGUgc2VxdWVuY2UgdG8gbWF0Y2ggaW4gYWRkaXRpb24gdG8gdGhlIGN1cnJlbnQgcGF0dGVybi5cbiAgICogIEByZXR1cm4ge1BhdHRlcm59IFBhdHRlcm4gb2JqZWN0IHRoYXQgbWF0Y2hlcyB3aGVuIGFsbCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybiBoYXZlIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICovXG4gIFBhdHRlcm4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBuZXcgUGF0dGVybih0aGlzLnBhdHRlcm5zLmNvbmNhdChvdGhlcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgTWF0Y2hlcyB3aGVuIGFsbCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybiAoc3BlY2lmaWVkIHVzaW5nIGEgY2hhaW4gb2YgYW5kIG9wZXJhdG9ycykgaGF2ZSBhbiBhdmFpbGFibGUgdmFsdWUgYW5kIHByb2plY3RzIHRoZSB2YWx1ZXMuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aXRoIGF2YWlsYWJsZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHNlcXVlbmNlcywgaW4gdGhlIHNhbWUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlcyBpbiB0aGUgcGF0dGVybi5cbiAgICogIEByZXR1cm4ge1BsYW59IFBsYW4gdGhhdCBwcm9kdWNlcyB0aGUgcHJvamVjdGVkIHZhbHVlcywgdG8gYmUgZmVkICh3aXRoIG90aGVyIHBsYW5zKSB0byB0aGUgd2hlbiBvcGVyYXRvci5cbiAgICovXG4gIFBhdHRlcm4ucHJvdG90eXBlLnRoZW5EbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgUGxhbih0aGlzLCBzZWxlY3Rvcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gUGxhbihleHByZXNzaW9uLCBzZWxlY3Rvcikge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT25FcnJvcihvKSB7IHJldHVybiBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH07IH1cbiAgZnVuY3Rpb24gaGFuZGxlT25OZXh0KHNlbGYsIG9ic2VydmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTmV4dCAoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goc2VsZi5zZWxlY3RvcikuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvYnNlcnZlci5vbkVycm9yKHJlc3VsdC5lKTsgfVxuICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgfVxuXG4gIFBsYW4ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGV4dGVybmFsU3Vic2NyaXB0aW9ucywgb2JzZXJ2ZXIsIGRlYWN0aXZhdGUpIHtcbiAgICB2YXIgam9pbk9ic2VydmVycyA9IFtdLCBlcnJIYW5kbGVyID0gaGFuZGxlT25FcnJvcihvYnNlcnZlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZXhwcmVzc2lvbi5wYXR0ZXJucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgam9pbk9ic2VydmVycy5wdXNoKHBsYW5DcmVhdGVPYnNlcnZlcihleHRlcm5hbFN1YnNjcmlwdGlvbnMsIHRoaXMuZXhwcmVzc2lvbi5wYXR0ZXJuc1tpXSwgZXJySGFuZGxlcikpO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlUGxhbiA9IG5ldyBBY3RpdmVQbGFuKGpvaW5PYnNlcnZlcnMsIGhhbmRsZU9uTmV4dCh0aGlzLCBvYnNlcnZlciksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gam9pbk9ic2VydmVycy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgam9pbk9ic2VydmVyc1tqXS5yZW1vdmVBY3RpdmVQbGFuKGFjdGl2ZVBsYW4pO1xuICAgICAgfVxuICAgICAgZGVhY3RpdmF0ZShhY3RpdmVQbGFuKTtcbiAgICB9KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBqb2luT2JzZXJ2ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBqb2luT2JzZXJ2ZXJzW2ldLmFkZEFjdGl2ZVBsYW4oYWN0aXZlUGxhbik7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVQbGFuO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBsYW5DcmVhdGVPYnNlcnZlcihleHRlcm5hbFN1YnNjcmlwdGlvbnMsIG9ic2VydmFibGUsIG9uRXJyb3IpIHtcbiAgICB2YXIgZW50cnkgPSBleHRlcm5hbFN1YnNjcmlwdGlvbnMuZ2V0KG9ic2VydmFibGUpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBKb2luT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgb25FcnJvcik7XG4gICAgICBleHRlcm5hbFN1YnNjcmlwdGlvbnMuc2V0KG9ic2VydmFibGUsIG9ic2VydmVyKTtcbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgZnVuY3Rpb24gQWN0aXZlUGxhbihqb2luT2JzZXJ2ZXJBcnJheSwgb25OZXh0LCBvbkNvbXBsZXRlZCkge1xuICAgIHRoaXMuam9pbk9ic2VydmVyQXJyYXkgPSBqb2luT2JzZXJ2ZXJBcnJheTtcbiAgICB0aGlzLm9uTmV4dCA9IG9uTmV4dDtcbiAgICB0aGlzLm9uQ29tcGxldGVkID0gb25Db21wbGV0ZWQ7XG4gICAgdGhpcy5qb2luT2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmpvaW5PYnNlcnZlckFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgam9pbk9ic2VydmVyID0gdGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXTtcbiAgICAgIHRoaXMuam9pbk9ic2VydmVycy5zZXQoam9pbk9ic2VydmVyLCBqb2luT2JzZXJ2ZXIpO1xuICAgIH1cbiAgfVxuXG4gIEFjdGl2ZVBsYW4ucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5qb2luT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5xdWV1ZS5zaGlmdCgpOyB9KTtcbiAgfTtcblxuICBBY3RpdmVQbGFuLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSwgbGVuLCBoYXNWYWx1ZXMgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuam9pbk9ic2VydmVyQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmpvaW5PYnNlcnZlckFycmF5W2ldLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNWYWx1ZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNWYWx1ZXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbHVlcyA9IFtdLFxuICAgICAgICAgIGlzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmpvaW5PYnNlcnZlckFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZpcnN0VmFsdWVzLnB1c2godGhpcy5qb2luT2JzZXJ2ZXJBcnJheVtpXS5xdWV1ZVswXSk7XG4gICAgICAgIHRoaXMuam9pbk9ic2VydmVyQXJyYXlbaV0ucXVldWVbMF0ua2luZCA9PT0gJ0MnICYmIChpc0NvbXBsZXRlZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZpcnN0VmFsdWVzLmxlbmd0aDsgaSA8IGZpcnN0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2goZmlyc3RWYWx1ZXNbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25OZXh0LmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBKb2luT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEpvaW5PYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIEpvaW5PYnNlcnZlcihzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgdGhpcy5hY3RpdmVQbGFucyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBKb2luT2JzZXJ2ZXJQcm90b3R5cGUgPSBKb2luT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLmtpbmQgPT09ICdFJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3Iobm90aWZpY2F0aW9uLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobm90aWZpY2F0aW9uKTtcbiAgICAgICAgdmFyIGFjdGl2ZVBsYW5zID0gdGhpcy5hY3RpdmVQbGFucy5zbGljZSgwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGl2ZVBsYW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYWN0aXZlUGxhbnNbaV0ubWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuZXJyb3IgPSBub29wO1xuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5jb21wbGV0ZWQgPSBub29wO1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmFkZEFjdGl2ZVBsYW4gPSBmdW5jdGlvbiAoYWN0aXZlUGxhbikge1xuICAgICAgdGhpcy5hY3RpdmVQbGFucy5wdXNoKGFjdGl2ZVBsYW4pO1xuICAgIH07XG5cbiAgICBKb2luT2JzZXJ2ZXJQcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5tYXRlcmlhbGl6ZSgpLnN1YnNjcmliZSh0aGlzKSk7XG4gICAgfTtcblxuICAgIEpvaW5PYnNlcnZlclByb3RvdHlwZS5yZW1vdmVBY3RpdmVQbGFuID0gZnVuY3Rpb24gKGFjdGl2ZVBsYW4pIHtcbiAgICAgIHRoaXMuYWN0aXZlUGxhbnMuc3BsaWNlKHRoaXMuYWN0aXZlUGxhbnMuaW5kZXhPZihhY3RpdmVQbGFuKSwgMSk7XG4gICAgICB0aGlzLmFjdGl2ZVBsYW5zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgSm9pbk9ic2VydmVyUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEpvaW5PYnNlcnZlcjtcbiAgfSAoQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHdoZW4gYm90aCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBoYXZlIGFuIGF2YWlsYWJsZSB2YWx1ZS5cbiAgICpcbiAgICogIEBwYXJhbSByaWdodCBPYnNlcnZhYmxlIHNlcXVlbmNlIHRvIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgc2VxdWVuY2UuXG4gICAqICBAcmV0dXJuIHtQYXR0ZXJufSBQYXR0ZXJuIG9iamVjdCB0aGF0IG1hdGNoZXMgd2hlbiBib3RoIG9ic2VydmFibGUgc2VxdWVuY2VzIGhhdmUgYW4gYXZhaWxhYmxlIHZhbHVlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmFuZCA9IGZ1bmN0aW9uIChyaWdodCkge1xuICAgIHJldHVybiBuZXcgUGF0dGVybihbdGhpcywgcmlnaHRdKTtcbiAgfTtcblxuICAvKipcbiAgICogIE1hdGNoZXMgd2hlbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBoYXMgYW4gYXZhaWxhYmxlIHZhbHVlIGFuZCBwcm9qZWN0cyB0aGUgdmFsdWUuXG4gICAqXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciBTZWxlY3RvciB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgdmFsdWVzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqICBAcmV0dXJucyB7UGxhbn0gUGxhbiB0aGF0IHByb2R1Y2VzIHRoZSBwcm9qZWN0ZWQgdmFsdWVzLCB0byBiZSBmZWQgKHdpdGggb3RoZXIgcGxhbnMpIHRvIHRoZSB3aGVuIG9wZXJhdG9yLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRoZW5EbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgUGF0dGVybihbdGhpc10pLnRoZW5EbyhzZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICBKb2lucyB0b2dldGhlciB0aGUgcmVzdWx0cyBmcm9tIHNldmVyYWwgcGF0dGVybnMuXG4gICAqXG4gICAqICBAcGFyYW0gcGxhbnMgQSBzZXJpZXMgb2YgcGxhbnMgKHNwZWNpZmllZCBhcyBhbiBBcnJheSBvZiBhcyBhIHNlcmllcyBvZiBhcmd1bWVudHMpIGNyZWF0ZWQgYnkgdXNlIG9mIHRoZSBUaGVuIG9wZXJhdG9yIG9uIHBhdHRlcm5zLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IE9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aGUgcmVzdWx0cyBmb3JtIG1hdGNoaW5nIHNldmVyYWwgcGF0dGVybnMuXG4gICAqL1xuICBPYnNlcnZhYmxlLndoZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsYW5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHBsYW5zID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGFucyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHBsYW5zW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFjdGl2ZVBsYW5zID0gW10sXG4gICAgICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIG91dE9ic2VydmVyID0gb2JzZXJ2ZXJDcmVhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7IG8ub25OZXh0KHgpOyB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgdi5vbkVycm9yKGVycik7IH0pO1xuICAgICAgICAgIG8ub25FcnJvcihlcnIpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoeCkgeyBvLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGxhbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBhY3RpdmVQbGFucy5wdXNoKHBsYW5zW2ldLmFjdGl2YXRlKGV4dGVybmFsU3Vic2NyaXB0aW9ucywgb3V0T2JzZXJ2ZXIsIGZ1bmN0aW9uIChhY3RpdmVQbGFuKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gYWN0aXZlUGxhbnMuaW5kZXhPZihhY3RpdmVQbGFuKTtcbiAgICAgICAgICAgIGFjdGl2ZVBsYW5zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgYWN0aXZlUGxhbnMubGVuZ3RoID09PSAwICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVUaHJvdyhlKS5zdWJzY3JpYmUobyk7XG4gICAgICB9XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgZXh0ZXJuYWxTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGpvaW5PYnNlcnZlcikge1xuICAgICAgICBqb2luT2JzZXJ2ZXIuc3Vic2NyaWJlKCk7XG4gICAgICAgIGdyb3VwLmFkZChqb2luT2JzZXJ2ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVQcm90byIsInByb3RvdHlwZSIsIkFub255bW91c09ic2VydmFibGUiLCJvYnNlcnZhYmxlVGhyb3ciLCJ0aHJvd0Vycm9yIiwib2JzZXJ2ZXJDcmVhdGUiLCJPYnNlcnZlciIsImNyZWF0ZSIsIlNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlIiwiQ29tcG9zaXRlRGlzcG9zYWJsZSIsIkFic3RyYWN0T2JzZXJ2ZXIiLCJpbnRlcm5hbHMiLCJub29wIiwiaGVscGVycyIsImluaGVyaXRzIiwiaXNGdW5jdGlvbiIsImVycm9yT2JqIiwiZSIsInRyeUNhdGNoZXJHZW4iLCJ0cnlDYXRjaFRhcmdldCIsInRyeUNhdGNoZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyeUNhdGNoIiwiZm4iLCJUeXBlRXJyb3IiLCJ0aHJvd2VyIiwiTWFwIiwic2l6ZSIsIl92YWx1ZXMiLCJfa2V5cyIsImtleSIsImkiLCJpbmRleE9mIiwic3BsaWNlIiwiZ2V0Iiwic2V0IiwicHVzaCIsImZvckVhY2giLCJjYiIsInRoaXNBcmciLCJQYXR0ZXJuIiwicGF0dGVybnMiLCJhbmQiLCJvdGhlciIsImNvbmNhdCIsInRoZW5EbyIsInNlbGVjdG9yIiwiUGxhbiIsImV4cHJlc3Npb24iLCJoYW5kbGVPbkVycm9yIiwibyIsIm9uRXJyb3IiLCJoYW5kbGVPbk5leHQiLCJvYnNlcnZlciIsIm9uTmV4dCIsInJlc3VsdCIsImFjdGl2YXRlIiwiZXh0ZXJuYWxTdWJzY3JpcHRpb25zIiwiZGVhY3RpdmF0ZSIsImpvaW5PYnNlcnZlcnMiLCJlcnJIYW5kbGVyIiwibGVuIiwibGVuZ3RoIiwicGxhbkNyZWF0ZU9ic2VydmVyIiwiYWN0aXZlUGxhbiIsIkFjdGl2ZVBsYW4iLCJqIiwiamxlbiIsInJlbW92ZUFjdGl2ZVBsYW4iLCJhZGRBY3RpdmVQbGFuIiwib2JzZXJ2YWJsZSIsImVudHJ5IiwiSm9pbk9ic2VydmVyIiwiam9pbk9ic2VydmVyQXJyYXkiLCJvbkNvbXBsZXRlZCIsImpvaW5PYnNlcnZlciIsImRlcXVldWUiLCJ2IiwicXVldWUiLCJzaGlmdCIsIm1hdGNoIiwiaGFzVmFsdWVzIiwiZmlyc3RWYWx1ZXMiLCJpc0NvbXBsZXRlZCIsImtpbmQiLCJ2YWx1ZXMiLCJfX3N1cGVyX18iLCJzb3VyY2UiLCJhY3RpdmVQbGFucyIsInN1YnNjcmlwdGlvbiIsImlzRGlzcG9zZWQiLCJKb2luT2JzZXJ2ZXJQcm90b3R5cGUiLCJuZXh0Iiwibm90aWZpY2F0aW9uIiwiZXJyb3IiLCJzbGljZSIsImNvbXBsZXRlZCIsInN1YnNjcmliZSIsInNldERpc3Bvc2FibGUiLCJtYXRlcmlhbGl6ZSIsImRpc3Bvc2UiLCJyaWdodCIsIndoZW4iLCJwbGFucyIsIkFycmF5IiwiaXNBcnJheSIsIm91dE9ic2VydmVyIiwieCIsImVyciIsImlkeCIsImdyb3VwIiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.joinpatterns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.js":
/*!************************************!*\
  !*** ./node_modules/rx/dist/rx.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n;\n(function(undefined) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    var Rx = {\n        internals: {},\n        config: {\n            Promise: root.Promise\n        },\n        helpers: {}\n    };\n    // Defaults\n    var noop = Rx.helpers.noop = function() {}, identity = Rx.helpers.identity = function(x) {\n        return x;\n    }, defaultNow = Rx.helpers.defaultNow = Date.now, defaultComparer = Rx.helpers.defaultComparer = function(x, y) {\n        return isEqual(x, y);\n    }, defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {\n        return x > y ? 1 : x < y ? -1 : 0;\n    }, defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {\n        return x.toString();\n    }, defaultError = Rx.helpers.defaultError = function(err) {\n        throw err;\n    }, isPromise = Rx.helpers.isPromise = function(p) {\n        return !!p && typeof p.subscribe !== \"function\" && typeof p.then === \"function\";\n    }, isFunction = Rx.helpers.isFunction = function() {\n        var isFn = function(value) {\n            return typeof value == \"function\" || false;\n        };\n        // fallback for older versions of Chrome and Safari\n        if (isFn(/x/)) {\n            isFn = function(value) {\n                return typeof value == \"function\" && toString.call(value) == \"[object Function]\";\n            };\n        }\n        return isFn;\n    }();\n    function cloneArray(arr) {\n        for(var a = [], i = 0, len = arr.length; i < len; i++){\n            a.push(arr[i]);\n        }\n        return a;\n    }\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    Rx.config.longStackSupport = false;\n    var hasStacks = false, stacks = tryCatch(function() {\n        throw new Error();\n    })();\n    hasStacks = !!stacks.e && !!stacks.e.stack;\n    // All code after this point will be filtered from stack traces reported by RxJS\n    var rStartingLine = captureLine(), rFileName;\n    var STACK_JUMP_SEPARATOR = \"From previous event:\";\n    function makeStackTraceLong(error, observable) {\n        // If possible, transform the error stack trace by removing Node and RxJS\n        // cruft, then concatenating with the stack trace of `observable`.\n        if (hasStacks && observable.stack && typeof error === \"object\" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {\n            var stacks = [];\n            for(var o = observable; !!o; o = o.source){\n                if (o.stack) {\n                    stacks.unshift(o.stack);\n                }\n            }\n            stacks.unshift(error.stack);\n            var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n            error.stack = filterStackString(concatedStacks);\n        }\n    }\n    function filterStackString(stackString) {\n        var lines = stackString.split(\"\\n\"), desiredLines = [];\n        for(var i = 0, len = lines.length; i < len; i++){\n            var line = lines[i];\n            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n                desiredLines.push(line);\n            }\n        }\n        return desiredLines.join(\"\\n\");\n    }\n    function isInternalFrame(stackLine) {\n        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n        if (!fileNameAndLineNumber) {\n            return false;\n        }\n        var fileName = fileNameAndLineNumber[0], lineNumber = fileNameAndLineNumber[1];\n        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;\n    }\n    function isNodeFrame(stackLine) {\n        return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n    }\n    function captureLine() {\n        if (!hasStacks) {\n            return;\n        }\n        try {\n            throw new Error();\n        } catch (e) {\n            var lines = e.stack.split(\"\\n\");\n            var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n            if (!fileNameAndLineNumber) {\n                return;\n            }\n            rFileName = fileNameAndLineNumber[0];\n            return fileNameAndLineNumber[1];\n        }\n    }\n    function getFileNameAndLineNumber(stackLine) {\n        // Named functions: 'at functionName (filename:lineNumber:columnNumber)'\n        var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n        if (attempt1) {\n            return [\n                attempt1[1],\n                Number(attempt1[2])\n            ];\n        }\n        // Anonymous functions: 'at filename:lineNumber:columnNumber'\n        var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n        if (attempt2) {\n            return [\n                attempt2[1],\n                Number(attempt2[2])\n            ];\n        }\n        // Firefox style: 'function@filename:lineNumber or @filename:lineNumber'\n        var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n        if (attempt3) {\n            return [\n                attempt3[1],\n                Number(attempt3[2])\n            ];\n        }\n    }\n    var EmptyError = Rx.EmptyError = function() {\n        this.message = \"Sequence contains no elements.\";\n        Error.call(this);\n    };\n    EmptyError.prototype = Object.create(Error.prototype);\n    EmptyError.prototype.name = \"EmptyError\";\n    var ObjectDisposedError = Rx.ObjectDisposedError = function() {\n        this.message = \"Object has been disposed\";\n        Error.call(this);\n    };\n    ObjectDisposedError.prototype = Object.create(Error.prototype);\n    ObjectDisposedError.prototype.name = \"ObjectDisposedError\";\n    var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {\n        this.message = \"Argument out of range\";\n        Error.call(this);\n    };\n    ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);\n    ArgumentOutOfRangeError.prototype.name = \"ArgumentOutOfRangeError\";\n    var NotSupportedError = Rx.NotSupportedError = function(message) {\n        this.message = message || \"This operation is not supported\";\n        Error.call(this);\n    };\n    NotSupportedError.prototype = Object.create(Error.prototype);\n    NotSupportedError.prototype.name = \"NotSupportedError\";\n    var NotImplementedError = Rx.NotImplementedError = function(message) {\n        this.message = message || \"This operation is not implemented\";\n        Error.call(this);\n    };\n    NotImplementedError.prototype = Object.create(Error.prototype);\n    NotImplementedError.prototype.name = \"NotImplementedError\";\n    var notImplemented = Rx.helpers.notImplemented = function() {\n        throw new NotImplementedError();\n    };\n    var notSupported = Rx.helpers.notSupported = function() {\n        throw new NotSupportedError();\n    };\n    // Shim in iterator support\n    var $iterator$ = typeof Symbol === \"function\" && Symbol.iterator || \"_es6shim_iterator_\";\n    // Bug for mozilla version\n    if (root.Set && typeof new root.Set()[\"@@iterator\"] === \"function\") {\n        $iterator$ = \"@@iterator\";\n    }\n    var doneEnumerator = Rx.doneEnumerator = {\n        done: true,\n        value: undefined\n    };\n    var isIterable = Rx.helpers.isIterable = function(o) {\n        return o && o[$iterator$] !== undefined;\n    };\n    var isArrayLike = Rx.helpers.isArrayLike = function(o) {\n        return o && o.length !== undefined;\n    };\n    Rx.helpers.iterator = $iterator$;\n    var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {\n        if (typeof thisArg === \"undefined\") {\n            return func;\n        }\n        switch(argCount){\n            case 0:\n                return function() {\n                    return func.call(thisArg);\n                };\n            case 1:\n                return function(arg) {\n                    return func.call(thisArg, arg);\n                };\n            case 2:\n                return function(value, index) {\n                    return func.call(thisArg, value, index);\n                };\n            case 3:\n                return function(value, index, collection) {\n                    return func.call(thisArg, value, index, collection);\n                };\n        }\n        return function() {\n            return func.apply(thisArg, arguments);\n        };\n    };\n    /** Used to determine if values are of the language type Object */ var dontEnums = [\n        \"toString\",\n        \"toLocaleString\",\n        \"valueOf\",\n        \"hasOwnProperty\",\n        \"isPrototypeOf\",\n        \"propertyIsEnumerable\",\n        \"constructor\"\n    ], dontEnumsLength = dontEnums.length;\n    var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", mapTag = \"[object Map]\", numberTag = \"[object Number]\", objectTag = \"[object Object]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag = \"[object String]\", weakMapTag = \"[object WeakMap]\";\n    var arrayBufferTag = \"[object ArrayBuffer]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n    var objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, objToString = objectProto.toString, MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n    var keys = Object.keys || function() {\n        var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({\n            toString: null\n        }).propertyIsEnumerable(\"toString\"), dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ], dontEnumsLength = dontEnums.length;\n        return function(obj) {\n            if (typeof obj !== \"object\" && (typeof obj !== \"function\" || obj === null)) {\n                throw new TypeError(\"Object.keys called on non-object\");\n            }\n            var result = [], prop, i;\n            for(prop in obj){\n                if (hasOwnProperty.call(obj, prop)) {\n                    result.push(prop);\n                }\n            }\n            if (hasDontEnumBug) {\n                for(i = 0; i < dontEnumsLength; i++){\n                    if (hasOwnProperty.call(obj, dontEnums[i])) {\n                        result.push(dontEnums[i]);\n                    }\n                }\n            }\n            return result;\n        };\n    }();\n    function equalObjects(object, other, equalFunc, isLoose, stackA, stackB) {\n        var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;\n        if (objLength !== othLength && !isLoose) {\n            return false;\n        }\n        var index = objLength, key;\n        while(index--){\n            key = objProps[index];\n            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n                return false;\n            }\n        }\n        var skipCtor = isLoose;\n        while(++index < objLength){\n            key = objProps[index];\n            var objValue = object[key], othValue = other[key], result;\n            if (!(result === undefined ? equalFunc(objValue, othValue, isLoose, stackA, stackB) : result)) {\n                return false;\n            }\n            skipCtor || (skipCtor = key === \"constructor\");\n        }\n        if (!skipCtor) {\n            var objCtor = object.constructor, othCtor = other.constructor;\n            if (objCtor !== othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor === \"function\" && objCtor instanceof objCtor && typeof othCtor === \"function\" && othCtor instanceof othCtor)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function equalByTag(object, other, tag) {\n        switch(tag){\n            case boolTag:\n            case dateTag:\n                return +object === +other;\n            case errorTag:\n                return object.name === other.name && object.message === other.message;\n            case numberTag:\n                return object !== +object ? other !== +other : object === +other;\n            case regexpTag:\n            case stringTag:\n                return object === other + \"\";\n        }\n        return false;\n    }\n    var isObject = Rx.internals.isObject = function(value) {\n        var type = typeof value;\n        return !!value && (type === \"object\" || type === \"function\");\n    };\n    function isObjectLike(value) {\n        return !!value && typeof value === \"object\";\n    }\n    function isLength(value) {\n        return typeof value === \"number\" && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;\n    }\n    var isHostObject = function() {\n        try {\n            Object({\n                \"toString\": 0\n            } + \"\");\n        } catch (e) {\n            return function() {\n                return false;\n            };\n        }\n        return function(value) {\n            return typeof value.toString !== \"function\" && typeof (value + \"\") === \"string\";\n        };\n    }();\n    function isTypedArray(value) {\n        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n    }\n    var isArray = Array.isArray || function(value) {\n        return isObjectLike(value) && isLength(value.length) && objToString.call(value) === arrayTag;\n    };\n    function arraySome(array, predicate) {\n        var index = -1, length = array.length;\n        while(++index < length){\n            if (predicate(array[index], index, array)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function equalArrays(array, other, equalFunc, isLoose, stackA, stackB) {\n        var index = -1, arrLength = array.length, othLength = other.length;\n        if (arrLength !== othLength && !(isLoose && othLength > arrLength)) {\n            return false;\n        }\n        // Ignore non-index properties.\n        while(++index < arrLength){\n            var arrValue = array[index], othValue = other[index], result;\n            if (result !== undefined) {\n                if (result) {\n                    continue;\n                }\n                return false;\n            }\n            // Recursively compare arrays (susceptible to call stack limits).\n            if (isLoose) {\n                if (!arraySome(other, function(othValue) {\n                    return arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB);\n                })) {\n                    return false;\n                }\n            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function baseIsEqualDeep(object, other, equalFunc, isLoose, stackA, stackB) {\n        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;\n        if (!objIsArr) {\n            objTag = objToString.call(object);\n            if (objTag === argsTag) {\n                objTag = objectTag;\n            } else if (objTag !== objectTag) {\n                objIsArr = isTypedArray(object);\n            }\n        }\n        if (!othIsArr) {\n            othTag = objToString.call(other);\n            if (othTag === argsTag) {\n                othTag = objectTag;\n            }\n        }\n        var objIsObj = objTag === objectTag && !isHostObject(object), othIsObj = othTag === objectTag && !isHostObject(other), isSameTag = objTag === othTag;\n        if (isSameTag && !(objIsArr || objIsObj)) {\n            return equalByTag(object, other, objTag);\n        }\n        if (!isLoose) {\n            var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n            if (objIsWrapped || othIsWrapped) {\n                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, isLoose, stackA, stackB);\n            }\n        }\n        if (!isSameTag) {\n            return false;\n        }\n        // Assume cyclic values are equal.\n        // For more information on detecting circular references see https://es5.github.io/#JO.\n        stackA || (stackA = []);\n        stackB || (stackB = []);\n        var length = stackA.length;\n        while(length--){\n            if (stackA[length] === object) {\n                return stackB[length] === other;\n            }\n        }\n        // Add `object` and `other` to the stack of traversed objects.\n        stackA.push(object);\n        stackB.push(other);\n        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, isLoose, stackA, stackB);\n        stackA.pop();\n        stackB.pop();\n        return result;\n    }\n    function baseIsEqual(value, other, isLoose, stackA, stackB) {\n        if (value === other) {\n            return true;\n        }\n        if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {\n            return value !== value && other !== other;\n        }\n        return baseIsEqualDeep(value, other, baseIsEqual, isLoose, stackA, stackB);\n    }\n    var isEqual = Rx.internals.isEqual = function(value, other) {\n        return baseIsEqual(value, other);\n    };\n    var hasProp = {}.hasOwnProperty, slice = Array.prototype.slice;\n    var inherits = Rx.internals.inherits = function(child, parent) {\n        function __() {\n            this.constructor = child;\n        }\n        __.prototype = parent.prototype;\n        child.prototype = new __();\n    };\n    var addProperties = Rx.internals.addProperties = function(obj) {\n        for(var sources = [], i = 1, len = arguments.length; i < len; i++){\n            sources.push(arguments[i]);\n        }\n        for(var idx = 0, ln = sources.length; idx < ln; idx++){\n            var source = sources[idx];\n            for(var prop in source){\n                obj[prop] = source[prop];\n            }\n        }\n    };\n    // Rx Utils\n    var addRef = Rx.internals.addRef = function(xs, r) {\n        return new AnonymousObservable(function(observer) {\n            return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));\n        });\n    };\n    function arrayInitialize(count, factory) {\n        var a = new Array(count);\n        for(var i = 0; i < count; i++){\n            a[i] = factory();\n        }\n        return a;\n    }\n    /**\n   * Represents a group of disposable resources that are disposed together.\n   * @constructor\n   */ var CompositeDisposable = Rx.CompositeDisposable = function() {\n        var args = [], i, len;\n        if (Array.isArray(arguments[0])) {\n            args = arguments[0];\n        } else {\n            len = arguments.length;\n            args = new Array(len);\n            for(i = 0; i < len; i++){\n                args[i] = arguments[i];\n            }\n        }\n        this.disposables = args;\n        this.isDisposed = false;\n        this.length = args.length;\n    };\n    var CompositeDisposablePrototype = CompositeDisposable.prototype;\n    /**\n   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.\n   * @param {Mixed} item Disposable to add.\n   */ CompositeDisposablePrototype.add = function(item) {\n        if (this.isDisposed) {\n            item.dispose();\n        } else {\n            this.disposables.push(item);\n            this.length++;\n        }\n    };\n    /**\n   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.\n   * @param {Mixed} item Disposable to remove.\n   * @returns {Boolean} true if found; false otherwise.\n   */ CompositeDisposablePrototype.remove = function(item) {\n        var shouldDispose = false;\n        if (!this.isDisposed) {\n            var idx = this.disposables.indexOf(item);\n            if (idx !== -1) {\n                shouldDispose = true;\n                this.disposables.splice(idx, 1);\n                this.length--;\n                item.dispose();\n            }\n        }\n        return shouldDispose;\n    };\n    /**\n   *  Disposes all disposables in the group and removes them from the group.\n   */ CompositeDisposablePrototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            var len = this.disposables.length, currentDisposables = new Array(len);\n            for(var i = 0; i < len; i++){\n                currentDisposables[i] = this.disposables[i];\n            }\n            this.disposables = [];\n            this.length = 0;\n            for(i = 0; i < len; i++){\n                currentDisposables[i].dispose();\n            }\n        }\n    };\n    /**\n   * Provides a set of static methods for creating Disposables.\n   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n   */ var Disposable = Rx.Disposable = function(action) {\n        this.isDisposed = false;\n        this.action = action || noop;\n    };\n    /** Performs the task of cleaning up resources. */ Disposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.action();\n            this.isDisposed = true;\n        }\n    };\n    /**\n   * Creates a disposable object that invokes the specified action when disposed.\n   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n   * @return {Disposable} The disposable object that runs the given action upon disposal.\n   */ var disposableCreate = Disposable.create = function(action) {\n        return new Disposable(action);\n    };\n    /**\n   * Gets the disposable that does nothing when disposed.\n   */ var disposableEmpty = Disposable.empty = {\n        dispose: noop\n    };\n    /**\n   * Validates whether the given object is a disposable\n   * @param {Object} Object to test whether it has a dispose method\n   * @returns {Boolean} true if a disposable object, else false.\n   */ var isDisposable = Disposable.isDisposable = function(d) {\n        return d && isFunction(d.dispose);\n    };\n    var checkDisposed = Disposable.checkDisposed = function(disposable) {\n        if (disposable.isDisposed) {\n            throw new ObjectDisposedError();\n        }\n    };\n    var disposableFixup = Disposable._fixup = function(result) {\n        return isDisposable(result) ? result : disposableEmpty;\n    };\n    // Single assignment\n    var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {\n        this.isDisposed = false;\n        this.current = null;\n    };\n    SingleAssignmentDisposable.prototype.getDisposable = function() {\n        return this.current;\n    };\n    SingleAssignmentDisposable.prototype.setDisposable = function(value) {\n        if (this.current) {\n            throw new Error(\"Disposable has already been assigned\");\n        }\n        var shouldDispose = this.isDisposed;\n        !shouldDispose && (this.current = value);\n        shouldDispose && value && value.dispose();\n    };\n    SingleAssignmentDisposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            var old = this.current;\n            this.current = null;\n            old && old.dispose();\n        }\n    };\n    // Multiple assignment disposable\n    var SerialDisposable = Rx.SerialDisposable = function() {\n        this.isDisposed = false;\n        this.current = null;\n    };\n    SerialDisposable.prototype.getDisposable = function() {\n        return this.current;\n    };\n    SerialDisposable.prototype.setDisposable = function(value) {\n        var shouldDispose = this.isDisposed;\n        if (!shouldDispose) {\n            var old = this.current;\n            this.current = value;\n        }\n        old && old.dispose();\n        shouldDispose && value && value.dispose();\n    };\n    SerialDisposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            var old = this.current;\n            this.current = null;\n        }\n        old && old.dispose();\n    };\n    var BinaryDisposable = Rx.BinaryDisposable = function(first, second) {\n        this._first = first;\n        this._second = second;\n        this.isDisposed = false;\n    };\n    BinaryDisposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            var old1 = this._first;\n            this._first = null;\n            old1 && old1.dispose();\n            var old2 = this._second;\n            this._second = null;\n            old2 && old2.dispose();\n        }\n    };\n    var NAryDisposable = Rx.NAryDisposable = function(disposables) {\n        this._disposables = disposables;\n        this.isDisposed = false;\n    };\n    NAryDisposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            for(var i = 0, len = this._disposables.length; i < len; i++){\n                this._disposables[i].dispose();\n            }\n            this._disposables.length = 0;\n        }\n    };\n    /**\n   * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.\n   */ var RefCountDisposable = Rx.RefCountDisposable = function() {\n        function InnerDisposable(disposable) {\n            this.disposable = disposable;\n            this.disposable.count++;\n            this.isInnerDisposed = false;\n        }\n        InnerDisposable.prototype.dispose = function() {\n            if (!this.disposable.isDisposed && !this.isInnerDisposed) {\n                this.isInnerDisposed = true;\n                this.disposable.count--;\n                if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {\n                    this.disposable.isDisposed = true;\n                    this.disposable.underlyingDisposable.dispose();\n                }\n            }\n        };\n        /**\n     * Initializes a new instance of the RefCountDisposable with the specified disposable.\n     * @constructor\n     * @param {Disposable} disposable Underlying disposable.\n      */ function RefCountDisposable(disposable) {\n            this.underlyingDisposable = disposable;\n            this.isDisposed = false;\n            this.isPrimaryDisposed = false;\n            this.count = 0;\n        }\n        /**\n     * Disposes the underlying disposable only when all dependent disposables have been disposed\n     */ RefCountDisposable.prototype.dispose = function() {\n            if (!this.isDisposed && !this.isPrimaryDisposed) {\n                this.isPrimaryDisposed = true;\n                if (this.count === 0) {\n                    this.isDisposed = true;\n                    this.underlyingDisposable.dispose();\n                }\n            }\n        };\n        /**\n     * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.\n     * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.\n     */ RefCountDisposable.prototype.getDisposable = function() {\n            return this.isDisposed ? disposableEmpty : new InnerDisposable(this);\n        };\n        return RefCountDisposable;\n    }();\n    function ScheduledDisposable(scheduler, disposable) {\n        this.scheduler = scheduler;\n        this.disposable = disposable;\n        this.isDisposed = false;\n    }\n    function scheduleItem(s, self1) {\n        if (!self1.isDisposed) {\n            self1.isDisposed = true;\n            self1.disposable.dispose();\n        }\n    }\n    ScheduledDisposable.prototype.dispose = function() {\n        this.scheduler.schedule(this, scheduleItem);\n    };\n    var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {\n        this.scheduler = scheduler;\n        this.state = state;\n        this.action = action;\n        this.dueTime = dueTime;\n        this.comparer = comparer || defaultSubComparer;\n        this.disposable = new SingleAssignmentDisposable();\n    };\n    ScheduledItem.prototype.invoke = function() {\n        this.disposable.setDisposable(this.invokeCore());\n    };\n    ScheduledItem.prototype.compareTo = function(other) {\n        return this.comparer(this.dueTime, other.dueTime);\n    };\n    ScheduledItem.prototype.isCancelled = function() {\n        return this.disposable.isDisposed;\n    };\n    ScheduledItem.prototype.invokeCore = function() {\n        return disposableFixup(this.action(this.scheduler, this.state));\n    };\n    /** Provides a set of static properties to access commonly used schedulers. */ var Scheduler = Rx.Scheduler = function() {\n        function Scheduler() {}\n        /** Determines whether the given object is a scheduler */ Scheduler.isScheduler = function(s) {\n            return s instanceof Scheduler;\n        };\n        var schedulerProto = Scheduler.prototype;\n        /**\n   * Schedules an action to be executed.\n   * @param state State passed to the action to be executed.\n   * @param {Function} action Action to be executed.\n   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n   */ schedulerProto.schedule = function(state, action) {\n            throw new NotImplementedError();\n        };\n        /**\n   * Schedules an action to be executed after dueTime.\n   * @param state State passed to the action to be executed.\n   * @param {Function} action Action to be executed.\n   * @param {Number} dueTime Relative time after which to execute the action.\n   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n   */ schedulerProto.scheduleFuture = function(state, dueTime, action) {\n            var dt = dueTime;\n            dt instanceof Date && (dt = dt - this.now());\n            dt = Scheduler.normalize(dt);\n            if (dt === 0) {\n                return this.schedule(state, action);\n            }\n            return this._scheduleFuture(state, dt, action);\n        };\n        schedulerProto._scheduleFuture = function(state, dueTime, action) {\n            throw new NotImplementedError();\n        };\n        /** Gets the current time according to the local machine's system clock. */ Scheduler.now = defaultNow;\n        /** Gets the current time according to the local machine's system clock. */ Scheduler.prototype.now = defaultNow;\n        /**\n     * Normalizes the specified TimeSpan value to a positive value.\n     * @param {Number} timeSpan The time span value to normalize.\n     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0\n     */ Scheduler.normalize = function(timeSpan) {\n            timeSpan < 0 && (timeSpan = 0);\n            return timeSpan;\n        };\n        return Scheduler;\n    }();\n    var normalizeTime = Scheduler.normalize, isScheduler = Scheduler.isScheduler;\n    (function(schedulerProto) {\n        function invokeRecImmediate(scheduler, pair) {\n            var state = pair[0], action = pair[1], group = new CompositeDisposable();\n            action(state, innerAction);\n            return group;\n            function innerAction(state2) {\n                var isAdded = false, isDone = false;\n                var d = scheduler.schedule(state2, scheduleWork);\n                if (!isDone) {\n                    group.add(d);\n                    isAdded = true;\n                }\n                function scheduleWork(_, state3) {\n                    if (isAdded) {\n                        group.remove(d);\n                    } else {\n                        isDone = true;\n                    }\n                    action(state3, innerAction);\n                    return disposableEmpty;\n                }\n            }\n        }\n        function invokeRecDate(scheduler, pair) {\n            var state = pair[0], action = pair[1], group = new CompositeDisposable();\n            action(state, innerAction);\n            return group;\n            function innerAction(state2, dueTime1) {\n                var isAdded = false, isDone = false;\n                var d = scheduler.scheduleFuture(state2, dueTime1, scheduleWork);\n                if (!isDone) {\n                    group.add(d);\n                    isAdded = true;\n                }\n                function scheduleWork(_, state3) {\n                    if (isAdded) {\n                        group.remove(d);\n                    } else {\n                        isDone = true;\n                    }\n                    action(state3, innerAction);\n                    return disposableEmpty;\n                }\n            }\n        }\n        /**\n     * Schedules an action to be executed recursively.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */ schedulerProto.scheduleRecursive = function(state, action) {\n            return this.schedule([\n                state,\n                action\n            ], invokeRecImmediate);\n        };\n        /**\n     * Schedules an action to be executed recursively after a specified relative or absolute due time.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.\n     * @param {Number | Date} dueTime Relative or absolute time after which to execute the action for the first time.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */ schedulerProto.scheduleRecursiveFuture = function(state, dueTime, action) {\n            return this.scheduleFuture([\n                state,\n                action\n            ], dueTime, invokeRecDate);\n        };\n    })(Scheduler.prototype);\n    (function(schedulerProto) {\n        /**\n     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.\n     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n     * @param {Number} period Period for running the work periodically.\n     * @param {Function} action Action to be executed, potentially updating the state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n     */ schedulerProto.schedulePeriodic = function(state, period, action) {\n            if (typeof root.setInterval === \"undefined\") {\n                throw new NotSupportedError();\n            }\n            period = normalizeTime(period);\n            var s = state, id = root.setInterval(function() {\n                s = action(s);\n            }, period);\n            return disposableCreate(function() {\n                root.clearInterval(id);\n            });\n        };\n    })(Scheduler.prototype);\n    (function(schedulerProto) {\n        /**\n     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.\n     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.\n     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.\n     */ schedulerProto.catchError = schedulerProto[\"catch\"] = function(handler) {\n            return new CatchScheduler(this, handler);\n        };\n    })(Scheduler.prototype);\n    var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = function() {\n        function createTick(self1) {\n            return function tick(command, recurse) {\n                recurse(0, self1._period);\n                var state = tryCatch(self1._action)(self1._state);\n                if (state === errorObj) {\n                    self1._cancel.dispose();\n                    thrower(state.e);\n                }\n                self1._state = state;\n            };\n        }\n        function SchedulePeriodicRecursive(scheduler, state, period, action) {\n            this._scheduler = scheduler;\n            this._state = state;\n            this._period = period;\n            this._action = action;\n        }\n        SchedulePeriodicRecursive.prototype.start = function() {\n            var d = new SingleAssignmentDisposable();\n            this._cancel = d;\n            d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));\n            return d;\n        };\n        return SchedulePeriodicRecursive;\n    }();\n    /** Gets a scheduler that schedules work immediately on the current thread. */ var ImmediateScheduler = function(__super__) {\n        inherits(ImmediateScheduler, __super__);\n        function ImmediateScheduler() {\n            __super__.call(this);\n        }\n        ImmediateScheduler.prototype.schedule = function(state, action) {\n            return disposableFixup(action(this, state));\n        };\n        return ImmediateScheduler;\n    }(Scheduler);\n    var immediateScheduler = Scheduler.immediate = new ImmediateScheduler();\n    /**\n   * Gets a scheduler that schedules work as soon as possible on the current thread.\n   */ var CurrentThreadScheduler = function(__super__) {\n        var queue;\n        function runTrampoline() {\n            while(queue.length > 0){\n                var item = queue.dequeue();\n                !item.isCancelled() && item.invoke();\n            }\n        }\n        inherits(CurrentThreadScheduler, __super__);\n        function CurrentThreadScheduler() {\n            __super__.call(this);\n        }\n        CurrentThreadScheduler.prototype.schedule = function(state, action) {\n            var si = new ScheduledItem(this, state, action, this.now());\n            if (!queue) {\n                queue = new PriorityQueue(4);\n                queue.enqueue(si);\n                var result = tryCatch(runTrampoline)();\n                queue = null;\n                if (result === errorObj) {\n                    thrower(result.e);\n                }\n            } else {\n                queue.enqueue(si);\n            }\n            return si.disposable;\n        };\n        CurrentThreadScheduler.prototype.scheduleRequired = function() {\n            return !queue;\n        };\n        return CurrentThreadScheduler;\n    }(Scheduler);\n    var currentThreadScheduler = Scheduler.currentThread = new CurrentThreadScheduler();\n    var scheduleMethod, clearMethod;\n    var localTimer = function() {\n        var localSetTimeout, localClearTimeout = noop;\n        if (!!root.setTimeout) {\n            localSetTimeout = root.setTimeout;\n            localClearTimeout = root.clearTimeout;\n        } else if (!!root.WScript) {\n            localSetTimeout = function(fn, time) {\n                root.WScript.Sleep(time);\n                fn();\n            };\n        } else {\n            throw new NotSupportedError();\n        }\n        return {\n            setTimeout: localSetTimeout,\n            clearTimeout: localClearTimeout\n        };\n    }();\n    var localSetTimeout = localTimer.setTimeout, localClearTimeout = localTimer.clearTimeout;\n    (function() {\n        var nextHandle = 1, tasksByHandle = {}, currentlyRunning = false;\n        clearMethod = function(handle) {\n            delete tasksByHandle[handle];\n        };\n        function runTask(handle) {\n            if (currentlyRunning) {\n                localSetTimeout(function() {\n                    runTask(handle);\n                }, 0);\n            } else {\n                var task = tasksByHandle[handle];\n                if (task) {\n                    currentlyRunning = true;\n                    var result = tryCatch(task)();\n                    clearMethod(handle);\n                    currentlyRunning = false;\n                    if (result === errorObj) {\n                        thrower(result.e);\n                    }\n                }\n            }\n        }\n        var reNative = new RegExp(\"^\" + String(toString).replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/toString| for [^\\]]+/g, \".*?\") + \"$\");\n        var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == \"function\" && !reNative.test(setImmediate) && setImmediate;\n        function postMessageSupported() {\n            // Ensure not in a worker\n            if (!root.postMessage || root.importScripts) {\n                return false;\n            }\n            var isAsync = false, oldHandler = root.onmessage;\n            // Test for async\n            root.onmessage = function() {\n                isAsync = true;\n            };\n            root.postMessage(\"\", \"*\");\n            root.onmessage = oldHandler;\n            return isAsync;\n        }\n        // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout\n        if (isFunction(setImmediate)) {\n            scheduleMethod = function(action) {\n                var id = nextHandle++;\n                tasksByHandle[id] = action;\n                setImmediate(function() {\n                    runTask(id);\n                });\n                return id;\n            };\n        } else if (typeof process !== \"undefined\" && ({}).toString.call(process) === \"[object process]\") {\n            scheduleMethod = function(action) {\n                var id = nextHandle++;\n                tasksByHandle[id] = action;\n                process.nextTick(function() {\n                    runTask(id);\n                });\n                return id;\n            };\n        } else if (postMessageSupported()) {\n            var MSG_PREFIX = \"ms.rx.schedule\" + Math.random();\n            var onGlobalPostMessage = function(event) {\n                // Only if we're a match to avoid any other global events\n                if (typeof event.data === \"string\" && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {\n                    runTask(event.data.substring(MSG_PREFIX.length));\n                }\n            };\n            root.addEventListener(\"message\", onGlobalPostMessage, false);\n            scheduleMethod = function(action) {\n                var id = nextHandle++;\n                tasksByHandle[id] = action;\n                root.postMessage(MSG_PREFIX + id, \"*\");\n                return id;\n            };\n        } else if (!!root.MessageChannel) {\n            var channel = new root.MessageChannel();\n            channel.port1.onmessage = function(e) {\n                runTask(e.data);\n            };\n            scheduleMethod = function(action) {\n                var id = nextHandle++;\n                tasksByHandle[id] = action;\n                channel.port2.postMessage(id);\n                return id;\n            };\n        } else if (\"document\" in root && \"onreadystatechange\" in root.document.createElement(\"script\")) {\n            scheduleMethod = function(action) {\n                var scriptElement = root.document.createElement(\"script\");\n                var id = nextHandle++;\n                tasksByHandle[id] = action;\n                scriptElement.onreadystatechange = function() {\n                    runTask(id);\n                    scriptElement.onreadystatechange = null;\n                    scriptElement.parentNode.removeChild(scriptElement);\n                    scriptElement = null;\n                };\n                root.document.documentElement.appendChild(scriptElement);\n                return id;\n            };\n        } else {\n            scheduleMethod = function(action) {\n                var id = nextHandle++;\n                tasksByHandle[id] = action;\n                localSetTimeout(function() {\n                    runTask(id);\n                }, 0);\n                return id;\n            };\n        }\n    })();\n    /**\n   * Gets a scheduler that schedules work via a timed callback based upon platform.\n   */ var DefaultScheduler = function(__super__) {\n        inherits(DefaultScheduler, __super__);\n        function DefaultScheduler() {\n            __super__.call(this);\n        }\n        function scheduleAction(disposable, action, scheduler, state) {\n            return function schedule() {\n                disposable.setDisposable(Disposable._fixup(action(scheduler, state)));\n            };\n        }\n        function ClearDisposable(id) {\n            this._id = id;\n            this.isDisposed = false;\n        }\n        ClearDisposable.prototype.dispose = function() {\n            if (!this.isDisposed) {\n                this.isDisposed = true;\n                clearMethod(this._id);\n            }\n        };\n        function LocalClearDisposable(id) {\n            this._id = id;\n            this.isDisposed = false;\n        }\n        LocalClearDisposable.prototype.dispose = function() {\n            if (!this.isDisposed) {\n                this.isDisposed = true;\n                localClearTimeout(this._id);\n            }\n        };\n        DefaultScheduler.prototype.schedule = function(state, action) {\n            var disposable = new SingleAssignmentDisposable(), id = scheduleMethod(scheduleAction(disposable, action, this, state));\n            return new BinaryDisposable(disposable, new ClearDisposable(id));\n        };\n        DefaultScheduler.prototype._scheduleFuture = function(state, dueTime, action) {\n            if (dueTime === 0) {\n                return this.schedule(state, action);\n            }\n            var disposable = new SingleAssignmentDisposable(), id = localSetTimeout(scheduleAction(disposable, action, this, state), dueTime);\n            return new BinaryDisposable(disposable, new LocalClearDisposable(id));\n        };\n        function scheduleLongRunning(state, action, disposable) {\n            return function() {\n                action(state, disposable);\n            };\n        }\n        DefaultScheduler.prototype.scheduleLongRunning = function(state, action) {\n            var disposable = disposableCreate(noop);\n            scheduleMethod(scheduleLongRunning(state, action, disposable));\n            return disposable;\n        };\n        return DefaultScheduler;\n    }(Scheduler);\n    var defaultScheduler = Scheduler[\"default\"] = Scheduler.async = new DefaultScheduler();\n    var CatchScheduler = function(__super__) {\n        inherits(CatchScheduler, __super__);\n        function CatchScheduler(scheduler, handler) {\n            this._scheduler = scheduler;\n            this._handler = handler;\n            this._recursiveOriginal = null;\n            this._recursiveWrapper = null;\n            __super__.call(this);\n        }\n        CatchScheduler.prototype.schedule = function(state, action) {\n            return this._scheduler.schedule(state, this._wrap(action));\n        };\n        CatchScheduler.prototype._scheduleFuture = function(state, dueTime, action) {\n            return this._scheduler.schedule(state, dueTime, this._wrap(action));\n        };\n        CatchScheduler.prototype.now = function() {\n            return this._scheduler.now();\n        };\n        CatchScheduler.prototype._clone = function(scheduler) {\n            return new CatchScheduler(scheduler, this._handler);\n        };\n        CatchScheduler.prototype._wrap = function(action) {\n            var parent = this;\n            return function(self1, state) {\n                var res = tryCatch(action)(parent._getRecursiveWrapper(self1), state);\n                if (res === errorObj) {\n                    if (!parent._handler(res.e)) {\n                        thrower(res.e);\n                    }\n                    return disposableEmpty;\n                }\n                return disposableFixup(res);\n            };\n        };\n        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {\n            if (this._recursiveOriginal !== scheduler) {\n                this._recursiveOriginal = scheduler;\n                var wrapper = this._clone(scheduler);\n                wrapper._recursiveOriginal = scheduler;\n                wrapper._recursiveWrapper = wrapper;\n                this._recursiveWrapper = wrapper;\n            }\n            return this._recursiveWrapper;\n        };\n        CatchScheduler.prototype.schedulePeriodic = function(state, period, action) {\n            var self1 = this, failed = false, d = new SingleAssignmentDisposable();\n            d.setDisposable(this._scheduler.schedulePeriodic(state, period, function(state1) {\n                if (failed) {\n                    return null;\n                }\n                var res = tryCatch(action)(state1);\n                if (res === errorObj) {\n                    failed = true;\n                    if (!self1._handler(res.e)) {\n                        thrower(res.e);\n                    }\n                    d.dispose();\n                    return null;\n                }\n                return res;\n            }));\n            return d;\n        };\n        return CatchScheduler;\n    }(Scheduler);\n    function IndexedItem(id, value) {\n        this.id = id;\n        this.value = value;\n    }\n    IndexedItem.prototype.compareTo = function(other) {\n        var c = this.value.compareTo(other.value);\n        c === 0 && (c = this.id - other.id);\n        return c;\n    };\n    var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {\n        this.items = new Array(capacity);\n        this.length = 0;\n    };\n    var priorityProto = PriorityQueue.prototype;\n    priorityProto.isHigherPriority = function(left, right) {\n        return this.items[left].compareTo(this.items[right]) < 0;\n    };\n    priorityProto.percolate = function(index) {\n        if (index >= this.length || index < 0) {\n            return;\n        }\n        var parent = index - 1 >> 1;\n        if (parent < 0 || parent === index) {\n            return;\n        }\n        if (this.isHigherPriority(index, parent)) {\n            var temp = this.items[index];\n            this.items[index] = this.items[parent];\n            this.items[parent] = temp;\n            this.percolate(parent);\n        }\n    };\n    priorityProto.heapify = function(index) {\n        +index || (index = 0);\n        if (index >= this.length || index < 0) {\n            return;\n        }\n        var left = 2 * index + 1, right = 2 * index + 2, first = index;\n        if (left < this.length && this.isHigherPriority(left, first)) {\n            first = left;\n        }\n        if (right < this.length && this.isHigherPriority(right, first)) {\n            first = right;\n        }\n        if (first !== index) {\n            var temp = this.items[index];\n            this.items[index] = this.items[first];\n            this.items[first] = temp;\n            this.heapify(first);\n        }\n    };\n    priorityProto.peek = function() {\n        return this.items[0].value;\n    };\n    priorityProto.removeAt = function(index) {\n        this.items[index] = this.items[--this.length];\n        this.items[this.length] = undefined;\n        this.heapify();\n    };\n    priorityProto.dequeue = function() {\n        var result = this.peek();\n        this.removeAt(0);\n        return result;\n    };\n    priorityProto.enqueue = function(item) {\n        var index = this.length++;\n        this.items[index] = new IndexedItem(PriorityQueue.count++, item);\n        this.percolate(index);\n    };\n    priorityProto.remove = function(item) {\n        for(var i = 0; i < this.length; i++){\n            if (this.items[i].value === item) {\n                this.removeAt(i);\n                return true;\n            }\n        }\n        return false;\n    };\n    PriorityQueue.count = 0;\n    /**\n   *  Represents a notification to an observer.\n   */ var Notification = Rx.Notification = function() {\n        function Notification() {}\n        Notification.prototype._accept = function(onNext, onError, onCompleted) {\n            throw new NotImplementedError();\n        };\n        Notification.prototype._acceptObserver = function(onNext, onError, onCompleted) {\n            throw new NotImplementedError();\n        };\n        /**\n     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.\n     * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification on..\n     * @param {Function} onError Function to invoke for an OnError notification.\n     * @param {Function} onCompleted Function to invoke for an OnCompleted notification.\n     * @returns {Any} Result produced by the observation.\n     */ Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {\n            return observerOrOnNext && typeof observerOrOnNext === \"object\" ? this._acceptObserver(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);\n        };\n        /**\n     * Returns an observable sequence with a single notification.\n     *\n     * @memberOf Notifications\n     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.\n     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.\n     */ Notification.prototype.toObservable = function(scheduler) {\n            var self1 = this;\n            isScheduler(scheduler) || (scheduler = immediateScheduler);\n            return new AnonymousObservable(function(o) {\n                return scheduler.schedule(self1, function(_, notification) {\n                    notification._acceptObserver(o);\n                    notification.kind === \"N\" && o.onCompleted();\n                });\n            });\n        };\n        return Notification;\n    }();\n    var OnNextNotification = function(__super__) {\n        inherits(OnNextNotification, __super__);\n        function OnNextNotification(value) {\n            this.value = value;\n            this.kind = \"N\";\n        }\n        OnNextNotification.prototype._accept = function(onNext) {\n            return onNext(this.value);\n        };\n        OnNextNotification.prototype._acceptObserver = function(o) {\n            return o.onNext(this.value);\n        };\n        OnNextNotification.prototype.toString = function() {\n            return \"OnNext(\" + this.value + \")\";\n        };\n        return OnNextNotification;\n    }(Notification);\n    var OnErrorNotification = function(__super__) {\n        inherits(OnErrorNotification, __super__);\n        function OnErrorNotification(error) {\n            this.error = error;\n            this.kind = \"E\";\n        }\n        OnErrorNotification.prototype._accept = function(onNext, onError) {\n            return onError(this.error);\n        };\n        OnErrorNotification.prototype._acceptObserver = function(o) {\n            return o.onError(this.error);\n        };\n        OnErrorNotification.prototype.toString = function() {\n            return \"OnError(\" + this.error + \")\";\n        };\n        return OnErrorNotification;\n    }(Notification);\n    var OnCompletedNotification = function(__super__) {\n        inherits(OnCompletedNotification, __super__);\n        function OnCompletedNotification() {\n            this.kind = \"C\";\n        }\n        OnCompletedNotification.prototype._accept = function(onNext, onError, onCompleted) {\n            return onCompleted();\n        };\n        OnCompletedNotification.prototype._acceptObserver = function(o) {\n            return o.onCompleted();\n        };\n        OnCompletedNotification.prototype.toString = function() {\n            return \"OnCompleted()\";\n        };\n        return OnCompletedNotification;\n    }(Notification);\n    /**\n   * Creates an object that represents an OnNext notification to an observer.\n   * @param {Any} value The value contained in the notification.\n   * @returns {Notification} The OnNext notification containing the value.\n   */ var notificationCreateOnNext = Notification.createOnNext = function(value) {\n        return new OnNextNotification(value);\n    };\n    /**\n   * Creates an object that represents an OnError notification to an observer.\n   * @param {Any} error The exception contained in the notification.\n   * @returns {Notification} The OnError notification containing the exception.\n   */ var notificationCreateOnError = Notification.createOnError = function(error) {\n        return new OnErrorNotification(error);\n    };\n    /**\n   * Creates an object that represents an OnCompleted notification to an observer.\n   * @returns {Notification} The OnCompleted notification.\n   */ var notificationCreateOnCompleted = Notification.createOnCompleted = function() {\n        return new OnCompletedNotification();\n    };\n    /**\n   * Supports push-style iteration over an observable sequence.\n   */ var Observer = Rx.Observer = function() {};\n    /**\n   *  Creates a notification callback from an observer.\n   * @returns The action that forwards its input notification to the underlying observer.\n   */ Observer.prototype.toNotifier = function() {\n        var observer = this;\n        return function(n) {\n            return n.accept(observer);\n        };\n    };\n    /**\n   *  Hides the identity of an observer.\n   * @returns An observer that hides the identity of the specified observer.\n   */ Observer.prototype.asObserver = function() {\n        var self1 = this;\n        return new AnonymousObserver(function(x) {\n            self1.onNext(x);\n        }, function(err) {\n            self1.onError(err);\n        }, function() {\n            self1.onCompleted();\n        });\n    };\n    /**\n   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.\n   *  If a violation is detected, an Error is thrown from the offending observer method call.\n   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.\n   */ Observer.prototype.checked = function() {\n        return new CheckedObserver(this);\n    };\n    /**\n   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.\n   * @param {Function} [onNext] Observer's OnNext action implementation.\n   * @param {Function} [onError] Observer's OnError action implementation.\n   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.\n   * @returns {Observer} The observer object implemented using the given actions.\n   */ var observerCreate = Observer.create = function(onNext, onError, onCompleted) {\n        onNext || (onNext = noop);\n        onError || (onError = defaultError);\n        onCompleted || (onCompleted = noop);\n        return new AnonymousObserver(onNext, onError, onCompleted);\n    };\n    /**\n   *  Creates an observer from a notification callback.\n   * @param {Function} handler Action that handles a notification.\n   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.\n   */ Observer.fromNotifier = function(handler, thisArg) {\n        var cb = bindCallback(handler, thisArg, 1);\n        return new AnonymousObserver(function(x) {\n            return cb(notificationCreateOnNext(x));\n        }, function(e) {\n            return cb(notificationCreateOnError(e));\n        }, function() {\n            return cb(notificationCreateOnCompleted());\n        });\n    };\n    /**\n   * Schedules the invocation of observer methods on the given scheduler.\n   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.\n   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.\n   */ Observer.prototype.notifyOn = function(scheduler) {\n        return new ObserveOnObserver(scheduler, this);\n    };\n    Observer.prototype.makeSafe = function(disposable) {\n        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);\n    };\n    /**\n   * Abstract base class for implementations of the Observer class.\n   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.\n   */ var AbstractObserver = Rx.internals.AbstractObserver = function(__super__) {\n        inherits(AbstractObserver, __super__);\n        /**\n     * Creates a new observer in a non-stopped state.\n     */ function AbstractObserver() {\n            this.isStopped = false;\n        }\n        // Must be implemented by other observers\n        AbstractObserver.prototype.next = notImplemented;\n        AbstractObserver.prototype.error = notImplemented;\n        AbstractObserver.prototype.completed = notImplemented;\n        /**\n     * Notifies the observer of a new element in the sequence.\n     * @param {Any} value Next element in the sequence.\n     */ AbstractObserver.prototype.onNext = function(value) {\n            !this.isStopped && this.next(value);\n        };\n        /**\n     * Notifies the observer that an exception has occurred.\n     * @param {Any} error The error that has occurred.\n     */ AbstractObserver.prototype.onError = function(error) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this.error(error);\n            }\n        };\n        /**\n     * Notifies the observer of the end of the sequence.\n     */ AbstractObserver.prototype.onCompleted = function() {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this.completed();\n            }\n        };\n        /**\n     * Disposes the observer, causing it to transition to the stopped state.\n     */ AbstractObserver.prototype.dispose = function() {\n            this.isStopped = true;\n        };\n        AbstractObserver.prototype.fail = function(e) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this.error(e);\n                return true;\n            }\n            return false;\n        };\n        return AbstractObserver;\n    }(Observer);\n    /**\n   * Class to create an Observer instance from delegate-based implementations of the on* methods.\n   */ var AnonymousObserver = Rx.AnonymousObserver = function(__super__) {\n        inherits(AnonymousObserver, __super__);\n        /**\n     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.\n     * @param {Any} onNext Observer's OnNext action implementation.\n     * @param {Any} onError Observer's OnError action implementation.\n     * @param {Any} onCompleted Observer's OnCompleted action implementation.\n     */ function AnonymousObserver(onNext, onError, onCompleted) {\n            __super__.call(this);\n            this._onNext = onNext;\n            this._onError = onError;\n            this._onCompleted = onCompleted;\n        }\n        /**\n     * Calls the onNext action.\n     * @param {Any} value Next element in the sequence.\n     */ AnonymousObserver.prototype.next = function(value) {\n            this._onNext(value);\n        };\n        /**\n     * Calls the onError action.\n     * @param {Any} error The error that has occurred.\n     */ AnonymousObserver.prototype.error = function(error) {\n            this._onError(error);\n        };\n        /**\n     *  Calls the onCompleted action.\n     */ AnonymousObserver.prototype.completed = function() {\n            this._onCompleted();\n        };\n        return AnonymousObserver;\n    }(AbstractObserver);\n    var CheckedObserver = function(__super__) {\n        inherits(CheckedObserver, __super__);\n        function CheckedObserver(observer) {\n            __super__.call(this);\n            this._observer = observer;\n            this._state = 0; // 0 - idle, 1 - busy, 2 - done\n        }\n        var CheckedObserverPrototype = CheckedObserver.prototype;\n        CheckedObserverPrototype.onNext = function(value) {\n            this.checkAccess();\n            var res = tryCatch(this._observer.onNext).call(this._observer, value);\n            this._state = 0;\n            res === errorObj && thrower(res.e);\n        };\n        CheckedObserverPrototype.onError = function(err) {\n            this.checkAccess();\n            var res = tryCatch(this._observer.onError).call(this._observer, err);\n            this._state = 2;\n            res === errorObj && thrower(res.e);\n        };\n        CheckedObserverPrototype.onCompleted = function() {\n            this.checkAccess();\n            var res = tryCatch(this._observer.onCompleted).call(this._observer);\n            this._state = 2;\n            res === errorObj && thrower(res.e);\n        };\n        CheckedObserverPrototype.checkAccess = function() {\n            if (this._state === 1) {\n                throw new Error(\"Re-entrancy detected\");\n            }\n            if (this._state === 2) {\n                throw new Error(\"Observer completed\");\n            }\n            if (this._state === 0) {\n                this._state = 1;\n            }\n        };\n        return CheckedObserver;\n    }(Observer);\n    var ScheduledObserver = Rx.internals.ScheduledObserver = function(__super__) {\n        inherits(ScheduledObserver, __super__);\n        function ScheduledObserver(scheduler, observer) {\n            __super__.call(this);\n            this.scheduler = scheduler;\n            this.observer = observer;\n            this.isAcquired = false;\n            this.hasFaulted = false;\n            this.queue = [];\n            this.disposable = new SerialDisposable();\n        }\n        function enqueueNext(observer, x) {\n            return function() {\n                observer.onNext(x);\n            };\n        }\n        function enqueueError(observer, e) {\n            return function() {\n                observer.onError(e);\n            };\n        }\n        function enqueueCompleted(observer) {\n            return function() {\n                observer.onCompleted();\n            };\n        }\n        ScheduledObserver.prototype.next = function(x) {\n            this.queue.push(enqueueNext(this.observer, x));\n        };\n        ScheduledObserver.prototype.error = function(e) {\n            this.queue.push(enqueueError(this.observer, e));\n        };\n        ScheduledObserver.prototype.completed = function() {\n            this.queue.push(enqueueCompleted(this.observer));\n        };\n        function scheduleMethod(state, recurse) {\n            var work;\n            if (state.queue.length > 0) {\n                work = state.queue.shift();\n            } else {\n                state.isAcquired = false;\n                return;\n            }\n            var res = tryCatch(work)();\n            if (res === errorObj) {\n                state.queue = [];\n                state.hasFaulted = true;\n                return thrower(res.e);\n            }\n            recurse(state);\n        }\n        ScheduledObserver.prototype.ensureActive = function() {\n            var isOwner = false;\n            if (!this.hasFaulted && this.queue.length > 0) {\n                isOwner = !this.isAcquired;\n                this.isAcquired = true;\n            }\n            isOwner && this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));\n        };\n        ScheduledObserver.prototype.dispose = function() {\n            __super__.prototype.dispose.call(this);\n            this.disposable.dispose();\n        };\n        return ScheduledObserver;\n    }(AbstractObserver);\n    var ObserveOnObserver = function(__super__) {\n        inherits(ObserveOnObserver, __super__);\n        function ObserveOnObserver(scheduler, observer, cancel) {\n            __super__.call(this, scheduler, observer);\n            this._cancel = cancel;\n        }\n        ObserveOnObserver.prototype.next = function(value) {\n            __super__.prototype.next.call(this, value);\n            this.ensureActive();\n        };\n        ObserveOnObserver.prototype.error = function(e) {\n            __super__.prototype.error.call(this, e);\n            this.ensureActive();\n        };\n        ObserveOnObserver.prototype.completed = function() {\n            __super__.prototype.completed.call(this);\n            this.ensureActive();\n        };\n        ObserveOnObserver.prototype.dispose = function() {\n            __super__.prototype.dispose.call(this);\n            this._cancel && this._cancel.dispose();\n            this._cancel = null;\n        };\n        return ObserveOnObserver;\n    }(ScheduledObserver);\n    var observableProto;\n    /**\n   * Represents a push-style collection.\n   */ var Observable = Rx.Observable = function() {\n        function makeSubscribe(self1, subscribe) {\n            return function(o) {\n                var oldOnError = o.onError;\n                o.onError = function(e) {\n                    makeStackTraceLong(e, self1);\n                    oldOnError.call(o, e);\n                };\n                return subscribe.call(self1, o);\n            };\n        }\n        function Observable() {\n            if (Rx.config.longStackSupport && hasStacks) {\n                var oldSubscribe = this._subscribe;\n                var e = tryCatch(thrower)(new Error()).e;\n                this.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n                this._subscribe = makeSubscribe(this, oldSubscribe);\n            }\n        }\n        observableProto = Observable.prototype;\n        /**\n    * Determines whether the given object is an Observable\n    * @param {Any} An object to determine whether it is an Observable\n    * @returns {Boolean} true if an Observable, else false.\n    */ Observable.isObservable = function(o) {\n            return o && isFunction(o.subscribe);\n        };\n        /**\n     *  Subscribes an o to the observable sequence.\n     *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n     */ observableProto.subscribe = observableProto.forEach = function(oOrOnNext, onError, onCompleted) {\n            return this._subscribe(typeof oOrOnNext === \"object\" ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));\n        };\n        /**\n     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n     * @param {Function} onNext The function to invoke on each element in the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */ observableProto.subscribeOnNext = function(onNext, thisArg) {\n            return this._subscribe(observerCreate(typeof thisArg !== \"undefined\" ? function(x) {\n                onNext.call(thisArg, x);\n            } : onNext));\n        };\n        /**\n     * Subscribes to an exceptional condition in the sequence with an optional \"this\" argument.\n     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */ observableProto.subscribeOnError = function(onError, thisArg) {\n            return this._subscribe(observerCreate(null, typeof thisArg !== \"undefined\" ? function(e) {\n                onError.call(thisArg, e);\n            } : onError));\n        };\n        /**\n     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */ observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {\n            return this._subscribe(observerCreate(null, null, typeof thisArg !== \"undefined\" ? function() {\n                onCompleted.call(thisArg);\n            } : onCompleted));\n        };\n        return Observable;\n    }();\n    var ObservableBase = Rx.ObservableBase = function(__super__) {\n        inherits(ObservableBase, __super__);\n        function fixSubscriber(subscriber) {\n            return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;\n        }\n        function setDisposable(s, state) {\n            var ado = state[0], self1 = state[1];\n            var sub = tryCatch(self1.subscribeCore).call(self1, ado);\n            if (sub === errorObj && !ado.fail(errorObj.e)) {\n                thrower(errorObj.e);\n            }\n            ado.setDisposable(fixSubscriber(sub));\n        }\n        function ObservableBase() {\n            __super__.call(this);\n        }\n        ObservableBase.prototype._subscribe = function(o) {\n            var ado = new AutoDetachObserver(o), state = [\n                ado,\n                this\n            ];\n            if (currentThreadScheduler.scheduleRequired()) {\n                currentThreadScheduler.schedule(state, setDisposable);\n            } else {\n                setDisposable(null, state);\n            }\n            return ado;\n        };\n        ObservableBase.prototype.subscribeCore = notImplemented;\n        return ObservableBase;\n    }(Observable);\n    var FlatMapObservable = Rx.FlatMapObservable = function(__super__) {\n        inherits(FlatMapObservable, __super__);\n        function FlatMapObservable(source, selector, resultSelector, thisArg) {\n            this.resultSelector = isFunction(resultSelector) ? resultSelector : null;\n            this.selector = bindCallback(isFunction(selector) ? selector : function() {\n                return selector;\n            }, thisArg, 3);\n            this.source = source;\n            __super__.call(this);\n        }\n        FlatMapObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));\n        };\n        inherits(InnerObserver, AbstractObserver);\n        function InnerObserver(observer, selector, resultSelector, source) {\n            this.i = 0;\n            this.selector = selector;\n            this.resultSelector = resultSelector;\n            this.source = source;\n            this.o = observer;\n            AbstractObserver.call(this);\n        }\n        InnerObserver.prototype._wrapResult = function(result, x, i) {\n            return this.resultSelector ? result.map(function(y, i2) {\n                return this.resultSelector(x, y, i, i2);\n            }, this) : result;\n        };\n        InnerObserver.prototype.next = function(x) {\n            var i = this.i++;\n            var result = tryCatch(this.selector)(x, i, this.source);\n            if (result === errorObj) {\n                return this.o.onError(result.e);\n            }\n            isPromise(result) && (result = observableFromPromise(result));\n            (isArrayLike(result) || isIterable(result)) && (result = Observable.from(result));\n            this.o.onNext(this._wrapResult(result, x, i));\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this.o.onCompleted();\n        };\n        return FlatMapObservable;\n    }(ObservableBase);\n    var Enumerable = Rx.internals.Enumerable = function() {};\n    function IsDisposedDisposable(state) {\n        this._s = state;\n        this.isDisposed = false;\n    }\n    IsDisposedDisposable.prototype.dispose = function() {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            this._s.isDisposed = true;\n        }\n    };\n    var ConcatEnumerableObservable = function(__super__) {\n        inherits(ConcatEnumerableObservable, __super__);\n        function ConcatEnumerableObservable(sources) {\n            this.sources = sources;\n            __super__.call(this);\n        }\n        function scheduleMethod(state, recurse) {\n            if (state.isDisposed) {\n                return;\n            }\n            var currentItem = tryCatch(state.e.next).call(state.e);\n            if (currentItem === errorObj) {\n                return state.o.onError(currentItem.e);\n            }\n            if (currentItem.done) {\n                return state.o.onCompleted();\n            }\n            // Check if promise\n            var currentValue = currentItem.value;\n            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n            var d = new SingleAssignmentDisposable();\n            state.subscription.setDisposable(d);\n            d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));\n        }\n        ConcatEnumerableObservable.prototype.subscribeCore = function(o) {\n            var subscription = new SerialDisposable();\n            var state = {\n                isDisposed: false,\n                o: o,\n                subscription: subscription,\n                e: this.sources[$iterator$]()\n            };\n            var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);\n            return new NAryDisposable([\n                subscription,\n                cancelable,\n                new IsDisposedDisposable(state)\n            ]);\n        };\n        function InnerObserver(state, recurse) {\n            this._state = state;\n            this._recurse = recurse;\n            AbstractObserver.call(this);\n        }\n        inherits(InnerObserver, AbstractObserver);\n        InnerObserver.prototype.next = function(x) {\n            this._state.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this._state.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this._recurse(this._state);\n        };\n        return ConcatEnumerableObservable;\n    }(ObservableBase);\n    Enumerable.prototype.concat = function() {\n        return new ConcatEnumerableObservable(this);\n    };\n    var CatchErrorObservable = function(__super__) {\n        function CatchErrorObservable(sources) {\n            this.sources = sources;\n            __super__.call(this);\n        }\n        inherits(CatchErrorObservable, __super__);\n        function scheduleMethod(state, recurse) {\n            if (state.isDisposed) {\n                return;\n            }\n            var currentItem = tryCatch(state.e.next).call(state.e);\n            if (currentItem === errorObj) {\n                return state.o.onError(currentItem.e);\n            }\n            if (currentItem.done) {\n                return state.lastError !== null ? state.o.onError(state.lastError) : state.o.onCompleted();\n            }\n            var currentValue = currentItem.value;\n            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n            var d = new SingleAssignmentDisposable();\n            state.subscription.setDisposable(d);\n            d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));\n        }\n        CatchErrorObservable.prototype.subscribeCore = function(o) {\n            var subscription = new SerialDisposable();\n            var state = {\n                isDisposed: false,\n                e: this.sources[$iterator$](),\n                subscription: subscription,\n                lastError: null,\n                o: o\n            };\n            var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);\n            return new NAryDisposable([\n                subscription,\n                cancelable,\n                new IsDisposedDisposable(state)\n            ]);\n        };\n        function InnerObserver(state, recurse) {\n            this._state = state;\n            this._recurse = recurse;\n            AbstractObserver.call(this);\n        }\n        inherits(InnerObserver, AbstractObserver);\n        InnerObserver.prototype.next = function(x) {\n            this._state.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this._state.lastError = e;\n            this._recurse(this._state);\n        };\n        InnerObserver.prototype.completed = function() {\n            this._state.o.onCompleted();\n        };\n        return CatchErrorObservable;\n    }(ObservableBase);\n    Enumerable.prototype.catchError = function() {\n        return new CatchErrorObservable(this);\n    };\n    var RepeatEnumerable = function(__super__) {\n        inherits(RepeatEnumerable, __super__);\n        function RepeatEnumerable(v, c) {\n            this.v = v;\n            this.c = c == null ? -1 : c;\n        }\n        RepeatEnumerable.prototype[$iterator$] = function() {\n            return new RepeatEnumerator(this);\n        };\n        function RepeatEnumerator(p) {\n            this.v = p.v;\n            this.l = p.c;\n        }\n        RepeatEnumerator.prototype.next = function() {\n            if (this.l === 0) {\n                return doneEnumerator;\n            }\n            if (this.l > 0) {\n                this.l--;\n            }\n            return {\n                done: false,\n                value: this.v\n            };\n        };\n        return RepeatEnumerable;\n    }(Enumerable);\n    var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {\n        return new RepeatEnumerable(value, repeatCount);\n    };\n    var OfEnumerable = function(__super__) {\n        inherits(OfEnumerable, __super__);\n        function OfEnumerable(s, fn, thisArg) {\n            this.s = s;\n            this.fn = fn ? bindCallback(fn, thisArg, 3) : null;\n        }\n        OfEnumerable.prototype[$iterator$] = function() {\n            return new OfEnumerator(this);\n        };\n        function OfEnumerator(p) {\n            this.i = -1;\n            this.s = p.s;\n            this.l = this.s.length;\n            this.fn = p.fn;\n        }\n        OfEnumerator.prototype.next = function() {\n            return ++this.i < this.l ? {\n                done: false,\n                value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)\n            } : doneEnumerator;\n        };\n        return OfEnumerable;\n    }(Enumerable);\n    var enumerableOf = Enumerable.of = function(source, selector, thisArg) {\n        return new OfEnumerable(source, selector, thisArg);\n    };\n    var ObserveOnObservable = function(__super__) {\n        inherits(ObserveOnObservable, __super__);\n        function ObserveOnObservable(source, s) {\n            this.source = source;\n            this._s = s;\n            __super__.call(this);\n        }\n        ObserveOnObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new ObserveOnObserver(this._s, o));\n        };\n        return ObserveOnObservable;\n    }(ObservableBase);\n    /**\n   *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.\n   *\n   *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects\n   *  that require to be run on a scheduler, use subscribeOn.\n   *\n   *  @param {Scheduler} scheduler Scheduler to notify observers on.\n   *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.\n   */ observableProto.observeOn = function(scheduler) {\n        return new ObserveOnObservable(this, scheduler);\n    };\n    var SubscribeOnObservable = function(__super__) {\n        inherits(SubscribeOnObservable, __super__);\n        function SubscribeOnObservable(source, s) {\n            this.source = source;\n            this._s = s;\n            __super__.call(this);\n        }\n        function scheduleMethod(scheduler, state) {\n            var source = state[0], d = state[1], o = state[2];\n            d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(o)));\n        }\n        SubscribeOnObservable.prototype.subscribeCore = function(o) {\n            var m = new SingleAssignmentDisposable(), d = new SerialDisposable();\n            d.setDisposable(m);\n            m.setDisposable(this._s.schedule([\n                this.source,\n                d,\n                o\n            ], scheduleMethod));\n            return d;\n        };\n        return SubscribeOnObservable;\n    }(ObservableBase);\n    /**\n   *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;\n   *  see the remarks section for more information on the distinction between subscribeOn and observeOn.\n\n   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer\n   *  callbacks on a scheduler, use observeOn.\n\n   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.\n   *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.\n   */ observableProto.subscribeOn = function(scheduler) {\n        return new SubscribeOnObservable(this, scheduler);\n    };\n    var FromPromiseObservable = function(__super__) {\n        inherits(FromPromiseObservable, __super__);\n        function FromPromiseObservable(p, s) {\n            this._p = p;\n            this._s = s;\n            __super__.call(this);\n        }\n        function scheduleNext(s, state) {\n            var o = state[0], data = state[1];\n            o.onNext(data);\n            o.onCompleted();\n        }\n        function scheduleError(s, state) {\n            var o = state[0], err = state[1];\n            o.onError(err);\n        }\n        FromPromiseObservable.prototype.subscribeCore = function(o) {\n            var sad = new SingleAssignmentDisposable(), self1 = this, p = this._p;\n            if (isFunction(p)) {\n                p = tryCatch(p)();\n                if (p === errorObj) {\n                    o.onError(p.e);\n                    return sad;\n                }\n            }\n            p.then(function(data) {\n                sad.setDisposable(self1._s.schedule([\n                    o,\n                    data\n                ], scheduleNext));\n            }, function(err) {\n                sad.setDisposable(self1._s.schedule([\n                    o,\n                    err\n                ], scheduleError));\n            });\n            return sad;\n        };\n        return FromPromiseObservable;\n    }(ObservableBase);\n    /**\n  * Converts a Promise to an Observable sequence\n  * @param {Promise} An ES6 Compliant promise.\n  * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.\n  */ var observableFromPromise = Observable.fromPromise = function(promise, scheduler) {\n        scheduler || (scheduler = defaultScheduler);\n        return new FromPromiseObservable(promise, scheduler);\n    };\n    /*\n   * Converts an existing observable sequence to an ES6 Compatible Promise\n   * @example\n   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);\n   *\n   * // With config\n   * Rx.config.Promise = RSVP.Promise;\n   * var promise = Rx.Observable.return(42).toPromise();\n   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.\n   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.\n   */ observableProto.toPromise = function(promiseCtor) {\n        promiseCtor || (promiseCtor = Rx.config.Promise);\n        if (!promiseCtor) {\n            throw new NotSupportedError(\"Promise type not provided nor in Rx.config.Promise\");\n        }\n        var source = this;\n        return new promiseCtor(function(resolve, reject) {\n            // No cancellation can be done\n            var value;\n            source.subscribe(function(v) {\n                value = v;\n            }, reject, function() {\n                resolve(value);\n            });\n        });\n    };\n    var ToArrayObservable = function(__super__) {\n        inherits(ToArrayObservable, __super__);\n        function ToArrayObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        ToArrayObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new InnerObserver(o));\n        };\n        inherits(InnerObserver, AbstractObserver);\n        function InnerObserver(o) {\n            this.o = o;\n            this.a = [];\n            AbstractObserver.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            this.a.push(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this.o.onNext(this.a);\n            this.o.onCompleted();\n        };\n        return ToArrayObservable;\n    }(ObservableBase);\n    /**\n  * Creates an array from an observable sequence.\n  * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.\n  */ observableProto.toArray = function() {\n        return new ToArrayObservable(this);\n    };\n    /**\n   *  Creates an observable sequence from a specified subscribe method implementation.\n   * @example\n   *  var res = Rx.Observable.create(function (observer) { return function () { } );\n   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );\n   *  var res = Rx.Observable.create(function (observer) { } );\n   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.\n   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.\n   */ Observable.create = function(subscribe, parent) {\n        return new AnonymousObservable(subscribe, parent);\n    };\n    var Defer = function(__super__) {\n        inherits(Defer, __super__);\n        function Defer(factory) {\n            this._f = factory;\n            __super__.call(this);\n        }\n        Defer.prototype.subscribeCore = function(o) {\n            var result = tryCatch(this._f)();\n            if (result === errorObj) {\n                return observableThrow(result.e).subscribe(o);\n            }\n            isPromise(result) && (result = observableFromPromise(result));\n            return result.subscribe(o);\n        };\n        return Defer;\n    }(ObservableBase);\n    /**\n   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.\n   *\n   * @example\n   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });\n   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.\n   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.\n   */ var observableDefer = Observable.defer = function(observableFactory) {\n        return new Defer(observableFactory);\n    };\n    var EmptyObservable = function(__super__) {\n        inherits(EmptyObservable, __super__);\n        function EmptyObservable(scheduler) {\n            this.scheduler = scheduler;\n            __super__.call(this);\n        }\n        EmptyObservable.prototype.subscribeCore = function(observer) {\n            var sink = new EmptySink(observer, this.scheduler);\n            return sink.run();\n        };\n        function EmptySink(observer, scheduler) {\n            this.observer = observer;\n            this.scheduler = scheduler;\n        }\n        function scheduleItem(s, state) {\n            state.onCompleted();\n            return disposableEmpty;\n        }\n        EmptySink.prototype.run = function() {\n            var state = this.observer;\n            return this.scheduler === immediateScheduler ? scheduleItem(null, state) : this.scheduler.schedule(state, scheduleItem);\n        };\n        return EmptyObservable;\n    }(ObservableBase);\n    var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);\n    /**\n   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.\n   *\n   * @example\n   *  var res = Rx.Observable.empty();\n   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);\n   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.\n   * @returns {Observable} An observable sequence with no elements.\n   */ var observableEmpty = Observable.empty = function(scheduler) {\n        isScheduler(scheduler) || (scheduler = immediateScheduler);\n        return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);\n    };\n    var FromObservable = function(__super__) {\n        inherits(FromObservable, __super__);\n        function FromObservable(iterable, fn, scheduler) {\n            this._iterable = iterable;\n            this._fn = fn;\n            this._scheduler = scheduler;\n            __super__.call(this);\n        }\n        function createScheduleMethod(o, it, fn) {\n            return function loopRecursive(i, recurse) {\n                var next = tryCatch(it.next).call(it);\n                if (next === errorObj) {\n                    return o.onError(next.e);\n                }\n                if (next.done) {\n                    return o.onCompleted();\n                }\n                var result = next.value;\n                if (isFunction(fn)) {\n                    result = tryCatch(fn)(result, i);\n                    if (result === errorObj) {\n                        return o.onError(result.e);\n                    }\n                }\n                o.onNext(result);\n                recurse(i + 1);\n            };\n        }\n        FromObservable.prototype.subscribeCore = function(o) {\n            var list = Object(this._iterable), it = getIterable(list);\n            return this._scheduler.scheduleRecursive(0, createScheduleMethod(o, it, this._fn));\n        };\n        return FromObservable;\n    }(ObservableBase);\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n    function StringIterable(s) {\n        this._s = s;\n    }\n    StringIterable.prototype[$iterator$] = function() {\n        return new StringIterator(this._s);\n    };\n    function StringIterator(s) {\n        this._s = s;\n        this._l = s.length;\n        this._i = 0;\n    }\n    StringIterator.prototype[$iterator$] = function() {\n        return this;\n    };\n    StringIterator.prototype.next = function() {\n        return this._i < this._l ? {\n            done: false,\n            value: this._s.charAt(this._i++)\n        } : doneEnumerator;\n    };\n    function ArrayIterable(a) {\n        this._a = a;\n    }\n    ArrayIterable.prototype[$iterator$] = function() {\n        return new ArrayIterator(this._a);\n    };\n    function ArrayIterator(a) {\n        this._a = a;\n        this._l = toLength(a);\n        this._i = 0;\n    }\n    ArrayIterator.prototype[$iterator$] = function() {\n        return this;\n    };\n    ArrayIterator.prototype.next = function() {\n        return this._i < this._l ? {\n            done: false,\n            value: this._a[this._i++]\n        } : doneEnumerator;\n    };\n    function numberIsFinite(value) {\n        return typeof value === \"number\" && root.isFinite(value);\n    }\n    function isNan(n) {\n        return n !== n;\n    }\n    function getIterable(o) {\n        var i = o[$iterator$], it;\n        if (!i && typeof o === \"string\") {\n            it = new StringIterable(o);\n            return it[$iterator$]();\n        }\n        if (!i && o.length !== undefined) {\n            it = new ArrayIterable(o);\n            return it[$iterator$]();\n        }\n        if (!i) {\n            throw new TypeError(\"Object is not iterable\");\n        }\n        return o[$iterator$]();\n    }\n    function sign(value) {\n        var number = +value;\n        if (number === 0) {\n            return number;\n        }\n        if (isNaN(number)) {\n            return number;\n        }\n        return number < 0 ? -1 : 1;\n    }\n    function toLength(o) {\n        var len = +o.length;\n        if (isNaN(len)) {\n            return 0;\n        }\n        if (len === 0 || !numberIsFinite(len)) {\n            return len;\n        }\n        len = sign(len) * Math.floor(Math.abs(len));\n        if (len <= 0) {\n            return 0;\n        }\n        if (len > maxSafeInteger) {\n            return maxSafeInteger;\n        }\n        return len;\n    }\n    /**\n  * This method creates a new Observable sequence from an array-like or iterable object.\n  * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.\n  * @param {Function} [mapFn] Map function to call on every element of the array.\n  * @param {Any} [thisArg] The context to use calling the mapFn if provided.\n  * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.\n  */ var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {\n        if (iterable == null) {\n            throw new Error(\"iterable cannot be null.\");\n        }\n        if (mapFn && !isFunction(mapFn)) {\n            throw new Error(\"mapFn when provided must be a function\");\n        }\n        if (mapFn) {\n            var mapper = bindCallback(mapFn, thisArg, 2);\n        }\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new FromObservable(iterable, mapper, scheduler);\n    };\n    var FromArrayObservable = function(__super__) {\n        inherits(FromArrayObservable, __super__);\n        function FromArrayObservable(args, scheduler) {\n            this._args = args;\n            this._scheduler = scheduler;\n            __super__.call(this);\n        }\n        function scheduleMethod(o, args) {\n            var len = args.length;\n            return function loopRecursive(i, recurse) {\n                if (i < len) {\n                    o.onNext(args[i]);\n                    recurse(i + 1);\n                } else {\n                    o.onCompleted();\n                }\n            };\n        }\n        FromArrayObservable.prototype.subscribeCore = function(o) {\n            return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._args));\n        };\n        return FromArrayObservable;\n    }(ObservableBase);\n    /**\n  *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.\n  * @deprecated use Observable.from or Observable.of\n  * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n  * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.\n  */ var observableFromArray = Observable.fromArray = function(array, scheduler) {\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new FromArrayObservable(array, scheduler);\n    };\n    var GenerateObservable = function(__super__) {\n        inherits(GenerateObservable, __super__);\n        function GenerateObservable(state, cndFn, itrFn, resFn, s) {\n            this._initialState = state;\n            this._cndFn = cndFn;\n            this._itrFn = itrFn;\n            this._resFn = resFn;\n            this._s = s;\n            __super__.call(this);\n        }\n        function scheduleRecursive(state, recurse) {\n            if (state.first) {\n                state.first = false;\n            } else {\n                state.newState = tryCatch(state.self._itrFn)(state.newState);\n                if (state.newState === errorObj) {\n                    return state.o.onError(state.newState.e);\n                }\n            }\n            var hasResult = tryCatch(state.self._cndFn)(state.newState);\n            if (hasResult === errorObj) {\n                return state.o.onError(hasResult.e);\n            }\n            if (hasResult) {\n                var result = tryCatch(state.self._resFn)(state.newState);\n                if (result === errorObj) {\n                    return state.o.onError(result.e);\n                }\n                state.o.onNext(result);\n                recurse(state);\n            } else {\n                state.o.onCompleted();\n            }\n        }\n        GenerateObservable.prototype.subscribeCore = function(o) {\n            var state = {\n                o: o,\n                self: this,\n                first: true,\n                newState: this._initialState\n            };\n            return this._s.scheduleRecursive(state, scheduleRecursive);\n        };\n        return GenerateObservable;\n    }(ObservableBase);\n    /**\n   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.\n   *\n   * @example\n   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });\n   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);\n   * @param {Mixed} initialState Initial state.\n   * @param {Function} condition Condition to terminate generation (upon returning false).\n   * @param {Function} iterate Iteration step function.\n   * @param {Function} resultSelector Selector function for results produced in the sequence.\n   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.\n   * @returns {Observable} The generated sequence.\n   */ Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);\n    };\n    var NeverObservable = function(__super__) {\n        inherits(NeverObservable, __super__);\n        function NeverObservable() {\n            __super__.call(this);\n        }\n        NeverObservable.prototype.subscribeCore = function(observer) {\n            return disposableEmpty;\n        };\n        return NeverObservable;\n    }(ObservableBase);\n    var NEVER_OBSERVABLE = new NeverObservable();\n    /**\n   * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).\n   * @returns {Observable} An observable sequence whose observers will never get called.\n   */ var observableNever = Observable.never = function() {\n        return NEVER_OBSERVABLE;\n    };\n    function observableOf(scheduler, array) {\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new FromArrayObservable(array, scheduler);\n    }\n    /**\n  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n  */ Observable.of = function() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        return new FromArrayObservable(args, currentThreadScheduler);\n    };\n    /**\n  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n  * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.\n  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n  */ Observable.ofWithScheduler = function(scheduler) {\n        var len = arguments.length, args = new Array(len - 1);\n        for(var i = 1; i < len; i++){\n            args[i - 1] = arguments[i];\n        }\n        return new FromArrayObservable(args, scheduler);\n    };\n    var PairsObservable = function(__super__) {\n        inherits(PairsObservable, __super__);\n        function PairsObservable(o, scheduler) {\n            this._o = o;\n            this._keys = Object.keys(o);\n            this._scheduler = scheduler;\n            __super__.call(this);\n        }\n        function scheduleMethod(o, obj, keys) {\n            return function loopRecursive(i, recurse) {\n                if (i < keys.length) {\n                    var key = keys[i];\n                    o.onNext([\n                        key,\n                        obj[key]\n                    ]);\n                    recurse(i + 1);\n                } else {\n                    o.onCompleted();\n                }\n            };\n        }\n        PairsObservable.prototype.subscribeCore = function(o) {\n            return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._o, this._keys));\n        };\n        return PairsObservable;\n    }(ObservableBase);\n    /**\n   * Convert an object into an observable sequence of [key, value] pairs.\n   * @param {Object} obj The object to inspect.\n   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n   * @returns {Observable} An observable sequence of [key, value] pairs from the object.\n   */ Observable.pairs = function(obj, scheduler) {\n        scheduler || (scheduler = currentThreadScheduler);\n        return new PairsObservable(obj, scheduler);\n    };\n    var RangeObservable = function(__super__) {\n        inherits(RangeObservable, __super__);\n        function RangeObservable(start, count, scheduler) {\n            this.start = start;\n            this.rangeCount = count;\n            this.scheduler = scheduler;\n            __super__.call(this);\n        }\n        function loopRecursive(start, count, o) {\n            return function loop(i, recurse) {\n                if (i < count) {\n                    o.onNext(start + i);\n                    recurse(i + 1);\n                } else {\n                    o.onCompleted();\n                }\n            };\n        }\n        RangeObservable.prototype.subscribeCore = function(o) {\n            return this.scheduler.scheduleRecursive(0, loopRecursive(this.start, this.rangeCount, o));\n        };\n        return RangeObservable;\n    }(ObservableBase);\n    /**\n  *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.\n  * @param {Number} start The value of the first integer in the sequence.\n  * @param {Number} count The number of sequential integers to generate.\n  * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.\n  * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.\n  */ Observable.range = function(start, count, scheduler) {\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new RangeObservable(start, count, scheduler);\n    };\n    var RepeatObservable = function(__super__) {\n        inherits(RepeatObservable, __super__);\n        function RepeatObservable(value, repeatCount, scheduler) {\n            this.value = value;\n            this.repeatCount = repeatCount == null ? -1 : repeatCount;\n            this.scheduler = scheduler;\n            __super__.call(this);\n        }\n        RepeatObservable.prototype.subscribeCore = function(observer) {\n            var sink = new RepeatSink(observer, this);\n            return sink.run();\n        };\n        return RepeatObservable;\n    }(ObservableBase);\n    function RepeatSink(observer, parent) {\n        this.observer = observer;\n        this.parent = parent;\n    }\n    RepeatSink.prototype.run = function() {\n        var observer = this.observer, value = this.parent.value;\n        function loopRecursive(i, recurse) {\n            if (i === -1 || i > 0) {\n                observer.onNext(value);\n                i > 0 && i--;\n            }\n            if (i === 0) {\n                return observer.onCompleted();\n            }\n            recurse(i);\n        }\n        return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount, loopRecursive);\n    };\n    /**\n   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.\n   * @param {Mixed} value Element to repeat.\n   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.\n   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.\n   */ Observable.repeat = function(value, repeatCount, scheduler) {\n        isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n        return new RepeatObservable(value, repeatCount, scheduler);\n    };\n    var JustObservable = function(__super__) {\n        inherits(JustObservable, __super__);\n        function JustObservable(value, scheduler) {\n            this._value = value;\n            this._scheduler = scheduler;\n            __super__.call(this);\n        }\n        JustObservable.prototype.subscribeCore = function(o) {\n            var state = [\n                this._value,\n                o\n            ];\n            return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);\n        };\n        function scheduleItem(s, state) {\n            var value = state[0], observer = state[1];\n            observer.onNext(value);\n            observer.onCompleted();\n            return disposableEmpty;\n        }\n        return JustObservable;\n    }(ObservableBase);\n    /**\n   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.\n   *  There is an alias called 'just' or browsers <IE9.\n   * @param {Mixed} value Single element in the resulting observable sequence.\n   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} An observable sequence containing the single specified element.\n   */ var observableReturn = Observable[\"return\"] = Observable.just = function(value, scheduler) {\n        isScheduler(scheduler) || (scheduler = immediateScheduler);\n        return new JustObservable(value, scheduler);\n    };\n    var ThrowObservable = function(__super__) {\n        inherits(ThrowObservable, __super__);\n        function ThrowObservable(error, scheduler) {\n            this._error = error;\n            this._scheduler = scheduler;\n            __super__.call(this);\n        }\n        ThrowObservable.prototype.subscribeCore = function(o) {\n            var state = [\n                this._error,\n                o\n            ];\n            return this._scheduler === immediateScheduler ? scheduleItem(null, state) : this._scheduler.schedule(state, scheduleItem);\n        };\n        function scheduleItem(s, state) {\n            var e = state[0], o = state[1];\n            o.onError(e);\n            return disposableEmpty;\n        }\n        return ThrowObservable;\n    }(ObservableBase);\n    /**\n   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.\n   *  There is an alias to this method called 'throwError' for browsers <IE9.\n   * @param {Mixed} error An object used for the sequence's termination.\n   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.\n   */ var observableThrow = Observable[\"throw\"] = function(error, scheduler) {\n        isScheduler(scheduler) || (scheduler = immediateScheduler);\n        return new ThrowObservable(error, scheduler);\n    };\n    var UsingObservable = function(__super__) {\n        inherits(UsingObservable, __super__);\n        function UsingObservable(resFn, obsFn) {\n            this._resFn = resFn;\n            this._obsFn = obsFn;\n            __super__.call(this);\n        }\n        UsingObservable.prototype.subscribeCore = function(o) {\n            var disposable = disposableEmpty;\n            var resource = tryCatch(this._resFn)();\n            if (resource === errorObj) {\n                return new BinaryDisposable(observableThrow(resource.e).subscribe(o), disposable);\n            }\n            resource && (disposable = resource);\n            var source = tryCatch(this._obsFn)(resource);\n            if (source === errorObj) {\n                return new BinaryDisposable(observableThrow(source.e).subscribe(o), disposable);\n            }\n            return new BinaryDisposable(source.subscribe(o), disposable);\n        };\n        return UsingObservable;\n    }(ObservableBase);\n    /**\n   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.\n   * @param {Function} resourceFactory Factory function to obtain a resource object.\n   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.\n   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.\n   */ Observable.using = function(resourceFactory, observableFactory) {\n        return new UsingObservable(resourceFactory, observableFactory);\n    };\n    /**\n   * Propagates the observable sequence or Promise that reacts first.\n   * @param {Observable} rightSource Second observable sequence or Promise.\n   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.\n   */ observableProto.amb = function(rightSource) {\n        var leftSource = this;\n        return new AnonymousObservable(function(observer) {\n            var choice, leftChoice = \"L\", rightChoice = \"R\", leftSubscription = new SingleAssignmentDisposable(), rightSubscription = new SingleAssignmentDisposable();\n            isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));\n            function choiceL() {\n                if (!choice) {\n                    choice = leftChoice;\n                    rightSubscription.dispose();\n                }\n            }\n            function choiceR() {\n                if (!choice) {\n                    choice = rightChoice;\n                    leftSubscription.dispose();\n                }\n            }\n            var leftSubscribe = observerCreate(function(left) {\n                choiceL();\n                choice === leftChoice && observer.onNext(left);\n            }, function(e) {\n                choiceL();\n                choice === leftChoice && observer.onError(e);\n            }, function() {\n                choiceL();\n                choice === leftChoice && observer.onCompleted();\n            });\n            var rightSubscribe = observerCreate(function(right) {\n                choiceR();\n                choice === rightChoice && observer.onNext(right);\n            }, function(e) {\n                choiceR();\n                choice === rightChoice && observer.onError(e);\n            }, function() {\n                choiceR();\n                choice === rightChoice && observer.onCompleted();\n            });\n            leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));\n            rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));\n            return new BinaryDisposable(leftSubscription, rightSubscription);\n        });\n    };\n    function amb(p, c) {\n        return p.amb(c);\n    }\n    /**\n   * Propagates the observable sequence or Promise that reacts first.\n   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.\n   */ Observable.amb = function() {\n        var acc = observableNever(), items;\n        if (Array.isArray(arguments[0])) {\n            items = arguments[0];\n        } else {\n            var len = arguments.length;\n            items = new Array(items);\n            for(var i = 0; i < len; i++){\n                items[i] = arguments[i];\n            }\n        }\n        for(var i = 0, len = items.length; i < len; i++){\n            acc = amb(acc, items[i]);\n        }\n        return acc;\n    };\n    var CatchObservable = function(__super__) {\n        inherits(CatchObservable, __super__);\n        function CatchObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        CatchObservable.prototype.subscribeCore = function(o) {\n            var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();\n            subscription.setDisposable(d1);\n            d1.setDisposable(this.source.subscribe(new CatchObserver(o, subscription, this._fn)));\n            return subscription;\n        };\n        return CatchObservable;\n    }(ObservableBase);\n    var CatchObserver = function(__super__) {\n        inherits(CatchObserver, __super__);\n        function CatchObserver(o, s, fn) {\n            this._o = o;\n            this._s = s;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        CatchObserver.prototype.next = function(x) {\n            this._o.onNext(x);\n        };\n        CatchObserver.prototype.completed = function() {\n            return this._o.onCompleted();\n        };\n        CatchObserver.prototype.error = function(e) {\n            var result = tryCatch(this._fn)(e);\n            if (result === errorObj) {\n                return this._o.onError(result.e);\n            }\n            isPromise(result) && (result = observableFromPromise(result));\n            var d = new SingleAssignmentDisposable();\n            this._s.setDisposable(d);\n            d.setDisposable(result.subscribe(this._o));\n        };\n        return CatchObserver;\n    }(AbstractObserver);\n    /**\n   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.\n   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.\n   */ observableProto[\"catch\"] = function(handlerOrSecond) {\n        return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([\n            this,\n            handlerOrSecond\n        ]);\n    };\n    /**\n   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.\n   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.\n   */ var observableCatch = Observable[\"catch\"] = function() {\n        var items;\n        if (Array.isArray(arguments[0])) {\n            items = arguments[0];\n        } else {\n            var len = arguments.length;\n            items = new Array(len);\n            for(var i = 0; i < len; i++){\n                items[i] = arguments[i];\n            }\n        }\n        return enumerableOf(items).catchError();\n    };\n    /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n   * This can be in the form of an argument list of observables or an array.\n   *\n   * @example\n   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */ observableProto.combineLatest = function() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        if (Array.isArray(args[0])) {\n            args[0].unshift(this);\n        } else {\n            args.unshift(this);\n        }\n        return combineLatest.apply(this, args);\n    };\n    function falseFactory() {\n        return false;\n    }\n    function argumentsToArray() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        return args;\n    }\n    var CombineLatestObservable = function(__super__) {\n        inherits(CombineLatestObservable, __super__);\n        function CombineLatestObservable(params, cb) {\n            this._params = params;\n            this._cb = cb;\n            __super__.call(this);\n        }\n        CombineLatestObservable.prototype.subscribeCore = function(observer) {\n            var len = this._params.length, subscriptions = new Array(len);\n            var state = {\n                hasValue: arrayInitialize(len, falseFactory),\n                hasValueAll: false,\n                isDone: arrayInitialize(len, falseFactory),\n                values: new Array(len)\n            };\n            for(var i = 0; i < len; i++){\n                var source = this._params[i], sad = new SingleAssignmentDisposable();\n                subscriptions[i] = sad;\n                isPromise(source) && (source = observableFromPromise(source));\n                sad.setDisposable(source.subscribe(new CombineLatestObserver(observer, i, this._cb, state)));\n            }\n            return new NAryDisposable(subscriptions);\n        };\n        return CombineLatestObservable;\n    }(ObservableBase);\n    var CombineLatestObserver = function(__super__) {\n        inherits(CombineLatestObserver, __super__);\n        function CombineLatestObserver(o, i, cb, state) {\n            this._o = o;\n            this._i = i;\n            this._cb = cb;\n            this._state = state;\n            __super__.call(this);\n        }\n        function notTheSame(i) {\n            return function(x, j) {\n                return j !== i;\n            };\n        }\n        CombineLatestObserver.prototype.next = function(x) {\n            this._state.values[this._i] = x;\n            this._state.hasValue[this._i] = true;\n            if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.every(identity))) {\n                var res = tryCatch(this._cb).apply(null, this._state.values);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                this._o.onNext(res);\n            } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {\n                this._o.onCompleted();\n            }\n        };\n        CombineLatestObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        CombineLatestObserver.prototype.completed = function() {\n            this._state.isDone[this._i] = true;\n            this._state.isDone.every(identity) && this._o.onCompleted();\n        };\n        return CombineLatestObserver;\n    }(AbstractObserver);\n    /**\n  * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n  *\n  * @example\n  * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n  * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n  * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n  */ var combineLatest = Observable.combineLatest = function() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n        Array.isArray(args[0]) && (args = args[0]);\n        return new CombineLatestObservable(args, resultSelector);\n    };\n    /**\n   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.\n   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n   */ observableProto.concat = function() {\n        for(var args = [], i = 0, len = arguments.length; i < len; i++){\n            args.push(arguments[i]);\n        }\n        args.unshift(this);\n        return observableConcat.apply(null, args);\n    };\n    var ConcatObserver = function(__super__) {\n        inherits(ConcatObserver, __super__);\n        function ConcatObserver(s, fn) {\n            this._s = s;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        ConcatObserver.prototype.next = function(x) {\n            this._s.o.onNext(x);\n        };\n        ConcatObserver.prototype.error = function(e) {\n            this._s.o.onError(e);\n        };\n        ConcatObserver.prototype.completed = function() {\n            this._s.i++;\n            this._fn(this._s);\n        };\n        return ConcatObserver;\n    }(AbstractObserver);\n    var ConcatObservable = function(__super__) {\n        inherits(ConcatObservable, __super__);\n        function ConcatObservable(sources) {\n            this._sources = sources;\n            __super__.call(this);\n        }\n        function scheduleRecursive(state, recurse) {\n            if (state.disposable.isDisposed) {\n                return;\n            }\n            if (state.i === state.sources.length) {\n                return state.o.onCompleted();\n            }\n            // Check if promise\n            var currentValue = state.sources[state.i];\n            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n            var d = new SingleAssignmentDisposable();\n            state.subscription.setDisposable(d);\n            d.setDisposable(currentValue.subscribe(new ConcatObserver(state, recurse)));\n        }\n        ConcatObservable.prototype.subscribeCore = function(o) {\n            var subscription = new SerialDisposable();\n            var disposable = disposableCreate(noop);\n            var state = {\n                o: o,\n                i: 0,\n                subscription: subscription,\n                disposable: disposable,\n                sources: this._sources\n            };\n            var cancelable = immediateScheduler.scheduleRecursive(state, scheduleRecursive);\n            return new NAryDisposable([\n                subscription,\n                disposable,\n                cancelable\n            ]);\n        };\n        return ConcatObservable;\n    }(ObservableBase);\n    /**\n   * Concatenates all the observable sequences.\n   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.\n   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n   */ var observableConcat = Observable.concat = function() {\n        var args;\n        if (Array.isArray(arguments[0])) {\n            args = arguments[0];\n        } else {\n            args = new Array(arguments.length);\n            for(var i = 0, len = arguments.length; i < len; i++){\n                args[i] = arguments[i];\n            }\n        }\n        return new ConcatObservable(args);\n    };\n    /**\n   * Concatenates an observable sequence of observable sequences.\n   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.\n   */ observableProto.concatAll = function() {\n        return this.merge(1);\n    };\n    var MergeObservable = function(__super__) {\n        inherits(MergeObservable, __super__);\n        function MergeObservable(source, maxConcurrent) {\n            this.source = source;\n            this.maxConcurrent = maxConcurrent;\n            __super__.call(this);\n        }\n        MergeObservable.prototype.subscribeCore = function(observer) {\n            var g = new CompositeDisposable();\n            g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));\n            return g;\n        };\n        return MergeObservable;\n    }(ObservableBase);\n    var MergeObserver = function(__super__) {\n        function MergeObserver(o, max, g) {\n            this.o = o;\n            this.max = max;\n            this.g = g;\n            this.done = false;\n            this.q = [];\n            this.activeCount = 0;\n            __super__.call(this);\n        }\n        inherits(MergeObserver, __super__);\n        MergeObserver.prototype.handleSubscribe = function(xs) {\n            var sad = new SingleAssignmentDisposable();\n            this.g.add(sad);\n            isPromise(xs) && (xs = observableFromPromise(xs));\n            sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));\n        };\n        MergeObserver.prototype.next = function(innerSource) {\n            if (this.activeCount < this.max) {\n                this.activeCount++;\n                this.handleSubscribe(innerSource);\n            } else {\n                this.q.push(innerSource);\n            }\n        };\n        MergeObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        MergeObserver.prototype.completed = function() {\n            this.done = true;\n            this.activeCount === 0 && this.o.onCompleted();\n        };\n        function InnerObserver(parent, sad) {\n            this.parent = parent;\n            this.sad = sad;\n            __super__.call(this);\n        }\n        inherits(InnerObserver, __super__);\n        InnerObserver.prototype.next = function(x) {\n            this.parent.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.parent.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this.parent.g.remove(this.sad);\n            if (this.parent.q.length > 0) {\n                this.parent.handleSubscribe(this.parent.q.shift());\n            } else {\n                this.parent.activeCount--;\n                this.parent.done && this.parent.activeCount === 0 && this.parent.o.onCompleted();\n            }\n        };\n        return MergeObserver;\n    }(AbstractObserver);\n    /**\n  * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.\n  * Or merges two observable sequences into a single observable sequence.\n  * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.\n  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n  */ observableProto.merge = function(maxConcurrentOrOther) {\n        return typeof maxConcurrentOrOther !== \"number\" ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);\n    };\n    /**\n   * Merges all the observable sequences into a single observable sequence.\n   * The scheduler is optional and if not specified, the immediate scheduler is used.\n   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.\n   */ var observableMerge = Observable.merge = function() {\n        var scheduler, sources = [], i, len = arguments.length;\n        if (!arguments[0]) {\n            scheduler = immediateScheduler;\n            for(i = 1; i < len; i++){\n                sources.push(arguments[i]);\n            }\n        } else if (isScheduler(arguments[0])) {\n            scheduler = arguments[0];\n            for(i = 1; i < len; i++){\n                sources.push(arguments[i]);\n            }\n        } else {\n            scheduler = immediateScheduler;\n            for(i = 0; i < len; i++){\n                sources.push(arguments[i]);\n            }\n        }\n        if (Array.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        return observableOf(scheduler, sources).mergeAll();\n    };\n    var CompositeError = Rx.CompositeError = function(errors) {\n        this.innerErrors = errors;\n        this.message = \"This contains multiple errors. Check the innerErrors\";\n        Error.call(this);\n    };\n    CompositeError.prototype = Object.create(Error.prototype);\n    CompositeError.prototype.name = \"CompositeError\";\n    var MergeDelayErrorObservable = function(__super__) {\n        inherits(MergeDelayErrorObservable, __super__);\n        function MergeDelayErrorObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        MergeDelayErrorObservable.prototype.subscribeCore = function(o) {\n            var group = new CompositeDisposable(), m = new SingleAssignmentDisposable(), state = {\n                isStopped: false,\n                errors: [],\n                o: o\n            };\n            group.add(m);\n            m.setDisposable(this.source.subscribe(new MergeDelayErrorObserver(group, state)));\n            return group;\n        };\n        return MergeDelayErrorObservable;\n    }(ObservableBase);\n    var MergeDelayErrorObserver = function(__super__) {\n        inherits(MergeDelayErrorObserver, __super__);\n        function MergeDelayErrorObserver(group, state) {\n            this._group = group;\n            this._state = state;\n            __super__.call(this);\n        }\n        function setCompletion(o, errors) {\n            if (errors.length === 0) {\n                o.onCompleted();\n            } else if (errors.length === 1) {\n                o.onError(errors[0]);\n            } else {\n                o.onError(new CompositeError(errors));\n            }\n        }\n        MergeDelayErrorObserver.prototype.next = function(x) {\n            var inner = new SingleAssignmentDisposable();\n            this._group.add(inner);\n            // Check for promises support\n            isPromise(x) && (x = observableFromPromise(x));\n            inner.setDisposable(x.subscribe(new InnerObserver(inner, this._group, this._state)));\n        };\n        MergeDelayErrorObserver.prototype.error = function(e) {\n            this._state.errors.push(e);\n            this._state.isStopped = true;\n            this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n        };\n        MergeDelayErrorObserver.prototype.completed = function() {\n            this._state.isStopped = true;\n            this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n        };\n        inherits(InnerObserver, __super__);\n        function InnerObserver(inner, group, state) {\n            this._inner = inner;\n            this._group = group;\n            this._state = state;\n            __super__.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            this._state.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this._state.errors.push(e);\n            this._group.remove(this._inner);\n            this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n        };\n        InnerObserver.prototype.completed = function() {\n            this._group.remove(this._inner);\n            this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n        };\n        return MergeDelayErrorObserver;\n    }(AbstractObserver);\n    /**\n  * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to\n  * receive all successfully emitted items from all of the source Observables without being interrupted by\n  * an error notification from one of them.\n  *\n  * This behaves like Observable.prototype.mergeAll except that if any of the merged Observables notify of an\n  * error via the Observer's onError, mergeDelayError will refrain from propagating that\n  * error notification until all of the merged Observables have finished emitting items.\n  * @param {Array | Arguments} args Arguments or an array to merge.\n  * @returns {Observable} an Observable that emits all of the items emitted by the Observables emitted by the Observable\n  */ Observable.mergeDelayError = function() {\n        var args;\n        if (Array.isArray(arguments[0])) {\n            args = arguments[0];\n        } else {\n            var len = arguments.length;\n            args = new Array(len);\n            for(var i = 0; i < len; i++){\n                args[i] = arguments[i];\n            }\n        }\n        var source = observableOf(null, args);\n        return new MergeDelayErrorObservable(source);\n    };\n    var MergeAllObservable = function(__super__) {\n        inherits(MergeAllObservable, __super__);\n        function MergeAllObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        MergeAllObservable.prototype.subscribeCore = function(o) {\n            var g = new CompositeDisposable(), m = new SingleAssignmentDisposable();\n            g.add(m);\n            m.setDisposable(this.source.subscribe(new MergeAllObserver(o, g)));\n            return g;\n        };\n        return MergeAllObservable;\n    }(ObservableBase);\n    var MergeAllObserver = function(__super__) {\n        function MergeAllObserver(o, g) {\n            this.o = o;\n            this.g = g;\n            this.done = false;\n            __super__.call(this);\n        }\n        inherits(MergeAllObserver, __super__);\n        MergeAllObserver.prototype.next = function(innerSource) {\n            var sad = new SingleAssignmentDisposable();\n            this.g.add(sad);\n            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n            sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));\n        };\n        MergeAllObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        MergeAllObserver.prototype.completed = function() {\n            this.done = true;\n            this.g.length === 1 && this.o.onCompleted();\n        };\n        function InnerObserver(parent, sad) {\n            this.parent = parent;\n            this.sad = sad;\n            __super__.call(this);\n        }\n        inherits(InnerObserver, __super__);\n        InnerObserver.prototype.next = function(x) {\n            this.parent.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.parent.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this.parent.g.remove(this.sad);\n            this.parent.done && this.parent.g.length === 1 && this.parent.o.onCompleted();\n        };\n        return MergeAllObserver;\n    }(AbstractObserver);\n    /**\n  * Merges an observable sequence of observable sequences into an observable sequence.\n  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n  */ observableProto.mergeAll = function() {\n        return new MergeAllObservable(this);\n    };\n    /**\n   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.\n   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.\n   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.\n   */ observableProto.onErrorResumeNext = function(second) {\n        if (!second) {\n            throw new Error(\"Second observable is required\");\n        }\n        return onErrorResumeNext([\n            this,\n            second\n        ]);\n    };\n    var OnErrorResumeNextObservable = function(__super__) {\n        inherits(OnErrorResumeNextObservable, __super__);\n        function OnErrorResumeNextObservable(sources) {\n            this.sources = sources;\n            __super__.call(this);\n        }\n        function scheduleMethod(state, recurse) {\n            if (state.pos < state.sources.length) {\n                var current = state.sources[state.pos++];\n                isPromise(current) && (current = observableFromPromise(current));\n                var d = new SingleAssignmentDisposable();\n                state.subscription.setDisposable(d);\n                d.setDisposable(current.subscribe(new OnErrorResumeNextObserver(state, recurse)));\n            } else {\n                state.o.onCompleted();\n            }\n        }\n        OnErrorResumeNextObservable.prototype.subscribeCore = function(o) {\n            var subscription = new SerialDisposable(), state = {\n                pos: 0,\n                subscription: subscription,\n                o: o,\n                sources: this.sources\n            }, cancellable = immediateScheduler.scheduleRecursive(state, scheduleMethod);\n            return new BinaryDisposable(subscription, cancellable);\n        };\n        return OnErrorResumeNextObservable;\n    }(ObservableBase);\n    var OnErrorResumeNextObserver = function(__super__) {\n        inherits(OnErrorResumeNextObserver, __super__);\n        function OnErrorResumeNextObserver(state, recurse) {\n            this._state = state;\n            this._recurse = recurse;\n            __super__.call(this);\n        }\n        OnErrorResumeNextObserver.prototype.next = function(x) {\n            this._state.o.onNext(x);\n        };\n        OnErrorResumeNextObserver.prototype.error = function() {\n            this._recurse(this._state);\n        };\n        OnErrorResumeNextObserver.prototype.completed = function() {\n            this._recurse(this._state);\n        };\n        return OnErrorResumeNextObserver;\n    }(AbstractObserver);\n    /**\n   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.\n   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.\n   */ var onErrorResumeNext = Observable.onErrorResumeNext = function() {\n        var sources = [];\n        if (Array.isArray(arguments[0])) {\n            sources = arguments[0];\n        } else {\n            var len = arguments.length;\n            sources = new Array(len);\n            for(var i = 0; i < len; i++){\n                sources[i] = arguments[i];\n            }\n        }\n        return new OnErrorResumeNextObservable(sources);\n    };\n    var SkipUntilObservable = function(__super__) {\n        inherits(SkipUntilObservable, __super__);\n        function SkipUntilObservable(source, other) {\n            this._s = source;\n            this._o = isPromise(other) ? observableFromPromise(other) : other;\n            this._open = false;\n            __super__.call(this);\n        }\n        SkipUntilObservable.prototype.subscribeCore = function(o) {\n            var leftSubscription = new SingleAssignmentDisposable();\n            leftSubscription.setDisposable(this._s.subscribe(new SkipUntilSourceObserver(o, this)));\n            isPromise(this._o) && (this._o = observableFromPromise(this._o));\n            var rightSubscription = new SingleAssignmentDisposable();\n            rightSubscription.setDisposable(this._o.subscribe(new SkipUntilOtherObserver(o, this, rightSubscription)));\n            return new BinaryDisposable(leftSubscription, rightSubscription);\n        };\n        return SkipUntilObservable;\n    }(ObservableBase);\n    var SkipUntilSourceObserver = function(__super__) {\n        inherits(SkipUntilSourceObserver, __super__);\n        function SkipUntilSourceObserver(o, p) {\n            this._o = o;\n            this._p = p;\n            __super__.call(this);\n        }\n        SkipUntilSourceObserver.prototype.next = function(x) {\n            this._p._open && this._o.onNext(x);\n        };\n        SkipUntilSourceObserver.prototype.error = function(err) {\n            this._o.onError(err);\n        };\n        SkipUntilSourceObserver.prototype.onCompleted = function() {\n            this._p._open && this._o.onCompleted();\n        };\n        return SkipUntilSourceObserver;\n    }(AbstractObserver);\n    var SkipUntilOtherObserver = function(__super__) {\n        inherits(SkipUntilOtherObserver, __super__);\n        function SkipUntilOtherObserver(o, p, r) {\n            this._o = o;\n            this._p = p;\n            this._r = r;\n            __super__.call(this);\n        }\n        SkipUntilOtherObserver.prototype.next = function() {\n            this._p._open = true;\n            this._r.dispose();\n        };\n        SkipUntilOtherObserver.prototype.error = function(err) {\n            this._o.onError(err);\n        };\n        SkipUntilOtherObserver.prototype.onCompleted = function() {\n            this._r.dispose();\n        };\n        return SkipUntilOtherObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the values from the source observable sequence only after the other observable sequence produces a value.\n   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.\n   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.\n   */ observableProto.skipUntil = function(other) {\n        return new SkipUntilObservable(this, other);\n    };\n    var SwitchObservable = function(__super__) {\n        inherits(SwitchObservable, __super__);\n        function SwitchObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        SwitchObservable.prototype.subscribeCore = function(o) {\n            var inner = new SerialDisposable(), s = this.source.subscribe(new SwitchObserver(o, inner));\n            return new BinaryDisposable(s, inner);\n        };\n        inherits(SwitchObserver, AbstractObserver);\n        function SwitchObserver(o, inner) {\n            this.o = o;\n            this.inner = inner;\n            this.stopped = false;\n            this.latest = 0;\n            this.hasLatest = false;\n            AbstractObserver.call(this);\n        }\n        SwitchObserver.prototype.next = function(innerSource) {\n            var d = new SingleAssignmentDisposable(), id = ++this.latest;\n            this.hasLatest = true;\n            this.inner.setDisposable(d);\n            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n            d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));\n        };\n        SwitchObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        SwitchObserver.prototype.completed = function() {\n            this.stopped = true;\n            !this.hasLatest && this.o.onCompleted();\n        };\n        inherits(InnerObserver, AbstractObserver);\n        function InnerObserver(parent, id) {\n            this.parent = parent;\n            this.id = id;\n            AbstractObserver.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            this.parent.latest === this.id && this.parent.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.parent.latest === this.id && this.parent.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            if (this.parent.latest === this.id) {\n                this.parent.hasLatest = false;\n                this.parent.stopped && this.parent.o.onCompleted();\n            }\n        };\n        return SwitchObservable;\n    }(ObservableBase);\n    /**\n  * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.\n  * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.\n  */ observableProto[\"switch\"] = observableProto.switchLatest = function() {\n        return new SwitchObservable(this);\n    };\n    var TakeUntilObservable = function(__super__) {\n        inherits(TakeUntilObservable, __super__);\n        function TakeUntilObservable(source, other) {\n            this.source = source;\n            this.other = isPromise(other) ? observableFromPromise(other) : other;\n            __super__.call(this);\n        }\n        TakeUntilObservable.prototype.subscribeCore = function(o) {\n            return new BinaryDisposable(this.source.subscribe(o), this.other.subscribe(new TakeUntilObserver(o)));\n        };\n        return TakeUntilObservable;\n    }(ObservableBase);\n    var TakeUntilObserver = function(__super__) {\n        inherits(TakeUntilObserver, __super__);\n        function TakeUntilObserver(o) {\n            this._o = o;\n            __super__.call(this);\n        }\n        TakeUntilObserver.prototype.next = function() {\n            this._o.onCompleted();\n        };\n        TakeUntilObserver.prototype.error = function(err) {\n            this._o.onError(err);\n        };\n        TakeUntilObserver.prototype.onCompleted = noop;\n        return TakeUntilObserver;\n    }(AbstractObserver);\n    /**\n   * Returns the values from the source observable sequence until the other observable sequence produces a value.\n   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.\n   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.\n   */ observableProto.takeUntil = function(other) {\n        return new TakeUntilObservable(this, other);\n    };\n    function falseFactory() {\n        return false;\n    }\n    function argumentsToArray() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        return args;\n    }\n    var WithLatestFromObservable = function(__super__) {\n        inherits(WithLatestFromObservable, __super__);\n        function WithLatestFromObservable(source, sources, resultSelector) {\n            this._s = source;\n            this._ss = sources;\n            this._cb = resultSelector;\n            __super__.call(this);\n        }\n        WithLatestFromObservable.prototype.subscribeCore = function(o) {\n            var len = this._ss.length;\n            var state = {\n                hasValue: arrayInitialize(len, falseFactory),\n                hasValueAll: false,\n                values: new Array(len)\n            };\n            var n = this._ss.length, subscriptions = new Array(n + 1);\n            for(var i = 0; i < n; i++){\n                var other = this._ss[i], sad = new SingleAssignmentDisposable();\n                isPromise(other) && (other = observableFromPromise(other));\n                sad.setDisposable(other.subscribe(new WithLatestFromOtherObserver(o, i, state)));\n                subscriptions[i] = sad;\n            }\n            var outerSad = new SingleAssignmentDisposable();\n            outerSad.setDisposable(this._s.subscribe(new WithLatestFromSourceObserver(o, this._cb, state)));\n            subscriptions[n] = outerSad;\n            return new NAryDisposable(subscriptions);\n        };\n        return WithLatestFromObservable;\n    }(ObservableBase);\n    var WithLatestFromOtherObserver = function(__super__) {\n        inherits(WithLatestFromOtherObserver, __super__);\n        function WithLatestFromOtherObserver(o, i, state) {\n            this._o = o;\n            this._i = i;\n            this._state = state;\n            __super__.call(this);\n        }\n        WithLatestFromOtherObserver.prototype.next = function(x) {\n            this._state.values[this._i] = x;\n            this._state.hasValue[this._i] = true;\n            this._state.hasValueAll = this._state.hasValue.every(identity);\n        };\n        WithLatestFromOtherObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        WithLatestFromOtherObserver.prototype.completed = noop;\n        return WithLatestFromOtherObserver;\n    }(AbstractObserver);\n    var WithLatestFromSourceObserver = function(__super__) {\n        inherits(WithLatestFromSourceObserver, __super__);\n        function WithLatestFromSourceObserver(o, cb, state) {\n            this._o = o;\n            this._cb = cb;\n            this._state = state;\n            __super__.call(this);\n        }\n        WithLatestFromSourceObserver.prototype.next = function(x) {\n            var allValues = [\n                x\n            ].concat(this._state.values);\n            if (!this._state.hasValueAll) {\n                return;\n            }\n            var res = tryCatch(this._cb).apply(null, allValues);\n            if (res === errorObj) {\n                return this._o.onError(res.e);\n            }\n            this._o.onNext(res);\n        };\n        WithLatestFromSourceObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        WithLatestFromSourceObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return WithLatestFromSourceObserver;\n    }(AbstractObserver);\n    /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */ observableProto.withLatestFrom = function() {\n        if (arguments.length === 0) {\n            throw new Error(\"invalid arguments\");\n        }\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n        Array.isArray(args[0]) && (args = args[0]);\n        return new WithLatestFromObservable(this, args, resultSelector);\n    };\n    function falseFactory() {\n        return false;\n    }\n    function emptyArrayFactory() {\n        return [];\n    }\n    var ZipObservable = function(__super__) {\n        inherits(ZipObservable, __super__);\n        function ZipObservable(sources, resultSelector) {\n            this._s = sources;\n            this._cb = resultSelector;\n            __super__.call(this);\n        }\n        ZipObservable.prototype.subscribeCore = function(observer) {\n            var n = this._s.length, subscriptions = new Array(n), done = arrayInitialize(n, falseFactory), q = arrayInitialize(n, emptyArrayFactory);\n            for(var i = 0; i < n; i++){\n                var source = this._s[i], sad = new SingleAssignmentDisposable();\n                subscriptions[i] = sad;\n                isPromise(source) && (source = observableFromPromise(source));\n                sad.setDisposable(source.subscribe(new ZipObserver(observer, i, this, q, done)));\n            }\n            return new NAryDisposable(subscriptions);\n        };\n        return ZipObservable;\n    }(ObservableBase);\n    var ZipObserver = function(__super__) {\n        inherits(ZipObserver, __super__);\n        function ZipObserver(o, i, p, q, d) {\n            this._o = o;\n            this._i = i;\n            this._p = p;\n            this._q = q;\n            this._d = d;\n            __super__.call(this);\n        }\n        function notEmpty(x) {\n            return x.length > 0;\n        }\n        function shiftEach(x) {\n            return x.shift();\n        }\n        function notTheSame(i) {\n            return function(x, j) {\n                return j !== i;\n            };\n        }\n        ZipObserver.prototype.next = function(x) {\n            this._q[this._i].push(x);\n            if (this._q.every(notEmpty)) {\n                var queuedValues = this._q.map(shiftEach);\n                var res = tryCatch(this._p._cb).apply(null, queuedValues);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                this._o.onNext(res);\n            } else if (this._d.filter(notTheSame(this._i)).every(identity)) {\n                this._o.onCompleted();\n            }\n        };\n        ZipObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ZipObserver.prototype.completed = function() {\n            this._d[this._i] = true;\n            this._d.every(identity) && this._o.onCompleted();\n        };\n        return ZipObserver;\n    }(AbstractObserver);\n    /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.\n   */ observableProto.zip = function() {\n        if (arguments.length === 0) {\n            throw new Error(\"invalid arguments\");\n        }\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n        Array.isArray(args[0]) && (args = args[0]);\n        var parent = this;\n        args.unshift(parent);\n        return new ZipObservable(args, resultSelector);\n    };\n    /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.\n   * @param arguments Observable sources.\n   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */ Observable.zip = function() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        if (Array.isArray(args[0])) {\n            args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];\n        }\n        var first = args.shift();\n        return first.zip.apply(first, args);\n    };\n    function falseFactory() {\n        return false;\n    }\n    function emptyArrayFactory() {\n        return [];\n    }\n    function argumentsToArray() {\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        return args;\n    }\n    var ZipIterableObservable = function(__super__) {\n        inherits(ZipIterableObservable, __super__);\n        function ZipIterableObservable(sources, cb) {\n            this.sources = sources;\n            this._cb = cb;\n            __super__.call(this);\n        }\n        ZipIterableObservable.prototype.subscribeCore = function(o) {\n            var sources = this.sources, len = sources.length, subscriptions = new Array(len);\n            var state = {\n                q: arrayInitialize(len, emptyArrayFactory),\n                done: arrayInitialize(len, falseFactory),\n                cb: this._cb,\n                o: o\n            };\n            for(var i = 0; i < len; i++){\n                (function(i) {\n                    var source = sources[i], sad = new SingleAssignmentDisposable();\n                    (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));\n                    subscriptions[i] = sad;\n                    sad.setDisposable(source.subscribe(new ZipIterableObserver(state, i)));\n                })(i);\n            }\n            return new NAryDisposable(subscriptions);\n        };\n        return ZipIterableObservable;\n    }(ObservableBase);\n    var ZipIterableObserver = function(__super__) {\n        inherits(ZipIterableObserver, __super__);\n        function ZipIterableObserver(s, i) {\n            this._s = s;\n            this._i = i;\n            __super__.call(this);\n        }\n        function notEmpty(x) {\n            return x.length > 0;\n        }\n        function shiftEach(x) {\n            return x.shift();\n        }\n        function notTheSame(i) {\n            return function(x, j) {\n                return j !== i;\n            };\n        }\n        ZipIterableObserver.prototype.next = function(x) {\n            this._s.q[this._i].push(x);\n            if (this._s.q.every(notEmpty)) {\n                var queuedValues = this._s.q.map(shiftEach), res = tryCatch(this._s.cb).apply(null, queuedValues);\n                if (res === errorObj) {\n                    return this._s.o.onError(res.e);\n                }\n                this._s.o.onNext(res);\n            } else if (this._s.done.filter(notTheSame(this._i)).every(identity)) {\n                this._s.o.onCompleted();\n            }\n        };\n        ZipIterableObserver.prototype.error = function(e) {\n            this._s.o.onError(e);\n        };\n        ZipIterableObserver.prototype.completed = function() {\n            this._s.done[this._i] = true;\n            this._s.done.every(identity) && this._s.o.onCompleted();\n        };\n        return ZipIterableObserver;\n    }(AbstractObserver);\n    /**\n * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.\n * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.\n */ observableProto.zipIterable = function() {\n        if (arguments.length === 0) {\n            throw new Error(\"invalid arguments\");\n        }\n        var len = arguments.length, args = new Array(len);\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n        var parent = this;\n        args.unshift(parent);\n        return new ZipIterableObservable(args, resultSelector);\n    };\n    function asObservable(source) {\n        return function subscribe(o) {\n            return source.subscribe(o);\n        };\n    }\n    /**\n   *  Hides the identity of an observable sequence.\n   * @returns {Observable} An observable sequence that hides the identity of the source sequence.\n   */ observableProto.asObservable = function() {\n        return new AnonymousObservable(asObservable(this), this);\n    };\n    function toArray(x) {\n        return x.toArray();\n    }\n    function notEmpty(x) {\n        return x.length > 0;\n    }\n    /**\n   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.\n   * @param {Number} count Length of each buffer.\n   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.\n   * @returns {Observable} An observable sequence of buffers.\n   */ observableProto.bufferWithCount = observableProto.bufferCount = function(count, skip) {\n        typeof skip !== \"number\" && (skip = count);\n        return this.windowWithCount(count, skip).flatMap(toArray).filter(notEmpty);\n    };\n    var DematerializeObservable = function(__super__) {\n        inherits(DematerializeObservable, __super__);\n        function DematerializeObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        DematerializeObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new DematerializeObserver(o));\n        };\n        return DematerializeObservable;\n    }(ObservableBase);\n    var DematerializeObserver = function(__super__) {\n        inherits(DematerializeObserver, __super__);\n        function DematerializeObserver(o) {\n            this._o = o;\n            __super__.call(this);\n        }\n        DematerializeObserver.prototype.next = function(x) {\n            x.accept(this._o);\n        };\n        DematerializeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        DematerializeObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return DematerializeObserver;\n    }(AbstractObserver);\n    /**\n   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.\n   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.\n   */ observableProto.dematerialize = function() {\n        return new DematerializeObservable(this);\n    };\n    var DistinctUntilChangedObservable = function(__super__) {\n        inherits(DistinctUntilChangedObservable, __super__);\n        function DistinctUntilChangedObservable(source, keyFn, comparer) {\n            this.source = source;\n            this.keyFn = keyFn;\n            this.comparer = comparer;\n            __super__.call(this);\n        }\n        DistinctUntilChangedObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));\n        };\n        return DistinctUntilChangedObservable;\n    }(ObservableBase);\n    var DistinctUntilChangedObserver = function(__super__) {\n        inherits(DistinctUntilChangedObserver, __super__);\n        function DistinctUntilChangedObserver(o, keyFn, comparer) {\n            this.o = o;\n            this.keyFn = keyFn;\n            this.comparer = comparer;\n            this.hasCurrentKey = false;\n            this.currentKey = null;\n            __super__.call(this);\n        }\n        DistinctUntilChangedObserver.prototype.next = function(x) {\n            var key = x, comparerEquals;\n            if (isFunction(this.keyFn)) {\n                key = tryCatch(this.keyFn)(x);\n                if (key === errorObj) {\n                    return this.o.onError(key.e);\n                }\n            }\n            if (this.hasCurrentKey) {\n                comparerEquals = tryCatch(this.comparer)(this.currentKey, key);\n                if (comparerEquals === errorObj) {\n                    return this.o.onError(comparerEquals.e);\n                }\n            }\n            if (!this.hasCurrentKey || !comparerEquals) {\n                this.hasCurrentKey = true;\n                this.currentKey = key;\n                this.o.onNext(x);\n            }\n        };\n        DistinctUntilChangedObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        DistinctUntilChangedObserver.prototype.completed = function() {\n            this.o.onCompleted();\n        };\n        return DistinctUntilChangedObserver;\n    }(AbstractObserver);\n    /**\n  *  Returns an observable sequence that contains only distinct contiguous elements according to the keyFn and the comparer.\n  * @param {Function} [keyFn] A function to compute the comparison key for each element. If not provided, it projects the value.\n  * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.\n  * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.\n  */ observableProto.distinctUntilChanged = function(keyFn, comparer) {\n        comparer || (comparer = defaultComparer);\n        return new DistinctUntilChangedObservable(this, keyFn, comparer);\n    };\n    var TapObservable = function(__super__) {\n        inherits(TapObservable, __super__);\n        function TapObservable(source, observerOrOnNext, onError, onCompleted) {\n            this.source = source;\n            this._oN = observerOrOnNext;\n            this._oE = onError;\n            this._oC = onCompleted;\n            __super__.call(this);\n        }\n        TapObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new InnerObserver(o, this));\n        };\n        inherits(InnerObserver, AbstractObserver);\n        function InnerObserver(o, p) {\n            this.o = o;\n            this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;\n            this.isStopped = false;\n            AbstractObserver.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            var res = tryCatch(this.t.onNext).call(this.t, x);\n            if (res === errorObj) {\n                this.o.onError(res.e);\n            }\n            this.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(err) {\n            var res = tryCatch(this.t.onError).call(this.t, err);\n            if (res === errorObj) {\n                return this.o.onError(res.e);\n            }\n            this.o.onError(err);\n        };\n        InnerObserver.prototype.completed = function() {\n            var res = tryCatch(this.t.onCompleted).call(this.t);\n            if (res === errorObj) {\n                return this.o.onError(res.e);\n            }\n            this.o.onCompleted();\n        };\n        return TapObservable;\n    }(ObservableBase);\n    /**\n  *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an o.\n  * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n  * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */ observableProto[\"do\"] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {\n        return new TapObservable(this, observerOrOnNext, onError, onCompleted);\n    };\n    /**\n  *  Invokes an action for each element in the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function} onNext Action to invoke for each element in the observable sequence.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */ observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {\n        return this.tap(typeof thisArg !== \"undefined\" ? function(x) {\n            onNext.call(thisArg, x);\n        } : onNext);\n    };\n    /**\n  *  Invokes an action upon exceptional termination of the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */ observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {\n        return this.tap(noop, typeof thisArg !== \"undefined\" ? function(e) {\n            onError.call(thisArg, e);\n        } : onError);\n    };\n    /**\n  *  Invokes an action upon graceful termination of the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */ observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {\n        return this.tap(noop, null, typeof thisArg !== \"undefined\" ? function() {\n            onCompleted.call(thisArg);\n        } : onCompleted);\n    };\n    var FinallyObservable = function(__super__) {\n        inherits(FinallyObservable, __super__);\n        function FinallyObservable(source, fn, thisArg) {\n            this.source = source;\n            this._fn = bindCallback(fn, thisArg, 0);\n            __super__.call(this);\n        }\n        FinallyObservable.prototype.subscribeCore = function(o) {\n            var d = tryCatch(this.source.subscribe).call(this.source, o);\n            if (d === errorObj) {\n                this._fn();\n                thrower(d.e);\n            }\n            return new FinallyDisposable(d, this._fn);\n        };\n        function FinallyDisposable(s, fn) {\n            this.isDisposed = false;\n            this._s = s;\n            this._fn = fn;\n        }\n        FinallyDisposable.prototype.dispose = function() {\n            if (!this.isDisposed) {\n                var res = tryCatch(this._s.dispose).call(this._s);\n                this._fn();\n                res === errorObj && thrower(res.e);\n            }\n        };\n        return FinallyObservable;\n    }(ObservableBase);\n    /**\n   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.\n   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.\n   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.\n   */ observableProto[\"finally\"] = function(action, thisArg) {\n        return new FinallyObservable(this, action, thisArg);\n    };\n    var IgnoreElementsObservable = function(__super__) {\n        inherits(IgnoreElementsObservable, __super__);\n        function IgnoreElementsObservable(source) {\n            this.source = source;\n            __super__.call(this);\n        }\n        IgnoreElementsObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new InnerObserver(o));\n        };\n        function InnerObserver(o) {\n            this.o = o;\n            this.isStopped = false;\n        }\n        InnerObserver.prototype.onNext = noop;\n        InnerObserver.prototype.onError = function(err) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this.o.onError(err);\n            }\n        };\n        InnerObserver.prototype.onCompleted = function() {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this.o.onCompleted();\n            }\n        };\n        InnerObserver.prototype.dispose = function() {\n            this.isStopped = true;\n        };\n        InnerObserver.prototype.fail = function(e) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this.observer.onError(e);\n                return true;\n            }\n            return false;\n        };\n        return IgnoreElementsObservable;\n    }(ObservableBase);\n    /**\n   *  Ignores all elements in an observable sequence leaving only the termination messages.\n   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.\n   */ observableProto.ignoreElements = function() {\n        return new IgnoreElementsObservable(this);\n    };\n    var MaterializeObservable = function(__super__) {\n        inherits(MaterializeObservable, __super__);\n        function MaterializeObservable(source, fn) {\n            this.source = source;\n            __super__.call(this);\n        }\n        MaterializeObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new MaterializeObserver(o));\n        };\n        return MaterializeObservable;\n    }(ObservableBase);\n    var MaterializeObserver = function(__super__) {\n        inherits(MaterializeObserver, __super__);\n        function MaterializeObserver(o) {\n            this._o = o;\n            __super__.call(this);\n        }\n        MaterializeObserver.prototype.next = function(x) {\n            this._o.onNext(notificationCreateOnNext(x));\n        };\n        MaterializeObserver.prototype.error = function(e) {\n            this._o.onNext(notificationCreateOnError(e));\n            this._o.onCompleted();\n        };\n        MaterializeObserver.prototype.completed = function() {\n            this._o.onNext(notificationCreateOnCompleted());\n            this._o.onCompleted();\n        };\n        return MaterializeObserver;\n    }(AbstractObserver);\n    /**\n   *  Materializes the implicit notifications of an observable sequence as explicit notification values.\n   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.\n   */ observableProto.materialize = function() {\n        return new MaterializeObservable(this);\n    };\n    /**\n   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.\n   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.\n   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.\n   */ observableProto.repeat = function(repeatCount) {\n        return enumerableRepeat(this, repeatCount).concat();\n    };\n    /**\n   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.\n   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);\n   *\n   * @example\n   *  var res = retried = retry.repeat();\n   *  var res = retried = retry.repeat(2);\n   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.\n   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n   */ observableProto.retry = function(retryCount) {\n        return enumerableRepeat(this, retryCount).catchError();\n    };\n    function repeat(value) {\n        return {\n            \"@@iterator\": function() {\n                return {\n                    next: function() {\n                        return {\n                            done: false,\n                            value: value\n                        };\n                    }\n                };\n            }\n        };\n    }\n    var RetryWhenObservable = function(__super__) {\n        function createDisposable(state) {\n            return {\n                isDisposed: false,\n                dispose: function() {\n                    if (!this.isDisposed) {\n                        this.isDisposed = true;\n                        state.isDisposed = true;\n                    }\n                }\n            };\n        }\n        function RetryWhenObservable(source, notifier) {\n            this.source = source;\n            this._notifier = notifier;\n            __super__.call(this);\n        }\n        inherits(RetryWhenObservable, __super__);\n        RetryWhenObservable.prototype.subscribeCore = function(o) {\n            var exceptions = new Subject(), notifier = new Subject(), handled = this._notifier(exceptions), notificationDisposable = handled.subscribe(notifier);\n            var e = this.source[\"@@iterator\"]();\n            var state = {\n                isDisposed: false\n            }, lastError, subscription = new SerialDisposable();\n            var cancelable = currentThreadScheduler.scheduleRecursive(null, function(_, recurse) {\n                if (state.isDisposed) {\n                    return;\n                }\n                var currentItem = e.next();\n                if (currentItem.done) {\n                    if (lastError) {\n                        o.onError(lastError);\n                    } else {\n                        o.onCompleted();\n                    }\n                    return;\n                }\n                // Check if promise\n                var currentValue = currentItem.value;\n                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n                var outer = new SingleAssignmentDisposable();\n                var inner = new SingleAssignmentDisposable();\n                subscription.setDisposable(new BinaryDisposable(inner, outer));\n                outer.setDisposable(currentValue.subscribe(function(x) {\n                    o.onNext(x);\n                }, function(exn) {\n                    inner.setDisposable(notifier.subscribe(recurse, function(ex) {\n                        o.onError(ex);\n                    }, function() {\n                        o.onCompleted();\n                    }));\n                    exceptions.onNext(exn);\n                    outer.dispose();\n                }, function() {\n                    o.onCompleted();\n                }));\n            });\n            return new NAryDisposable([\n                notificationDisposable,\n                subscription,\n                cancelable,\n                createDisposable(state)\n            ]);\n        };\n        return RetryWhenObservable;\n    }(ObservableBase);\n    observableProto.retryWhen = function(notifier) {\n        return new RetryWhenObservable(repeat(this), notifier);\n    };\n    function repeat(value) {\n        return {\n            \"@@iterator\": function() {\n                return {\n                    next: function() {\n                        return {\n                            done: false,\n                            value: value\n                        };\n                    }\n                };\n            }\n        };\n    }\n    var RepeatWhenObservable = function(__super__) {\n        function createDisposable(state) {\n            return {\n                isDisposed: false,\n                dispose: function() {\n                    if (!this.isDisposed) {\n                        this.isDisposed = true;\n                        state.isDisposed = true;\n                    }\n                }\n            };\n        }\n        function RepeatWhenObservable(source, notifier) {\n            this.source = source;\n            this._notifier = notifier;\n            __super__.call(this);\n        }\n        inherits(RepeatWhenObservable, __super__);\n        RepeatWhenObservable.prototype.subscribeCore = function(o) {\n            var completions = new Subject(), notifier = new Subject(), handled = this._notifier(completions), notificationDisposable = handled.subscribe(notifier);\n            var e = this.source[\"@@iterator\"]();\n            var state = {\n                isDisposed: false\n            }, lastError, subscription = new SerialDisposable();\n            var cancelable = currentThreadScheduler.scheduleRecursive(null, function(_, recurse) {\n                if (state.isDisposed) {\n                    return;\n                }\n                var currentItem = e.next();\n                if (currentItem.done) {\n                    if (lastError) {\n                        o.onError(lastError);\n                    } else {\n                        o.onCompleted();\n                    }\n                    return;\n                }\n                // Check if promise\n                var currentValue = currentItem.value;\n                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n                var outer = new SingleAssignmentDisposable();\n                var inner = new SingleAssignmentDisposable();\n                subscription.setDisposable(new BinaryDisposable(inner, outer));\n                outer.setDisposable(currentValue.subscribe(function(x) {\n                    o.onNext(x);\n                }, function(exn) {\n                    o.onError(exn);\n                }, function() {\n                    inner.setDisposable(notifier.subscribe(recurse, function(ex) {\n                        o.onError(ex);\n                    }, function() {\n                        o.onCompleted();\n                    }));\n                    completions.onNext(null);\n                    outer.dispose();\n                }));\n            });\n            return new NAryDisposable([\n                notificationDisposable,\n                subscription,\n                cancelable,\n                createDisposable(state)\n            ]);\n        };\n        return RepeatWhenObservable;\n    }(ObservableBase);\n    observableProto.repeatWhen = function(notifier) {\n        return new RepeatWhenObservable(repeat(this), notifier);\n    };\n    var ScanObservable = function(__super__) {\n        inherits(ScanObservable, __super__);\n        function ScanObservable(source, accumulator, hasSeed, seed) {\n            this.source = source;\n            this.accumulator = accumulator;\n            this.hasSeed = hasSeed;\n            this.seed = seed;\n            __super__.call(this);\n        }\n        ScanObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new ScanObserver(o, this));\n        };\n        return ScanObservable;\n    }(ObservableBase);\n    var ScanObserver = function(__super__) {\n        inherits(ScanObserver, __super__);\n        function ScanObserver(o, parent) {\n            this._o = o;\n            this._p = parent;\n            this._fn = parent.accumulator;\n            this._hs = parent.hasSeed;\n            this._s = parent.seed;\n            this._ha = false;\n            this._a = null;\n            this._hv = false;\n            this._i = 0;\n            __super__.call(this);\n        }\n        ScanObserver.prototype.next = function(x) {\n            !this._hv && (this._hv = true);\n            if (this._ha) {\n                this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);\n            } else {\n                this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;\n                this._ha = true;\n            }\n            if (this._a === errorObj) {\n                return this._o.onError(this._a.e);\n            }\n            this._o.onNext(this._a);\n            this._i++;\n        };\n        ScanObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        ScanObserver.prototype.completed = function() {\n            !this._hv && this._hs && this._o.onNext(this._s);\n            this._o.onCompleted();\n        };\n        return ScanObserver;\n    }(AbstractObserver);\n    /**\n  *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.\n  *  For aggregation behavior with no intermediate results, see Observable.aggregate.\n  * @param {Mixed} [seed] The initial accumulator value.\n  * @param {Function} accumulator An accumulator function to be invoked on each element.\n  * @returns {Observable} An observable sequence containing the accumulated values.\n  */ observableProto.scan = function() {\n        var hasSeed = false, seed, accumulator = arguments[0];\n        if (arguments.length === 2) {\n            hasSeed = true;\n            seed = arguments[1];\n        }\n        return new ScanObservable(this, accumulator, hasSeed, seed);\n    };\n    var SkipLastObservable = function(__super__) {\n        inherits(SkipLastObservable, __super__);\n        function SkipLastObservable(source, c) {\n            this.source = source;\n            this._c = c;\n            __super__.call(this);\n        }\n        SkipLastObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SkipLastObserver(o, this._c));\n        };\n        return SkipLastObservable;\n    }(ObservableBase);\n    var SkipLastObserver = function(__super__) {\n        inherits(SkipLastObserver, __super__);\n        function SkipLastObserver(o, c) {\n            this._o = o;\n            this._c = c;\n            this._q = [];\n            __super__.call(this);\n        }\n        SkipLastObserver.prototype.next = function(x) {\n            this._q.push(x);\n            this._q.length > this._c && this._o.onNext(this._q.shift());\n        };\n        SkipLastObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SkipLastObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return SkipLastObserver;\n    }(AbstractObserver);\n    /**\n   *  Bypasses a specified number of elements at the end of an observable sequence.\n   * @description\n   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are\n   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.\n   * @param count Number of elements to bypass at the end of the source sequence.\n   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.\n   */ observableProto.skipLast = function(count) {\n        if (count < 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        return new SkipLastObservable(this, count);\n    };\n    /**\n   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.\n   *  @example\n   *  var res = source.startWith(1, 2, 3);\n   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);\n   * @param {Arguments} args The specified values to prepend to the observable sequence\n   * @returns {Observable} The source sequence prepended with the specified values.\n   */ observableProto.startWith = function() {\n        var values, scheduler, start = 0;\n        if (!!arguments.length && isScheduler(arguments[0])) {\n            scheduler = arguments[0];\n            start = 1;\n        } else {\n            scheduler = immediateScheduler;\n        }\n        for(var args = [], i = start, len = arguments.length; i < len; i++){\n            args.push(arguments[i]);\n        }\n        return observableConcat.apply(null, [\n            observableFromArray(args, scheduler),\n            this\n        ]);\n    };\n    var TakeLastObserver = function(__super__) {\n        inherits(TakeLastObserver, __super__);\n        function TakeLastObserver(o, c) {\n            this._o = o;\n            this._c = c;\n            this._q = [];\n            __super__.call(this);\n        }\n        TakeLastObserver.prototype.next = function(x) {\n            this._q.push(x);\n            this._q.length > this._c && this._q.shift();\n        };\n        TakeLastObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TakeLastObserver.prototype.completed = function() {\n            while(this._q.length > 0){\n                this._o.onNext(this._q.shift());\n            }\n            this._o.onCompleted();\n        };\n        return TakeLastObserver;\n    }(AbstractObserver);\n    /**\n   *  Returns a specified number of contiguous elements from the end of an observable sequence.\n   * @description\n   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of\n   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.\n   * @param {Number} count Number of elements to take from the end of the source sequence.\n   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.\n   */ observableProto.takeLast = function(count) {\n        if (count < 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        var source = this;\n        return new AnonymousObservable(function(o) {\n            return source.subscribe(new TakeLastObserver(o, count));\n        }, source);\n    };\n    var TakeLastBufferObserver = function(__super__) {\n        inherits(TakeLastBufferObserver, __super__);\n        function TakeLastBufferObserver(o, c) {\n            this._o = o;\n            this._c = c;\n            this._q = [];\n            __super__.call(this);\n        }\n        TakeLastBufferObserver.prototype.next = function(x) {\n            this._q.push(x);\n            this._q.length > this._c && this._q.shift();\n        };\n        TakeLastBufferObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TakeLastBufferObserver.prototype.completed = function() {\n            this._o.onNext(this._q);\n            this._o.onCompleted();\n        };\n        return TakeLastBufferObserver;\n    }(AbstractObserver);\n    /**\n   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.\n   *\n   * @description\n   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the\n   *  source sequence, this buffer is produced on the result sequence.\n   * @param {Number} count Number of elements to take from the end of the source sequence.\n   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.\n   */ observableProto.takeLastBuffer = function(count) {\n        if (count < 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        var source = this;\n        return new AnonymousObservable(function(o) {\n            return source.subscribe(new TakeLastBufferObserver(o, count));\n        }, source);\n    };\n    /**\n   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.\n   * @param {Number} count Length of each window.\n   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.\n   * @returns {Observable} An observable sequence of windows.\n   */ observableProto.windowWithCount = observableProto.windowCount = function(count, skip) {\n        var source = this;\n        +count || (count = 0);\n        Math.abs(count) === Infinity && (count = 0);\n        if (count <= 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        skip == null && (skip = count);\n        +skip || (skip = 0);\n        Math.abs(skip) === Infinity && (skip = 0);\n        if (skip <= 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        return new AnonymousObservable(function(observer) {\n            var m = new SingleAssignmentDisposable(), refCountDisposable = new RefCountDisposable(m), n = 0, q = [];\n            function createWindow() {\n                var s = new Subject();\n                q.push(s);\n                observer.onNext(addRef(s, refCountDisposable));\n            }\n            createWindow();\n            m.setDisposable(source.subscribe(function(x) {\n                for(var i = 0, len = q.length; i < len; i++){\n                    q[i].onNext(x);\n                }\n                var c = n - count + 1;\n                c >= 0 && c % skip === 0 && q.shift().onCompleted();\n                ++n % skip === 0 && createWindow();\n            }, function(e) {\n                while(q.length > 0){\n                    q.shift().onError(e);\n                }\n                observer.onError(e);\n            }, function() {\n                while(q.length > 0){\n                    q.shift().onCompleted();\n                }\n                observer.onCompleted();\n            }));\n            return refCountDisposable;\n        }, source);\n    };\n    observableProto.flatMapConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {\n        return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(1);\n    };\n    /**\n   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.\n   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.\n   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.\n   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.\n   * @param {Any} [thisArg] An optional \"this\" to use to invoke each transform.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.\n   */ observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {\n        var source = this, onNextFunc = bindCallback(onNext, thisArg, 2), onErrorFunc = bindCallback(onError, thisArg, 1), onCompletedFunc = bindCallback(onCompleted, thisArg, 0);\n        return new AnonymousObservable(function(observer) {\n            var index = 0;\n            return source.subscribe(function(x) {\n                var result;\n                try {\n                    result = onNextFunc(x, index++);\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(result) && (result = observableFromPromise(result));\n                observer.onNext(result);\n            }, function(err) {\n                var result;\n                try {\n                    result = onErrorFunc(err);\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(result) && (result = observableFromPromise(result));\n                observer.onNext(result);\n                observer.onCompleted();\n            }, function() {\n                var result;\n                try {\n                    result = onCompletedFunc();\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(result) && (result = observableFromPromise(result));\n                observer.onNext(result);\n                observer.onCompleted();\n            });\n        }, this).concatAll();\n    };\n    var DefaultIfEmptyObserver = function(__super__) {\n        inherits(DefaultIfEmptyObserver, __super__);\n        function DefaultIfEmptyObserver(o, d) {\n            this._o = o;\n            this._d = d;\n            this._f = false;\n            __super__.call(this);\n        }\n        DefaultIfEmptyObserver.prototype.next = function(x) {\n            this._f = true;\n            this._o.onNext(x);\n        };\n        DefaultIfEmptyObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        DefaultIfEmptyObserver.prototype.completed = function() {\n            !this._f && this._o.onNext(this._d);\n            this._o.onCompleted();\n        };\n        return DefaultIfEmptyObserver;\n    }(AbstractObserver);\n    /**\n   *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.\n   *\n   *  var res = obs = xs.defaultIfEmpty();\n   *  2 - obs = xs.defaultIfEmpty(false);\n   *\n   * @memberOf Observable#\n   * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.\n   * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.\n   */ observableProto.defaultIfEmpty = function(defaultValue) {\n        var source = this;\n        defaultValue === undefined && (defaultValue = null);\n        return new AnonymousObservable(function(o) {\n            return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));\n        }, source);\n    };\n    // Swap out for Array.findIndex\n    function arrayIndexOfComparer(array, item, comparer) {\n        for(var i = 0, len = array.length; i < len; i++){\n            if (comparer(array[i], item)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    function HashSet(comparer) {\n        this.comparer = comparer;\n        this.set = [];\n    }\n    HashSet.prototype.push = function(value) {\n        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;\n        retValue && this.set.push(value);\n        return retValue;\n    };\n    var DistinctObservable = function(__super__) {\n        inherits(DistinctObservable, __super__);\n        function DistinctObservable(source, keyFn, cmpFn) {\n            this.source = source;\n            this._keyFn = keyFn;\n            this._cmpFn = cmpFn;\n            __super__.call(this);\n        }\n        DistinctObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new DistinctObserver(o, this._keyFn, this._cmpFn));\n        };\n        return DistinctObservable;\n    }(ObservableBase);\n    var DistinctObserver = function(__super__) {\n        inherits(DistinctObserver, __super__);\n        function DistinctObserver(o, keyFn, cmpFn) {\n            this._o = o;\n            this._keyFn = keyFn;\n            this._h = new HashSet(cmpFn);\n            __super__.call(this);\n        }\n        DistinctObserver.prototype.next = function(x) {\n            var key = x;\n            if (isFunction(this._keyFn)) {\n                key = tryCatch(this._keyFn)(x);\n                if (key === errorObj) {\n                    return this._o.onError(key.e);\n                }\n            }\n            this._h.push(key) && this._o.onNext(x);\n        };\n        DistinctObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        DistinctObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return DistinctObserver;\n    }(AbstractObserver);\n    /**\n   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.\n   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.\n   *\n   * @example\n   *  var res = obs = xs.distinct();\n   *  2 - obs = xs.distinct(function (x) { return x.id; });\n   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });\n   * @param {Function} [keySelector]  A function to compute the comparison key for each element.\n   * @param {Function} [comparer]  Used to compare items in the collection.\n   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.\n   */ observableProto.distinct = function(keySelector, comparer) {\n        comparer || (comparer = defaultComparer);\n        return new DistinctObservable(this, keySelector, comparer);\n    };\n    var MapObservable = function(__super__) {\n        inherits(MapObservable, __super__);\n        function MapObservable(source, selector, thisArg) {\n            this.source = source;\n            this.selector = bindCallback(selector, thisArg, 3);\n            __super__.call(this);\n        }\n        function innerMap(selector, self1) {\n            return function(x, i, o) {\n                return selector.call(this, self1.selector(x, i, o), i, o);\n            };\n        }\n        MapObservable.prototype.internalMap = function(selector, thisArg) {\n            return new MapObservable(this.source, innerMap(selector, this), thisArg);\n        };\n        MapObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new InnerObserver(o, this.selector, this));\n        };\n        inherits(InnerObserver, AbstractObserver);\n        function InnerObserver(o, selector, source) {\n            this.o = o;\n            this.selector = selector;\n            this.source = source;\n            this.i = 0;\n            AbstractObserver.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            var result = tryCatch(this.selector)(x, this.i++, this.source);\n            if (result === errorObj) {\n                return this.o.onError(result.e);\n            }\n            this.o.onNext(result);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this.o.onCompleted();\n        };\n        return MapObservable;\n    }(ObservableBase);\n    /**\n  * Projects each element of an observable sequence into a new form by incorporating the element's index.\n  * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.\n  */ observableProto.map = observableProto.select = function(selector, thisArg) {\n        var selectorFn = typeof selector === \"function\" ? selector : function() {\n            return selector;\n        };\n        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);\n    };\n    function plucker(args, len) {\n        return function mapper(x) {\n            var currentProp = x;\n            for(var i = 0; i < len; i++){\n                var p = currentProp[args[i]];\n                if (typeof p !== \"undefined\") {\n                    currentProp = p;\n                } else {\n                    return undefined;\n                }\n            }\n            return currentProp;\n        };\n    }\n    /**\n   * Retrieves the value of a specified nested property from all elements in\n   * the Observable sequence.\n   * @param {Arguments} arguments The nested properties to pluck.\n   * @returns {Observable} Returns a new Observable sequence of property values.\n   */ observableProto.pluck = function() {\n        var len = arguments.length, args = new Array(len);\n        if (len === 0) {\n            throw new Error(\"List of properties cannot be empty.\");\n        }\n        for(var i = 0; i < len; i++){\n            args[i] = arguments[i];\n        }\n        return this.map(plucker(args, len));\n    };\n    /**\n   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.\n   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.\n   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.\n   * @param {Any} [thisArg] An optional \"this\" to use to invoke each transform.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.\n   */ observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {\n        var source = this;\n        return new AnonymousObservable(function(observer) {\n            var index = 0;\n            return source.subscribe(function(x) {\n                var result;\n                try {\n                    result = onNext.call(thisArg, x, index++);\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(result) && (result = observableFromPromise(result));\n                observer.onNext(result);\n            }, function(err) {\n                var result;\n                try {\n                    result = onError.call(thisArg, err);\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(result) && (result = observableFromPromise(result));\n                observer.onNext(result);\n                observer.onCompleted();\n            }, function() {\n                var result;\n                try {\n                    result = onCompleted.call(thisArg);\n                } catch (e) {\n                    observer.onError(e);\n                    return;\n                }\n                isPromise(result) && (result = observableFromPromise(result));\n                observer.onNext(result);\n                observer.onCompleted();\n            });\n        }, source).mergeAll();\n    };\n    observableProto.flatMap = observableProto.selectMany = observableProto.mergeMap = function(selector, resultSelector, thisArg) {\n        return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();\n    };\n    observableProto.flatMapLatest = observableProto.switchMap = function(selector, resultSelector, thisArg) {\n        return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();\n    };\n    var SkipObservable = function(__super__) {\n        inherits(SkipObservable, __super__);\n        function SkipObservable(source, count) {\n            this.source = source;\n            this._count = count;\n            __super__.call(this);\n        }\n        SkipObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SkipObserver(o, this._count));\n        };\n        function SkipObserver(o, c) {\n            this._o = o;\n            this._r = c;\n            AbstractObserver.call(this);\n        }\n        inherits(SkipObserver, AbstractObserver);\n        SkipObserver.prototype.next = function(x) {\n            if (this._r <= 0) {\n                this._o.onNext(x);\n            } else {\n                this._r--;\n            }\n        };\n        SkipObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SkipObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return SkipObservable;\n    }(ObservableBase);\n    /**\n   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.\n   * @param {Number} count The number of elements to skip before returning the remaining elements.\n   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.\n   */ observableProto.skip = function(count) {\n        if (count < 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        return new SkipObservable(this, count);\n    };\n    var SkipWhileObservable = function(__super__) {\n        inherits(SkipWhileObservable, __super__);\n        function SkipWhileObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        SkipWhileObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SkipWhileObserver(o, this));\n        };\n        return SkipWhileObservable;\n    }(ObservableBase);\n    var SkipWhileObserver = function(__super__) {\n        inherits(SkipWhileObserver, __super__);\n        function SkipWhileObserver(o, p) {\n            this._o = o;\n            this._p = p;\n            this._i = 0;\n            this._r = false;\n            __super__.call(this);\n        }\n        SkipWhileObserver.prototype.next = function(x) {\n            if (!this._r) {\n                var res = tryCatch(this._p._fn)(x, this._i++, this._p);\n                if (res === errorObj) {\n                    return this._o.onError(res.e);\n                }\n                this._r = !res;\n            }\n            this._r && this._o.onNext(x);\n        };\n        SkipWhileObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SkipWhileObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return SkipWhileObserver;\n    }(AbstractObserver);\n    /**\n   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\n   *  The element's index is used in the logic of the predicate function.\n   *\n   *  var res = source.skipWhile(function (value) { return value < 10; });\n   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });\n   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.\n   */ observableProto.skipWhile = function(predicate, thisArg) {\n        var fn = bindCallback(predicate, thisArg, 3);\n        return new SkipWhileObservable(this, fn);\n    };\n    var TakeObservable = function(__super__) {\n        inherits(TakeObservable, __super__);\n        function TakeObservable(source, count) {\n            this.source = source;\n            this._count = count;\n            __super__.call(this);\n        }\n        TakeObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new TakeObserver(o, this._count));\n        };\n        function TakeObserver(o, c) {\n            this._o = o;\n            this._c = c;\n            this._r = c;\n            AbstractObserver.call(this);\n        }\n        inherits(TakeObserver, AbstractObserver);\n        TakeObserver.prototype.next = function(x) {\n            if (this._r-- > 0) {\n                this._o.onNext(x);\n                this._r <= 0 && this._o.onCompleted();\n            }\n        };\n        TakeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TakeObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return TakeObservable;\n    }(ObservableBase);\n    /**\n   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).\n   * @param {Number} count The number of elements to return.\n   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name=\"count count</paramref> is set to 0.\n   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.\n   */ observableProto.take = function(count, scheduler) {\n        if (count < 0) {\n            throw new ArgumentOutOfRangeError();\n        }\n        if (count === 0) {\n            return observableEmpty(scheduler);\n        }\n        return new TakeObservable(this, count);\n    };\n    var TakeWhileObservable = function(__super__) {\n        inherits(TakeWhileObservable, __super__);\n        function TakeWhileObservable(source, fn) {\n            this.source = source;\n            this._fn = fn;\n            __super__.call(this);\n        }\n        TakeWhileObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new TakeWhileObserver(o, this));\n        };\n        return TakeWhileObservable;\n    }(ObservableBase);\n    var TakeWhileObserver = function(__super__) {\n        inherits(TakeWhileObserver, __super__);\n        function TakeWhileObserver(o, p) {\n            this._o = o;\n            this._p = p;\n            this._i = 0;\n            this._r = true;\n            __super__.call(this);\n        }\n        TakeWhileObserver.prototype.next = function(x) {\n            if (this._r) {\n                this._r = tryCatch(this._p._fn)(x, this._i++, this._p);\n                if (this._r === errorObj) {\n                    return this._o.onError(this._r.e);\n                }\n            }\n            if (this._r) {\n                this._o.onNext(x);\n            } else {\n                this._o.onCompleted();\n            }\n        };\n        TakeWhileObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TakeWhileObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return TakeWhileObserver;\n    }(AbstractObserver);\n    /**\n   *  Returns elements from an observable sequence as long as a specified condition is true.\n   *  The element's index is used in the logic of the predicate function.\n   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.\n   */ observableProto.takeWhile = function(predicate, thisArg) {\n        var fn = bindCallback(predicate, thisArg, 3);\n        return new TakeWhileObservable(this, fn);\n    };\n    var FilterObservable = function(__super__) {\n        inherits(FilterObservable, __super__);\n        function FilterObservable(source, predicate, thisArg) {\n            this.source = source;\n            this.predicate = bindCallback(predicate, thisArg, 3);\n            __super__.call(this);\n        }\n        FilterObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new InnerObserver(o, this.predicate, this));\n        };\n        function innerPredicate(predicate, self1) {\n            return function(x, i, o) {\n                return self1.predicate(x, i, o) && predicate.call(this, x, i, o);\n            };\n        }\n        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {\n            return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);\n        };\n        inherits(InnerObserver, AbstractObserver);\n        function InnerObserver(o, predicate, source) {\n            this.o = o;\n            this.predicate = predicate;\n            this.source = source;\n            this.i = 0;\n            AbstractObserver.call(this);\n        }\n        InnerObserver.prototype.next = function(x) {\n            var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);\n            if (shouldYield === errorObj) {\n                return this.o.onError(shouldYield.e);\n            }\n            shouldYield && this.o.onNext(x);\n        };\n        InnerObserver.prototype.error = function(e) {\n            this.o.onError(e);\n        };\n        InnerObserver.prototype.completed = function() {\n            this.o.onCompleted();\n        };\n        return FilterObservable;\n    }(ObservableBase);\n    /**\n  *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.\n  * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.\n  */ observableProto.filter = observableProto.where = function(predicate, thisArg) {\n        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);\n    };\n    var TransduceObserver = function(__super__) {\n        inherits(TransduceObserver, __super__);\n        function TransduceObserver(o, xform) {\n            this._o = o;\n            this._xform = xform;\n            __super__.call(this);\n        }\n        TransduceObserver.prototype.next = function(x) {\n            var res = tryCatch(this._xform[\"@@transducer/step\"]).call(this._xform, this._o, x);\n            if (res === errorObj) {\n                this._o.onError(res.e);\n            }\n        };\n        TransduceObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TransduceObserver.prototype.completed = function() {\n            this._xform[\"@@transducer/result\"](this._o);\n        };\n        return TransduceObserver;\n    }(AbstractObserver);\n    function transformForObserver(o) {\n        return {\n            \"@@transducer/init\": function() {\n                return o;\n            },\n            \"@@transducer/step\": function(obs, input) {\n                return obs.onNext(input);\n            },\n            \"@@transducer/result\": function(obs) {\n                return obs.onCompleted();\n            }\n        };\n    }\n    /**\n   * Executes a transducer to transform the observable sequence\n   * @param {Transducer} transducer A transducer to execute\n   * @returns {Observable} An Observable sequence containing the results from the transducer.\n   */ observableProto.transduce = function(transducer) {\n        var source = this;\n        return new AnonymousObservable(function(o) {\n            var xform = transducer(transformForObserver(o));\n            return source.subscribe(new TransduceObserver(o, xform));\n        }, source);\n    };\n    var AnonymousObservable = Rx.AnonymousObservable = function(__super__) {\n        inherits(AnonymousObservable, __super__);\n        // Fix subscriber to check for undefined or function returned to decorate as Disposable\n        function fixSubscriber(subscriber) {\n            return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;\n        }\n        function setDisposable(s, state) {\n            var ado = state[0], self1 = state[1];\n            var sub = tryCatch(self1.__subscribe).call(self1, ado);\n            if (sub === errorObj && !ado.fail(errorObj.e)) {\n                thrower(errorObj.e);\n            }\n            ado.setDisposable(fixSubscriber(sub));\n        }\n        function AnonymousObservable(subscribe, parent) {\n            this.source = parent;\n            this.__subscribe = subscribe;\n            __super__.call(this);\n        }\n        AnonymousObservable.prototype._subscribe = function(o) {\n            var ado = new AutoDetachObserver(o), state = [\n                ado,\n                this\n            ];\n            if (currentThreadScheduler.scheduleRequired()) {\n                currentThreadScheduler.schedule(state, setDisposable);\n            } else {\n                setDisposable(null, state);\n            }\n            return ado;\n        };\n        return AnonymousObservable;\n    }(Observable);\n    var AutoDetachObserver = function(__super__) {\n        inherits(AutoDetachObserver, __super__);\n        function AutoDetachObserver(observer) {\n            __super__.call(this);\n            this.observer = observer;\n            this.m = new SingleAssignmentDisposable();\n        }\n        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;\n        AutoDetachObserverPrototype.next = function(value) {\n            var result = tryCatch(this.observer.onNext).call(this.observer, value);\n            if (result === errorObj) {\n                this.dispose();\n                thrower(result.e);\n            }\n        };\n        AutoDetachObserverPrototype.error = function(err) {\n            var result = tryCatch(this.observer.onError).call(this.observer, err);\n            this.dispose();\n            result === errorObj && thrower(result.e);\n        };\n        AutoDetachObserverPrototype.completed = function() {\n            var result = tryCatch(this.observer.onCompleted).call(this.observer);\n            this.dispose();\n            result === errorObj && thrower(result.e);\n        };\n        AutoDetachObserverPrototype.setDisposable = function(value) {\n            this.m.setDisposable(value);\n        };\n        AutoDetachObserverPrototype.getDisposable = function() {\n            return this.m.getDisposable();\n        };\n        AutoDetachObserverPrototype.dispose = function() {\n            __super__.prototype.dispose.call(this);\n            this.m.dispose();\n        };\n        return AutoDetachObserver;\n    }(AbstractObserver);\n    var InnerSubscription = function(s, o) {\n        this._s = s;\n        this._o = o;\n    };\n    InnerSubscription.prototype.dispose = function() {\n        if (!this._s.isDisposed && this._o !== null) {\n            var idx = this._s.observers.indexOf(this._o);\n            this._s.observers.splice(idx, 1);\n            this._o = null;\n        }\n    };\n    /**\n   *  Represents an object that is both an observable sequence as well as an observer.\n   *  Each notification is broadcasted to all subscribed observers.\n   */ var Subject = Rx.Subject = function(__super__) {\n        inherits(Subject, __super__);\n        function Subject() {\n            __super__.call(this);\n            this.isDisposed = false;\n            this.isStopped = false;\n            this.observers = [];\n            this.hasError = false;\n        }\n        addProperties(Subject.prototype, Observer.prototype, {\n            _subscribe: function(o) {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.observers.push(o);\n                    return new InnerSubscription(this, o);\n                }\n                if (this.hasError) {\n                    o.onError(this.error);\n                    return disposableEmpty;\n                }\n                o.onCompleted();\n                return disposableEmpty;\n            },\n            /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */ hasObservers: function() {\n                checkDisposed(this);\n                return this.observers.length > 0;\n            },\n            /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */ onCompleted: function() {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.isStopped = true;\n                    for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                        os[i].onCompleted();\n                    }\n                    this.observers.length = 0;\n                }\n            },\n            /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */ onError: function(error) {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.isStopped = true;\n                    this.error = error;\n                    this.hasError = true;\n                    for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                        os[i].onError(error);\n                    }\n                    this.observers.length = 0;\n                }\n            },\n            /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */ onNext: function(value) {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                        os[i].onNext(value);\n                    }\n                }\n            },\n            /**\n       * Unsubscribe all observers and release resources.\n       */ dispose: function() {\n                this.isDisposed = true;\n                this.observers = null;\n            }\n        });\n        /**\n     * Creates a subject from the specified observer and observable.\n     * @param {Observer} observer The observer used to send messages to the subject.\n     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.\n     * @returns {Subject} Subject implemented using the given observer and observable.\n     */ Subject.create = function(observer, observable) {\n            return new AnonymousSubject(observer, observable);\n        };\n        return Subject;\n    }(Observable);\n    /**\n   *  Represents the result of an asynchronous operation.\n   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.\n   */ var AsyncSubject = Rx.AsyncSubject = function(__super__) {\n        inherits(AsyncSubject, __super__);\n        /**\n     * Creates a subject that can only receive one value and that value is cached for all future observations.\n     * @constructor\n     */ function AsyncSubject() {\n            __super__.call(this);\n            this.isDisposed = false;\n            this.isStopped = false;\n            this.hasValue = false;\n            this.observers = [];\n            this.hasError = false;\n        }\n        addProperties(AsyncSubject.prototype, Observer.prototype, {\n            _subscribe: function(o) {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.observers.push(o);\n                    return new InnerSubscription(this, o);\n                }\n                if (this.hasError) {\n                    o.onError(this.error);\n                } else if (this.hasValue) {\n                    o.onNext(this.value);\n                    o.onCompleted();\n                } else {\n                    o.onCompleted();\n                }\n                return disposableEmpty;\n            },\n            /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */ hasObservers: function() {\n                checkDisposed(this);\n                return this.observers.length > 0;\n            },\n            /**\n       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).\n       */ onCompleted: function() {\n                var i, len;\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.isStopped = true;\n                    var os = cloneArray(this.observers), len = os.length;\n                    if (this.hasValue) {\n                        for(i = 0; i < len; i++){\n                            var o = os[i];\n                            o.onNext(this.value);\n                            o.onCompleted();\n                        }\n                    } else {\n                        for(i = 0; i < len; i++){\n                            os[i].onCompleted();\n                        }\n                    }\n                    this.observers.length = 0;\n                }\n            },\n            /**\n       * Notifies all subscribed observers about the error.\n       * @param {Mixed} error The Error to send to all observers.\n       */ onError: function(error) {\n                checkDisposed(this);\n                if (!this.isStopped) {\n                    this.isStopped = true;\n                    this.hasError = true;\n                    this.error = error;\n                    for(var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++){\n                        os[i].onError(error);\n                    }\n                    this.observers.length = 0;\n                }\n            },\n            /**\n       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.\n       * @param {Mixed} value The value to store in the subject.\n       */ onNext: function(value) {\n                checkDisposed(this);\n                if (this.isStopped) {\n                    return;\n                }\n                this.value = value;\n                this.hasValue = true;\n            },\n            /**\n       * Unsubscribe all observers and release resources.\n       */ dispose: function() {\n                this.isDisposed = true;\n                this.observers = null;\n                this.error = null;\n                this.value = null;\n            }\n        });\n        return AsyncSubject;\n    }(Observable);\n    var AnonymousSubject = Rx.AnonymousSubject = function(__super__) {\n        inherits(AnonymousSubject, __super__);\n        function AnonymousSubject(observer, observable) {\n            this.observer = observer;\n            this.observable = observable;\n            __super__.call(this);\n        }\n        addProperties(AnonymousSubject.prototype, Observer.prototype, {\n            _subscribe: function(o) {\n                return this.observable.subscribe(o);\n            },\n            onCompleted: function() {\n                this.observer.onCompleted();\n            },\n            onError: function(error) {\n                this.observer.onError(error);\n            },\n            onNext: function(value) {\n                this.observer.onNext(value);\n            }\n        });\n        return AnonymousSubject;\n    }(Observable);\n    if (true) {\n        root.Rx = Rx;\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return Rx;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n    // All code before this point will be filtered from stack traces.\n    var rEndingLine = captureLine();\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVGLElBQUksSUFBMEUsRUFBRTtRQUM5RTdjLEtBQUtFLEVBQUUsR0FBR0E7UUFFVisxQixtQ0FBTztZQUNMLE9BQU8vMUI7UUFDVCxDQUFDO0FBQUEsa0dBQUM7SUFDSixPQUFPLEVBVU47SUFFRCxpRUFBaUU7SUFDakUsSUFBSTJFLGNBQWN6QjtBQUVwQixHQUFFekIsSUFBSSxDQUFDLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXJ2ZXItYWN0aW9uLy4vbm9kZV9tb2R1bGVzL3J4L2Rpc3QvcnguanM/YWU4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCwgQWxsIHJpZ2h0cyByZXNlcnZlZC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbjsoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLk9iamVjdCA9PT0gT2JqZWN0KSA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIHZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkgPyBleHBvcnRzIDogbnVsbDtcbiAgdmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpID8gbW9kdWxlIDogbnVsbDtcbiAgdmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCk7XG4gIHZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcbiAgdmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IChmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpID8gZnJlZUV4cG9ydHMgOiBudWxsO1xuICB2YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgdmFyIFJ4ID0ge1xuICAgIGludGVybmFsczoge30sXG4gICAgY29uZmlnOiB7XG4gICAgICBQcm9taXNlOiByb290LlByb21pc2VcbiAgICB9LFxuICAgIGhlbHBlcnM6IHsgfVxuICB9O1xuXG4gIC8vIERlZmF1bHRzXG4gIHZhciBub29wID0gUnguaGVscGVycy5ub29wID0gZnVuY3Rpb24gKCkgeyB9LFxuICAgIGlkZW50aXR5ID0gUnguaGVscGVycy5pZGVudGl0eSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9LFxuICAgIGRlZmF1bHROb3cgPSBSeC5oZWxwZXJzLmRlZmF1bHROb3cgPSBEYXRlLm5vdyxcbiAgICBkZWZhdWx0Q29tcGFyZXIgPSBSeC5oZWxwZXJzLmRlZmF1bHRDb21wYXJlciA9IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBpc0VxdWFsKHgsIHkpOyB9LFxuICAgIGRlZmF1bHRTdWJDb21wYXJlciA9IFJ4LmhlbHBlcnMuZGVmYXVsdFN1YkNvbXBhcmVyID0gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggPiB5ID8gMSA6ICh4IDwgeSA/IC0xIDogMCk7IH0sXG4gICAgZGVmYXVsdEtleVNlcmlhbGl6ZXIgPSBSeC5oZWxwZXJzLmRlZmF1bHRLZXlTZXJpYWxpemVyID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcoKTsgfSxcbiAgICBkZWZhdWx0RXJyb3IgPSBSeC5oZWxwZXJzLmRlZmF1bHRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9LFxuICAgIGlzUHJvbWlzZSA9IFJ4LmhlbHBlcnMuaXNQcm9taXNlID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuICEhcCAmJiB0eXBlb2YgcC5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgICBpc0Z1bmN0aW9uID0gUnguaGVscGVycy5pc0Z1bmN0aW9uID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgdmFyIGlzRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICBpZiAoaXNGbigveC8pKSB7XG4gICAgICAgIGlzRm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNGbjtcbiAgICB9KCkpO1xuXG4gIGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyKSB7IGZvcih2YXIgYSA9IFtdLCBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IGEucHVzaChhcnJbaV0pOyB9IHJldHVybiBhO31cblxuICB2YXIgZXJyb3JPYmogPSB7ZToge319O1xuICBcbiAgZnVuY3Rpb24gdHJ5Q2F0Y2hlckdlbih0cnlDYXRjaFRhcmdldCkge1xuICAgIHJldHVybiBmdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciB0cnlDYXRjaCA9IFJ4LmludGVybmFscy50cnlDYXRjaCA9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdmbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTsgfVxuICAgIHJldHVybiB0cnlDYXRjaGVyR2VuKGZuKTtcbiAgfTtcblxuICBmdW5jdGlvbiB0aHJvd2VyKGUpIHtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgUnguY29uZmlnLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcbiAgdmFyIGhhc1N0YWNrcyA9IGZhbHNlLCBzdGFja3MgPSB0cnlDYXRjaChmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcigpOyB9KSgpO1xuICBoYXNTdGFja3MgPSAhIXN0YWNrcy5lICYmICEhc3RhY2tzLmUuc3RhY2s7XG5cbiAgLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkIGJ5IFJ4SlNcbiAgdmFyIHJTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpLCByRmlsZU5hbWU7XG5cbiAgdmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gJ0Zyb20gcHJldmlvdXMgZXZlbnQ6JztcblxuICBmdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIG9ic2VydmFibGUpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBSeEpTXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgb2JzZXJ2YWJsZWAuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBvYnNlcnZhYmxlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICB2YXIgc3RhY2tzID0gW107XG4gICAgICBmb3IgKHZhciBvID0gb2JzZXJ2YWJsZTsgISFvOyBvID0gby5zb3VyY2UpIHtcbiAgICAgICAgaWYgKG8uc3RhY2spIHtcbiAgICAgICAgICBzdGFja3MudW5zaGlmdChvLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbignXFxuJyArIFNUQUNLX0pVTVBfU0VQQVJBVE9SICsgJ1xcbicpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyU3RhY2tTdHJpbmcoc3RhY2tTdHJpbmcpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdCgnXFxuJyksIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbignXFxuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ludGVybmFsRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpO1xuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBmaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXSwgbGluZU51bWJlciA9IGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcblxuICAgIHJldHVybiBmaWxlTmFtZSA9PT0gckZpbGVOYW1lICYmXG4gICAgICBsaW5lTnVtYmVyID49IHJTdGFydGluZ0xpbmUgJiZcbiAgICAgIGxpbmVOdW1iZXIgPD0gckVuZGluZ0xpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoJyhtb2R1bGUuanM6JykgIT09IC0xIHx8XG4gICAgICBzdGFja0xpbmUuaW5kZXhPZignKG5vZGUuanM6JykgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHsgcmV0dXJuOyB9XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZignQCcpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKGZpcnN0TGluZSk7XG4gICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikgeyByZXR1cm47IH1cblxuICAgICAgckZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiAnYXQgZnVuY3Rpb25OYW1lIChmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlciknXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkgeyByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTsgfVxuXG4gICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uczogJ2F0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyJ1xuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHsgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07IH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6ICdmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyJ1xuICAgIHZhciBhdHRlbXB0MyA9IC8uKkAoLispOihcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDMpIHsgcmV0dXJuIFthdHRlbXB0M1sxXSwgTnVtYmVyKGF0dGVtcHQzWzJdKV07IH1cbiAgfVxuXG4gIHZhciBFbXB0eUVycm9yID0gUnguRW1wdHlFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWVzc2FnZSA9ICdTZXF1ZW5jZSBjb250YWlucyBubyBlbGVtZW50cy4nO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIEVtcHR5RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBFbXB0eUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0VtcHR5RXJyb3InO1xuXG4gIHZhciBPYmplY3REaXNwb3NlZEVycm9yID0gUnguT2JqZWN0RGlzcG9zZWRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWVzc2FnZSA9ICdPYmplY3QgaGFzIGJlZW4gZGlzcG9zZWQnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIE9iamVjdERpc3Bvc2VkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBPYmplY3REaXNwb3NlZEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ09iamVjdERpc3Bvc2VkRXJyb3InO1xuXG4gIHZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IFJ4LkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubWVzc2FnZSA9ICdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuXG4gIHZhciBOb3RTdXBwb3J0ZWRFcnJvciA9IFJ4Lk5vdFN1cHBvcnRlZEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkJztcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICB9O1xuICBOb3RTdXBwb3J0ZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIE5vdFN1cHBvcnRlZEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJztcblxuICB2YXIgTm90SW1wbGVtZW50ZWRFcnJvciA9IFJ4Lk5vdEltcGxlbWVudGVkRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgTm90SW1wbGVtZW50ZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIE5vdEltcGxlbWVudGVkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnTm90SW1wbGVtZW50ZWRFcnJvcic7XG5cbiAgdmFyIG5vdEltcGxlbWVudGVkID0gUnguaGVscGVycy5ub3RJbXBsZW1lbnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9O1xuXG4gIHZhciBub3RTdXBwb3J0ZWQgPSBSeC5oZWxwZXJzLm5vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgfTtcblxuICAvLyBTaGltIGluIGl0ZXJhdG9yIHN1cHBvcnRcbiAgdmFyICRpdGVyYXRvciQgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHx8XG4gICAgJ19lczZzaGltX2l0ZXJhdG9yXyc7XG4gIC8vIEJ1ZyBmb3IgbW96aWxsYSB2ZXJzaW9uXG4gIGlmIChyb290LlNldCAmJiB0eXBlb2YgbmV3IHJvb3QuU2V0KClbJ0BAaXRlcmF0b3InXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICRpdGVyYXRvciQgPSAnQEBpdGVyYXRvcic7XG4gIH1cblxuICB2YXIgZG9uZUVudW1lcmF0b3IgPSBSeC5kb25lRW51bWVyYXRvciA9IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXG4gIHZhciBpc0l0ZXJhYmxlID0gUnguaGVscGVycy5pc0l0ZXJhYmxlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBvWyRpdGVyYXRvciRdICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIGlzQXJyYXlMaWtlID0gUnguaGVscGVycy5pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgby5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBSeC5oZWxwZXJzLml0ZXJhdG9yID0gJGl0ZXJhdG9yJDtcblxuICB2YXIgYmluZENhbGxiYWNrID0gUnguaW50ZXJuYWxzLmJpbmRDYWxsYmFjayA9IGZ1bmN0aW9uIChmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgIGlmICh0eXBlb2YgdGhpc0FyZyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZ1bmM7IH1cbiAgICBzd2l0Y2goYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZylcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnKTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBkb250RW51bXMgPSBbJ3RvU3RyaW5nJyxcbiAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICd2YWx1ZU9mJyxcbiAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICdjb25zdHJ1Y3RvciddLFxuICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG50eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzIHx8IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBoYXNEb250RW51bUJ1ZyA9ICEoeyB0b1N0cmluZzogbnVsbCB9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcbiAgICAgICAgZG9udEVudW1zID0gW1xuICAgICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgICAnY29uc3RydWN0b3InXG4gICAgICAgIF0sXG4gICAgICAgIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgKHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicgfHwgb2JqID09PSBudWxsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHByb3AsIGk7XG5cbiAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvbnRFbnVtc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH0oKSk7XG5cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPT0gb3RoTGVuZ3RoICYmICFpc0xvb3NlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aCwga2V5O1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikgOiByZXN1bHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKCFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICBpZiAob2JqQ3RvciAhPT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuICtvYmplY3QgPT09ICtvdGhlcjtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIHJldHVybiAob2JqZWN0ICE9PSArb2JqZWN0KSA/XG4gICAgICAgIG90aGVyICE9PSArb3RoZXIgOlxuICAgICAgICBvYmplY3QgPT09ICtvdGhlcjtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gKG90aGVyICsgJycpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzT2JqZWN0ID0gUnguaW50ZXJuYWxzLmlzT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG5cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG52YXIgaXNIb3N0T2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIE9iamVjdCh7ICd0b1N0cmluZyc6IDAgfSArICcnKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKHZhbHVlICsgJycpID09PSAnc3RyaW5nJztcbiAgfTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYXJyYXlUYWc7XG59O1xuXG5mdW5jdGlvbiBhcnJheVNvbWUgKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT09IG90aExlbmd0aCAmJiAhKGlzTG9vc2UgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChpc0xvb3NlKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG9iamVjdCk7XG4gICAgaWYgKG9ialRhZyA9PT0gYXJnc1RhZykge1xuICAgICAgb2JqVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob2JqVGFnICE9PSBvYmplY3RUYWcpIHtcbiAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgfVxuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG90aGVyKTtcbiAgICBpZiAob3RoVGFnID09PSBhcmdzVGFnKSB7XG4gICAgICBvdGhUYWcgPSBvYmplY3RUYWc7XG4gICAgfVxuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob2JqZWN0KSxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvdGhlciksXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgfVxuICBpZiAoIWlzTG9vc2UpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZXRlY3RpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBzZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNKTy5cbiAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT09IG9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09PSBvdGhlcjtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIGBvYmplY3RgIGFuZCBgb3RoZXJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgc3RhY2tBLnB1c2gob2JqZWN0KTtcbiAgc3RhY2tCLnB1c2gob3RoZXIpO1xuXG4gIHZhciByZXN1bHQgPSAob2JqSXNBcnIgPyBlcXVhbEFycmF5cyA6IGVxdWFsT2JqZWN0cykob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG5cbiAgc3RhY2tBLnBvcCgpO1xuICBzdGFja0IucG9wKCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbn1cblxudmFyIGlzRXF1YWwgPSBSeC5pbnRlcm5hbHMuaXNFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59O1xuXG4gIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICB2YXIgaW5oZXJpdHMgPSBSeC5pbnRlcm5hbHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgICBfXy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBfXygpO1xuICB9O1xuXG4gIHZhciBhZGRQcm9wZXJ0aWVzID0gUnguaW50ZXJuYWxzLmFkZFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yKHZhciBzb3VyY2VzID0gW10sIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgc291cmNlcy5wdXNoKGFyZ3VtZW50c1tpXSk7IH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsbiA9IHNvdXJjZXMubGVuZ3RoOyBpZHggPCBsbjsgaWR4KyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2lkeF07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJ4IFV0aWxzXG4gIHZhciBhZGRSZWYgPSBSeC5pbnRlcm5hbHMuYWRkUmVmID0gZnVuY3Rpb24gKHhzLCByKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHIuZ2V0RGlzcG9zYWJsZSgpLCB4cy5zdWJzY3JpYmUob2JzZXJ2ZXIpKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcnJheUluaXRpYWxpemUoY291bnQsIGZhY3RvcnkpIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBhW2ldID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgZ3JvdXAgb2YgZGlzcG9zYWJsZSByZXNvdXJjZXMgdGhhdCBhcmUgZGlzcG9zZWQgdG9nZXRoZXIuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdmFyIENvbXBvc2l0ZURpc3Bvc2FibGUgPSBSeC5Db21wb3NpdGVEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGksIGxlbjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2FibGVzID0gYXJncztcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBDb21wb3NpdGVEaXNwb3NhYmxlUHJvdG90eXBlID0gQ29tcG9zaXRlRGlzcG9zYWJsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBkaXNwb3NhYmxlIHRvIHRoZSBDb21wb3NpdGVEaXNwb3NhYmxlIG9yIGRpc3Bvc2VzIHRoZSBkaXNwb3NhYmxlIGlmIHRoZSBDb21wb3NpdGVEaXNwb3NhYmxlIGlzIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge01peGVkfSBpdGVtIERpc3Bvc2FibGUgdG8gYWRkLlxuICAgKi9cbiAgQ29tcG9zaXRlRGlzcG9zYWJsZVByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2FibGVzLnB1c2goaXRlbSk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbmQgZGlzcG9zZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBkaXNwb3NhYmxlIGZyb20gdGhlIENvbXBvc2l0ZURpc3Bvc2FibGUuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gRGlzcG9zYWJsZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGZvdW5kOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBDb21wb3NpdGVEaXNwb3NhYmxlUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIHNob3VsZERpc3Bvc2UgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuZGlzcG9zYWJsZXMuaW5kZXhPZihpdGVtKTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHNob3VsZERpc3Bvc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZERpc3Bvc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqICBEaXNwb3NlcyBhbGwgZGlzcG9zYWJsZXMgaW4gdGhlIGdyb3VwIGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgZ3JvdXAuXG4gICAqL1xuICBDb21wb3NpdGVEaXNwb3NhYmxlUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kaXNwb3NhYmxlcy5sZW5ndGgsIGN1cnJlbnREaXNwb3NhYmxlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGN1cnJlbnREaXNwb3NhYmxlc1tpXSA9IHRoaXMuZGlzcG9zYWJsZXNbaV07IH1cbiAgICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBbXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnREaXNwb3NhYmxlc1tpXS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHNldCBvZiBzdGF0aWMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgRGlzcG9zYWJsZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3Bvc2UgQWN0aW9uIHRvIHJ1biBkdXJpbmcgdGhlIGZpcnN0IGNhbGwgdG8gZGlzcG9zZS4gVGhlIGFjdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIHJ1biBhdCBtb3N0IG9uY2UuXG4gICAqL1xuICB2YXIgRGlzcG9zYWJsZSA9IFJ4LkRpc3Bvc2FibGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb24gfHwgbm9vcDtcbiAgfTtcblxuICAvKiogUGVyZm9ybXMgdGhlIHRhc2sgb2YgY2xlYW5pbmcgdXAgcmVzb3VyY2VzLiAqL1xuICBEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmFjdGlvbigpO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkaXNwb3NhYmxlIG9iamVjdCB0aGF0IGludm9rZXMgdGhlIHNwZWNpZmllZCBhY3Rpb24gd2hlbiBkaXNwb3NlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcG9zZSBBY3Rpb24gdG8gcnVuIGR1cmluZyB0aGUgZmlyc3QgY2FsbCB0byBkaXNwb3NlLiBUaGUgYWN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgcnVuIGF0IG1vc3Qgb25jZS5cbiAgICogQHJldHVybiB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHRoYXQgcnVucyB0aGUgZ2l2ZW4gYWN0aW9uIHVwb24gZGlzcG9zYWwuXG4gICAqL1xuICB2YXIgZGlzcG9zYWJsZUNyZWF0ZSA9IERpc3Bvc2FibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV3IERpc3Bvc2FibGUoYWN0aW9uKTsgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgZGlzcG9zYWJsZSB0aGF0IGRvZXMgbm90aGluZyB3aGVuIGRpc3Bvc2VkLlxuICAgKi9cbiAgdmFyIGRpc3Bvc2FibGVFbXB0eSA9IERpc3Bvc2FibGUuZW1wdHkgPSB7IGRpc3Bvc2U6IG5vb3AgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIGRpc3Bvc2FibGVcbiAgICogQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byB0ZXN0IHdoZXRoZXIgaXQgaGFzIGEgZGlzcG9zZSBtZXRob2RcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYSBkaXNwb3NhYmxlIG9iamVjdCwgZWxzZSBmYWxzZS5cbiAgICovXG4gIHZhciBpc0Rpc3Bvc2FibGUgPSBEaXNwb3NhYmxlLmlzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQgJiYgaXNGdW5jdGlvbihkLmRpc3Bvc2UpO1xuICB9O1xuXG4gIHZhciBjaGVja0Rpc3Bvc2VkID0gRGlzcG9zYWJsZS5jaGVja0Rpc3Bvc2VkID0gZnVuY3Rpb24gKGRpc3Bvc2FibGUpIHtcbiAgICBpZiAoZGlzcG9zYWJsZS5pc0Rpc3Bvc2VkKSB7IHRocm93IG5ldyBPYmplY3REaXNwb3NlZEVycm9yKCk7IH1cbiAgfTtcblxuICB2YXIgZGlzcG9zYWJsZUZpeHVwID0gRGlzcG9zYWJsZS5fZml4dXAgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGlzRGlzcG9zYWJsZShyZXN1bHQpID8gcmVzdWx0IDogZGlzcG9zYWJsZUVtcHR5O1xuICB9O1xuXG4gIC8vIFNpbmdsZSBhc3NpZ25tZW50XG4gIHZhciBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSA9IFJ4LlNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gIH07XG4gIFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlLnByb3RvdHlwZS5nZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gIH07XG4gIFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlLnByb3RvdHlwZS5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3Bvc2FibGUgaGFzIGFscmVhZHkgYmVlbiBhc3NpZ25lZCcpOyB9XG4gICAgdmFyIHNob3VsZERpc3Bvc2UgPSB0aGlzLmlzRGlzcG9zZWQ7XG4gICAgIXNob3VsZERpc3Bvc2UgJiYgKHRoaXMuY3VycmVudCA9IHZhbHVlKTtcbiAgICBzaG91bGREaXNwb3NlICYmIHZhbHVlICYmIHZhbHVlLmRpc3Bvc2UoKTtcbiAgfTtcbiAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB2YXIgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgIG9sZCAmJiBvbGQuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBNdWx0aXBsZSBhc3NpZ25tZW50IGRpc3Bvc2FibGVcbiAgdmFyIFNlcmlhbERpc3Bvc2FibGUgPSBSeC5TZXJpYWxEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gIH07XG4gIFNlcmlhbERpc3Bvc2FibGUucHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcbiAgU2VyaWFsRGlzcG9zYWJsZS5wcm90b3R5cGUuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBzaG91bGREaXNwb3NlID0gdGhpcy5pc0Rpc3Bvc2VkO1xuICAgIGlmICghc2hvdWxkRGlzcG9zZSkge1xuICAgICAgdmFyIG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgICBvbGQgJiYgb2xkLmRpc3Bvc2UoKTtcbiAgICBzaG91bGREaXNwb3NlICYmIHZhbHVlICYmIHZhbHVlLmRpc3Bvc2UoKTtcbiAgfTtcbiAgU2VyaWFsRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBvbGQgJiYgb2xkLmRpc3Bvc2UoKTtcbiAgfTtcblxuICB2YXIgQmluYXJ5RGlzcG9zYWJsZSA9IFJ4LkJpbmFyeURpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgIHRoaXMuX2ZpcnN0ID0gZmlyc3Q7XG4gICAgdGhpcy5fc2Vjb25kID0gc2Vjb25kO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9O1xuXG4gIEJpbmFyeURpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB2YXIgb2xkMSA9IHRoaXMuX2ZpcnN0O1xuICAgICAgdGhpcy5fZmlyc3QgPSBudWxsO1xuICAgICAgb2xkMSAmJiBvbGQxLmRpc3Bvc2UoKTtcbiAgICAgIHZhciBvbGQyID0gdGhpcy5fc2Vjb25kO1xuICAgICAgdGhpcy5fc2Vjb25kID0gbnVsbDtcbiAgICAgIG9sZDIgJiYgb2xkMi5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBOQXJ5RGlzcG9zYWJsZSA9IFJ4Lk5BcnlEaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2FibGVzKSB7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBkaXNwb3NhYmxlcztcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgfTtcblxuICBOQXJ5RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9kaXNwb3NhYmxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlc1tpXS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIGRpc3Bvc2FibGUgcmVzb3VyY2UgdGhhdCBvbmx5IGRpc3Bvc2VzIGl0cyB1bmRlcmx5aW5nIGRpc3Bvc2FibGUgcmVzb3VyY2Ugd2hlbiBhbGwgZGVwZW5kZW50IGRpc3Bvc2FibGUgb2JqZWN0cyBoYXZlIGJlZW4gZGlzcG9zZWQuXG4gICAqL1xuICB2YXIgUmVmQ291bnREaXNwb3NhYmxlID0gUnguUmVmQ291bnREaXNwb3NhYmxlID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIElubmVyRGlzcG9zYWJsZShkaXNwb3NhYmxlKSB7XG4gICAgICB0aGlzLmRpc3Bvc2FibGUgPSBkaXNwb3NhYmxlO1xuICAgICAgdGhpcy5kaXNwb3NhYmxlLmNvdW50Kys7XG4gICAgICB0aGlzLmlzSW5uZXJEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIElubmVyRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5kaXNwb3NhYmxlLmlzRGlzcG9zZWQgJiYgIXRoaXMuaXNJbm5lckRpc3Bvc2VkKSB7XG4gICAgICAgIHRoaXMuaXNJbm5lckRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlLmNvdW50LS07XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2FibGUuY291bnQgPT09IDAgJiYgdGhpcy5kaXNwb3NhYmxlLmlzUHJpbWFyeURpc3Bvc2VkKSB7XG4gICAgICAgICAgdGhpcy5kaXNwb3NhYmxlLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZS51bmRlcmx5aW5nRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFJlZkNvdW50RGlzcG9zYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgZGlzcG9zYWJsZS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0Rpc3Bvc2FibGV9IGRpc3Bvc2FibGUgVW5kZXJseWluZyBkaXNwb3NhYmxlLlxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWZDb3VudERpc3Bvc2FibGUoZGlzcG9zYWJsZSkge1xuICAgICAgdGhpcy51bmRlcmx5aW5nRGlzcG9zYWJsZSA9IGRpc3Bvc2FibGU7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNQcmltYXJ5RGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSB1bmRlcmx5aW5nIGRpc3Bvc2FibGUgb25seSB3aGVuIGFsbCBkZXBlbmRlbnQgZGlzcG9zYWJsZXMgaGF2ZSBiZWVuIGRpc3Bvc2VkXG4gICAgICovXG4gICAgUmVmQ291bnREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQgJiYgIXRoaXMuaXNQcmltYXJ5RGlzcG9zZWQpIHtcbiAgICAgICAgdGhpcy5pc1ByaW1hcnlEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVuZGVybHlpbmdEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGVwZW5kZW50IGRpc3Bvc2FibGUgdGhhdCB3aGVuIGRpc3Bvc2VkIGRlY3JlYXNlcyB0aGUgcmVmY291bnQgb24gdGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkZXBlbmRlbnQgZGlzcG9zYWJsZSBjb250cmlidXRpbmcgdG8gdGhlIHJlZmVyZW5jZSBjb3VudCB0aGF0IG1hbmFnZXMgdGhlIHVuZGVybHlpbmcgZGlzcG9zYWJsZSdzIGxpZmV0aW1lLlxuICAgICAqL1xuICAgIFJlZkNvdW50RGlzcG9zYWJsZS5wcm90b3R5cGUuZ2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRGlzcG9zZWQgPyBkaXNwb3NhYmxlRW1wdHkgOiBuZXcgSW5uZXJEaXNwb3NhYmxlKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVmQ291bnREaXNwb3NhYmxlO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIFNjaGVkdWxlZERpc3Bvc2FibGUoc2NoZWR1bGVyLCBkaXNwb3NhYmxlKSB7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgdGhpcy5kaXNwb3NhYmxlID0gZGlzcG9zYWJsZTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzZWxmKSB7XG4gICAgaWYgKCFzZWxmLmlzRGlzcG9zZWQpIHtcbiAgICAgIHNlbGYuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICBzZWxmLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIFNjaGVkdWxlZERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUodGhpcywgc2NoZWR1bGVJdGVtKTtcbiAgfTtcblxuICB2YXIgU2NoZWR1bGVkSXRlbSA9IFJ4LmludGVybmFscy5TY2hlZHVsZWRJdGVtID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgc3RhdGUsIGFjdGlvbiwgZHVlVGltZSwgY29tcGFyZXIpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXIgfHwgZGVmYXVsdFN1YkNvbXBhcmVyO1xuICAgIHRoaXMuZGlzcG9zYWJsZSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICB9O1xuXG4gIFNjaGVkdWxlZEl0ZW0ucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc3Bvc2FibGUuc2V0RGlzcG9zYWJsZSh0aGlzLmludm9rZUNvcmUoKSk7XG4gIH07XG5cbiAgU2NoZWR1bGVkSXRlbS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZXIodGhpcy5kdWVUaW1lLCBvdGhlci5kdWVUaW1lKTtcbiAgfTtcblxuICBTY2hlZHVsZWRJdGVtLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwb3NhYmxlLmlzRGlzcG9zZWQ7XG4gIH07XG5cbiAgU2NoZWR1bGVkSXRlbS5wcm90b3R5cGUuaW52b2tlQ29yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcG9zYWJsZUZpeHVwKHRoaXMuYWN0aW9uKHRoaXMuc2NoZWR1bGVyLCB0aGlzLnN0YXRlKSk7XG4gIH07XG5cbiAgLyoqIFByb3ZpZGVzIGEgc2V0IG9mIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIGFjY2VzcyBjb21tb25seSB1c2VkIHNjaGVkdWxlcnMuICovXG4gIHZhciBTY2hlZHVsZXIgPSBSeC5TY2hlZHVsZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24gU2NoZWR1bGVyKCkgeyB9XG5cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBzY2hlZHVsZXIgKi9cbiAgICBTY2hlZHVsZXIuaXNTY2hlZHVsZXIgPSBmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMgaW5zdGFuY2VvZiBTY2hlZHVsZXI7XG4gICAgfTtcblxuICAgIHZhciBzY2hlZHVsZXJQcm90byA9IFNjaGVkdWxlci5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVzIGFuIGFjdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkdWVUaW1lLlxuICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIFJlbGF0aXZlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAqL1xuICAgIHNjaGVkdWxlclByb3RvLnNjaGVkdWxlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHZhciBkdCA9IGR1ZVRpbWU7XG4gICAgICBkdCBpbnN0YW5jZW9mIERhdGUgJiYgKGR0ID0gZHQgLSB0aGlzLm5vdygpKTtcbiAgICAgIGR0ID0gU2NoZWR1bGVyLm5vcm1hbGl6ZShkdCk7XG5cbiAgICAgIGlmIChkdCA9PT0gMCkgeyByZXR1cm4gdGhpcy5zY2hlZHVsZShzdGF0ZSwgYWN0aW9uKTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVGdXR1cmUoc3RhdGUsIGR0LCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICBzY2hlZHVsZXJQcm90by5fc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuXG4gICAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdGltZSBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsIG1hY2hpbmUncyBzeXN0ZW0gY2xvY2suICovXG4gICAgU2NoZWR1bGVyLm5vdyA9IGRlZmF1bHROb3c7XG5cbiAgICAvKiogR2V0cyB0aGUgY3VycmVudCB0aW1lIGFjY29yZGluZyB0byB0aGUgbG9jYWwgbWFjaGluZSdzIHN5c3RlbSBjbG9jay4gKi9cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLm5vdyA9IGRlZmF1bHROb3c7XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgVGltZVNwYW4gdmFsdWUgdG8gYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gVGhlIHRpbWUgc3BhbiB2YWx1ZSB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIHNwZWNpZmllZCBUaW1lU3BhbiB2YWx1ZSBpZiBpdCBpcyB6ZXJvIG9yIHBvc2l0aXZlOyBvdGhlcndpc2UsIDBcbiAgICAgKi9cbiAgICBTY2hlZHVsZXIubm9ybWFsaXplID0gZnVuY3Rpb24gKHRpbWVTcGFuKSB7XG4gICAgICB0aW1lU3BhbiA8IDAgJiYgKHRpbWVTcGFuID0gMCk7XG4gICAgICByZXR1cm4gdGltZVNwYW47XG4gICAgfTtcblxuICAgIHJldHVybiBTY2hlZHVsZXI7XG4gIH0oKSk7XG5cbiAgdmFyIG5vcm1hbGl6ZVRpbWUgPSBTY2hlZHVsZXIubm9ybWFsaXplLCBpc1NjaGVkdWxlciA9IFNjaGVkdWxlci5pc1NjaGVkdWxlcjtcblxuICAoZnVuY3Rpb24gKHNjaGVkdWxlclByb3RvKSB7XG5cbiAgICBmdW5jdGlvbiBpbnZva2VSZWNJbW1lZGlhdGUoc2NoZWR1bGVyLCBwYWlyKSB7XG4gICAgICB2YXIgc3RhdGUgPSBwYWlyWzBdLCBhY3Rpb24gPSBwYWlyWzFdLCBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBhY3Rpb24oc3RhdGUsIGlubmVyQWN0aW9uKTtcbiAgICAgIHJldHVybiBncm91cDtcblxuICAgICAgZnVuY3Rpb24gaW5uZXJBY3Rpb24oc3RhdGUyKSB7XG4gICAgICAgIHZhciBpc0FkZGVkID0gZmFsc2UsIGlzRG9uZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBkID0gc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlMiwgc2NoZWR1bGVXb3JrKTtcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICBncm91cC5hZGQoZCk7XG4gICAgICAgICAgaXNBZGRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoXywgc3RhdGUzKSB7XG4gICAgICAgICAgaWYgKGlzQWRkZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZShkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aW9uKHN0YXRlMywgaW5uZXJBY3Rpb24pO1xuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VSZWNEYXRlKHNjaGVkdWxlciwgcGFpcikge1xuICAgICAgdmFyIHN0YXRlID0gcGFpclswXSwgYWN0aW9uID0gcGFpclsxXSwgZ3JvdXAgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgYWN0aW9uKHN0YXRlLCBpbm5lckFjdGlvbik7XG4gICAgICByZXR1cm4gZ3JvdXA7XG5cbiAgICAgIGZ1bmN0aW9uIGlubmVyQWN0aW9uKHN0YXRlMiwgZHVlVGltZTEpIHtcbiAgICAgICAgdmFyIGlzQWRkZWQgPSBmYWxzZSwgaXNEb25lID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGQgPSBzY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUoc3RhdGUyLCBkdWVUaW1lMSwgc2NoZWR1bGVXb3JrKTtcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICBncm91cC5hZGQoZCk7XG4gICAgICAgICAgaXNBZGRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoXywgc3RhdGUzKSB7XG4gICAgICAgICAgaWYgKGlzQWRkZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZShkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aW9uKHN0YXRlMywgaW5uZXJBY3Rpb24pO1xuICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBBY3Rpb24gdG8gZXhlY3V0ZSByZWN1cnNpdmVseS4gVGhlIGxhc3QgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgYWN0aW9uIGlzIHVzZWQgdG8gdHJpZ2dlciByZWN1cnNpdmUgc2NoZWR1bGluZyBvZiB0aGUgYWN0aW9uLCBwYXNzaW5nIGluIHJlY3Vyc2l2ZSBpbnZvY2F0aW9uIHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVJlY3Vyc2l2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZShbc3RhdGUsIGFjdGlvbl0sIGludm9rZVJlY0ltbWVkaWF0ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgcmVjdXJzaXZlbHkgYWZ0ZXIgYSBzcGVjaWZpZWQgcmVsYXRpdmUgb3IgYWJzb2x1dGUgZHVlIHRpbWUuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBleGVjdXRlIHJlY3Vyc2l2ZWx5LiBUaGUgbGFzdCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBhY3Rpb24gaXMgdXNlZCB0byB0cmlnZ2VyIHJlY3Vyc2l2ZSBzY2hlZHVsaW5nIG9mIHRoZSBhY3Rpb24sIHBhc3NpbmcgaW4gdGhlIHJlY3Vyc2l2ZSBkdWUgdGltZSBhbmQgaW52b2NhdGlvbiBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlciB8IERhdGV9IGR1ZVRpbWUgUmVsYXRpdmUgb3IgYWJzb2x1dGUgdGltZSBhZnRlciB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24gZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUZ1dHVyZShbc3RhdGUsIGFjdGlvbl0sIGR1ZVRpbWUsIGludm9rZVJlY0RhdGUpO1xuICAgIH07XG5cbiAgfShTY2hlZHVsZXIucHJvdG90eXBlKSk7XG5cbiAgKGZ1bmN0aW9uIChzY2hlZHVsZXJQcm90bykge1xuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgcGVyaW9kaWMgcGllY2Ugb2Ygd29yayBieSBkeW5hbWljYWxseSBkaXNjb3ZlcmluZyB0aGUgc2NoZWR1bGVyJ3MgY2FwYWJpbGl0aWVzLiBUaGUgcGVyaW9kaWMgdGFzayB3aWxsIGJlIHNjaGVkdWxlZCB1c2luZyB3aW5kb3cuc2V0SW50ZXJ2YWwgZm9yIHRoZSBiYXNlIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIEluaXRpYWwgc3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdXBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBydW5uaW5nIHRoZSB3b3JrIHBlcmlvZGljYWxseS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLCBwb3RlbnRpYWxseSB1cGRhdGluZyB0aGUgc3RhdGUuXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IFRoZSBkaXNwb3NhYmxlIG9iamVjdCB1c2VkIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIHJlY3VycmluZyBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5zY2hlZHVsZVBlcmlvZGljID0gZnVuY3Rpb24oc3RhdGUsIHBlcmlvZCwgYWN0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHJvb3Quc2V0SW50ZXJ2YWwgPT09ICd1bmRlZmluZWQnKSB7IHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpOyB9XG4gICAgICBwZXJpb2QgPSBub3JtYWxpemVUaW1lKHBlcmlvZCk7XG4gICAgICB2YXIgcyA9IHN0YXRlLCBpZCA9IHJvb3Quc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBzID0gYWN0aW9uKHMpOyB9LCBwZXJpb2QpO1xuICAgICAgcmV0dXJuIGRpc3Bvc2FibGVDcmVhdGUoZnVuY3Rpb24gKCkgeyByb290LmNsZWFySW50ZXJ2YWwoaWQpOyB9KTtcbiAgICB9O1xuXG4gIH0oU2NoZWR1bGVyLnByb3RvdHlwZSkpO1xuXG4gIChmdW5jdGlvbiAoc2NoZWR1bGVyUHJvdG8pIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2NoZWR1bGVyIHRoYXQgd3JhcHMgdGhlIG9yaWdpbmFsIHNjaGVkdWxlciwgYWRkaW5nIGV4Y2VwdGlvbiBoYW5kbGluZyBmb3Igc2NoZWR1bGVkIGFjdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBIYW5kbGVyIHRoYXQncyBydW4gaWYgYW4gZXhjZXB0aW9uIGlzIGNhdWdodC4gVGhlIGV4Y2VwdGlvbiB3aWxsIGJlIHJldGhyb3duIGlmIHRoZSBoYW5kbGVyIHJldHVybnMgZmFsc2UuXG4gICAgICogQHJldHVybnMge1NjaGVkdWxlcn0gV3JhcHBlciBhcm91bmQgdGhlIG9yaWdpbmFsIHNjaGVkdWxlciwgZW5mb3JjaW5nIGV4Y2VwdGlvbiBoYW5kbGluZy5cbiAgICAgKi9cbiAgICBzY2hlZHVsZXJQcm90by5jYXRjaEVycm9yID0gc2NoZWR1bGVyUHJvdG9bJ2NhdGNoJ10gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgcmV0dXJuIG5ldyBDYXRjaFNjaGVkdWxlcih0aGlzLCBoYW5kbGVyKTtcbiAgICB9O1xuICB9KFNjaGVkdWxlci5wcm90b3R5cGUpKTtcblxuICB2YXIgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZSA9IFJ4LmludGVybmFscy5TY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVUaWNrKHNlbGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiB0aWNrKGNvbW1hbmQsIHJlY3Vyc2UpIHtcbiAgICAgICAgcmVjdXJzZSgwLCBzZWxmLl9wZXJpb2QpO1xuICAgICAgICB2YXIgc3RhdGUgPSB0cnlDYXRjaChzZWxmLl9hY3Rpb24pKHNlbGYuX3N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSBlcnJvck9iaikge1xuICAgICAgICAgIHNlbGYuX2NhbmNlbC5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhyb3dlcihzdGF0ZS5lKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTY2hlZHVsZVBlcmlvZGljUmVjdXJzaXZlKHNjaGVkdWxlciwgc3RhdGUsIHBlcmlvZCwgYWN0aW9uKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcGVyaW9kID0gcGVyaW9kO1xuICAgICAgdGhpcy5fYWN0aW9uID0gYWN0aW9uO1xuICAgIH1cblxuICAgIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX2NhbmNlbCA9IGQ7XG4gICAgICBkLnNldERpc3Bvc2FibGUodGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKDAsIHRoaXMuX3BlcmlvZCwgY3JlYXRlVGljayh0aGlzKSkpO1xuXG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmU7XG4gIH0oKSk7XG5cbiAgLyoqIEdldHMgYSBzY2hlZHVsZXIgdGhhdCBzY2hlZHVsZXMgd29yayBpbW1lZGlhdGVseSBvbiB0aGUgY3VycmVudCB0aHJlYWQuICovXG4gICB2YXIgSW1tZWRpYXRlU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJbW1lZGlhdGVTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gSW1tZWRpYXRlU2NoZWR1bGVyKCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW1tZWRpYXRlU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUZpeHVwKGFjdGlvbih0aGlzLCBzdGF0ZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW1tZWRpYXRlU2NoZWR1bGVyO1xuICB9KFNjaGVkdWxlcikpO1xuXG4gIHZhciBpbW1lZGlhdGVTY2hlZHVsZXIgPSBTY2hlZHVsZXIuaW1tZWRpYXRlID0gbmV3IEltbWVkaWF0ZVNjaGVkdWxlcigpO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgc2NoZWR1bGVyIHRoYXQgc2NoZWR1bGVzIHdvcmsgYXMgc29vbiBhcyBwb3NzaWJsZSBvbiB0aGUgY3VycmVudCB0aHJlYWQuXG4gICAqL1xuICB2YXIgQ3VycmVudFRocmVhZFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgdmFyIHF1ZXVlO1xuXG4gICAgZnVuY3Rpb24gcnVuVHJhbXBvbGluZSAoKSB7XG4gICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgIWl0ZW0uaXNDYW5jZWxsZWQoKSAmJiBpdGVtLmludm9rZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluaGVyaXRzKEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ3VycmVudFRocmVhZFNjaGVkdWxlcigpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEN1cnJlbnRUaHJlYWRTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHZhciBzaSA9IG5ldyBTY2hlZHVsZWRJdGVtKHRoaXMsIHN0YXRlLCBhY3Rpb24sIHRoaXMubm93KCkpO1xuXG4gICAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICAgIHF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoNCk7XG4gICAgICAgIHF1ZXVlLmVucXVldWUoc2kpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChydW5UcmFtcG9saW5lKSgpO1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHRocm93ZXIocmVzdWx0LmUpOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZS5lbnF1ZXVlKHNpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaS5kaXNwb3NhYmxlO1xuICAgIH07XG5cbiAgICBDdXJyZW50VGhyZWFkU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZVJlcXVpcmVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gIXF1ZXVlOyB9O1xuXG4gICAgcmV0dXJuIEN1cnJlbnRUaHJlYWRTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgdmFyIGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIgPSBTY2hlZHVsZXIuY3VycmVudFRocmVhZCA9IG5ldyBDdXJyZW50VGhyZWFkU2NoZWR1bGVyKCk7XG5cbiAgdmFyIHNjaGVkdWxlTWV0aG9kLCBjbGVhck1ldGhvZDtcblxuICB2YXIgbG9jYWxUaW1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxvY2FsU2V0VGltZW91dCwgbG9jYWxDbGVhclRpbWVvdXQgPSBub29wO1xuICAgIGlmICghIXJvb3Quc2V0VGltZW91dCkge1xuICAgICAgbG9jYWxTZXRUaW1lb3V0ID0gcm9vdC5zZXRUaW1lb3V0O1xuICAgICAgbG9jYWxDbGVhclRpbWVvdXQgPSByb290LmNsZWFyVGltZW91dDtcbiAgICB9IGVsc2UgaWYgKCEhcm9vdC5XU2NyaXB0KSB7XG4gICAgICBsb2NhbFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcbiAgICAgICAgcm9vdC5XU2NyaXB0LlNsZWVwKHRpbWUpO1xuICAgICAgICBmbigpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFRpbWVvdXQ6IGxvY2FsU2V0VGltZW91dCxcbiAgICAgIGNsZWFyVGltZW91dDogbG9jYWxDbGVhclRpbWVvdXRcbiAgICB9O1xuICB9KCkpO1xuICB2YXIgbG9jYWxTZXRUaW1lb3V0ID0gbG9jYWxUaW1lci5zZXRUaW1lb3V0LFxuICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID0gbG9jYWxUaW1lci5jbGVhclRpbWVvdXQ7XG5cbiAgKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBuZXh0SGFuZGxlID0gMSwgdGFza3NCeUhhbmRsZSA9IHt9LCBjdXJyZW50bHlSdW5uaW5nID0gZmFsc2U7XG5cbiAgICBjbGVhck1ldGhvZCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1blRhc2soaGFuZGxlKSB7XG4gICAgICBpZiAoY3VycmVudGx5UnVubmluZykge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBydW5UYXNrKGhhbmRsZSk7IH0sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgY3VycmVudGx5UnVubmluZyA9IHRydWU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRhc2spKCk7XG4gICAgICAgICAgY2xlYXJNZXRob2QoaGFuZGxlKTtcbiAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgdGhyb3dlcihyZXN1bHQuZSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZU5hdGl2ZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAgIFN0cmluZyh0b1N0cmluZylcbiAgICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfCBmb3IgW15cXF1dKy9nLCAnLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgdmFyIHNldEltbWVkaWF0ZSA9IHR5cGVvZiAoc2V0SW1tZWRpYXRlID0gZnJlZUdsb2JhbCAmJiBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwuc2V0SW1tZWRpYXRlKSA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAhcmVOYXRpdmUudGVzdChzZXRJbW1lZGlhdGUpICYmIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHBvc3RNZXNzYWdlU3VwcG9ydGVkICgpIHtcbiAgICAgIC8vIEVuc3VyZSBub3QgaW4gYSB3b3JrZXJcbiAgICAgIGlmICghcm9vdC5wb3N0TWVzc2FnZSB8fCByb290LmltcG9ydFNjcmlwdHMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICB2YXIgaXNBc3luYyA9IGZhbHNlLCBvbGRIYW5kbGVyID0gcm9vdC5vbm1lc3NhZ2U7XG4gICAgICAvLyBUZXN0IGZvciBhc3luY1xuICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7IGlzQXN5bmMgPSB0cnVlOyB9O1xuICAgICAgcm9vdC5wb3N0TWVzc2FnZSgnJywgJyonKTtcbiAgICAgIHJvb3Qub25tZXNzYWdlID0gb2xkSGFuZGxlcjtcblxuICAgICAgcmV0dXJuIGlzQXN5bmM7XG4gICAgfVxuXG4gICAgLy8gVXNlIGluIG9yZGVyLCBzZXRJbW1lZGlhdGUsIG5leHRUaWNrLCBwb3N0TWVzc2FnZSwgTWVzc2FnZUNoYW5uZWwsIHNjcmlwdCByZWFkeXN0YXRlY2hhbmdlZCwgc2V0VGltZW91dFxuICAgIGlmIChpc0Z1bmN0aW9uKHNldEltbWVkaWF0ZSkpIHtcbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgeyBydW5UYXNrKGlkKTsgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuVGFzayhpZCk7IH0pO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwb3N0TWVzc2FnZVN1cHBvcnRlZCgpKSB7XG4gICAgICB2YXIgTVNHX1BSRUZJWCA9ICdtcy5yeC5zY2hlZHVsZScgKyBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICB2YXIgb25HbG9iYWxQb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBPbmx5IGlmIHdlJ3JlIGEgbWF0Y2ggdG8gYXZvaWQgYW55IG90aGVyIGdsb2JhbCBldmVudHNcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyAmJiBldmVudC5kYXRhLnN1YnN0cmluZygwLCBNU0dfUFJFRklYLmxlbmd0aCkgPT09IE1TR19QUkVGSVgpIHtcbiAgICAgICAgICBydW5UYXNrKGV2ZW50LmRhdGEuc3Vic3RyaW5nKE1TR19QUkVGSVgubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uR2xvYmFsUG9zdE1lc3NhZ2UsIGZhbHNlKTtcblxuICAgICAgc2NoZWR1bGVNZXRob2QgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZCA9IG5leHRIYW5kbGUrKztcbiAgICAgICAgdGFza3NCeUhhbmRsZVtpZF0gPSBhY3Rpb247XG4gICAgICAgIHJvb3QucG9zdE1lc3NhZ2UoTVNHX1BSRUZJWCArIGlkLCAnKicpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoISFyb290Lk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyByb290Lk1lc3NhZ2VDaGFubmVsKCk7XG5cbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHsgcnVuVGFzayhlLmRhdGEpOyB9O1xuXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGlkID0gbmV4dEhhbmRsZSsrO1xuICAgICAgICB0YXNrc0J5SGFuZGxlW2lkXSA9IGFjdGlvbjtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShpZCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgnZG9jdW1lbnQnIGluIHJvb3QgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gcm9vdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXG4gICAgICBzY2hlZHVsZU1ldGhvZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNjcmlwdEVsZW1lbnQgPSByb290LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuXG4gICAgICAgIHNjcmlwdEVsZW1lbnQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJ1blRhc2soaWQpO1xuICAgICAgICAgIHNjcmlwdEVsZW1lbnQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICBzY3JpcHRFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWxlbWVudCk7XG4gICAgICAgICAgc2NyaXB0RWxlbWVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlTWV0aG9kID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgaWQgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaWRdID0gYWN0aW9uO1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJ1blRhc2soaWQpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIH1cbiAgfSgpKTtcblxuICAvKipcbiAgICogR2V0cyBhIHNjaGVkdWxlciB0aGF0IHNjaGVkdWxlcyB3b3JrIHZpYSBhIHRpbWVkIGNhbGxiYWNrIGJhc2VkIHVwb24gcGxhdGZvcm0uXG4gICAqL1xuICAgdmFyIERlZmF1bHRTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgICBpbmhlcml0cyhEZWZhdWx0U2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuICAgICBmdW5jdGlvbiBEZWZhdWx0U2NoZWR1bGVyKCkge1xuICAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICB9XG5cbiAgICAgZnVuY3Rpb24gc2NoZWR1bGVBY3Rpb24oZGlzcG9zYWJsZSwgYWN0aW9uLCBzY2hlZHVsZXIsIHN0YXRlKSB7XG4gICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICAgICAgICAgZGlzcG9zYWJsZS5zZXREaXNwb3NhYmxlKERpc3Bvc2FibGUuX2ZpeHVwKGFjdGlvbihzY2hlZHVsZXIsIHN0YXRlKSkpO1xuICAgICAgIH07XG4gICAgIH1cblxuICAgICBmdW5jdGlvbiBDbGVhckRpc3Bvc2FibGUoaWQpIHtcbiAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICB9XG5cbiAgICAgQ2xlYXJEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgY2xlYXJNZXRob2QodGhpcy5faWQpO1xuICAgICAgIH1cbiAgICAgfTtcblxuICAgICBmdW5jdGlvbiBMb2NhbENsZWFyRGlzcG9zYWJsZShpZCkge1xuICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgIH1cblxuICAgICBMb2NhbENsZWFyRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRoaXMuX2lkKTtcbiAgICAgICB9XG4gICAgIH07XG5cbiAgICBEZWZhdWx0U2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICAgIGlkID0gc2NoZWR1bGVNZXRob2Qoc2NoZWR1bGVBY3Rpb24oZGlzcG9zYWJsZSwgYWN0aW9uLCB0aGlzLCBzdGF0ZSkpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGRpc3Bvc2FibGUsIG5ldyBDbGVhckRpc3Bvc2FibGUoaWQpKTtcbiAgICB9O1xuXG4gICAgRGVmYXVsdFNjaGVkdWxlci5wcm90b3R5cGUuX3NjaGVkdWxlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIGlmIChkdWVUaW1lID09PSAwKSB7IHJldHVybiB0aGlzLnNjaGVkdWxlKHN0YXRlLCBhY3Rpb24pOyB9XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLFxuICAgICAgICAgIGlkID0gbG9jYWxTZXRUaW1lb3V0KHNjaGVkdWxlQWN0aW9uKGRpc3Bvc2FibGUsIGFjdGlvbiwgdGhpcywgc3RhdGUpLCBkdWVUaW1lKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShkaXNwb3NhYmxlLCBuZXcgTG9jYWxDbGVhckRpc3Bvc2FibGUoaWQpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVMb25nUnVubmluZyhzdGF0ZSwgYWN0aW9uLCBkaXNwb3NhYmxlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBhY3Rpb24oc3RhdGUsIGRpc3Bvc2FibGUpOyB9O1xuICAgIH1cblxuICAgIERlZmF1bHRTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlTG9uZ1J1bm5pbmcgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgdmFyIGRpc3Bvc2FibGUgPSBkaXNwb3NhYmxlQ3JlYXRlKG5vb3ApO1xuICAgICAgc2NoZWR1bGVNZXRob2Qoc2NoZWR1bGVMb25nUnVubmluZyhzdGF0ZSwgYWN0aW9uLCBkaXNwb3NhYmxlKSk7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlZmF1bHRTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgdmFyIGRlZmF1bHRTY2hlZHVsZXIgPSBTY2hlZHVsZXJbJ2RlZmF1bHQnXSA9IFNjaGVkdWxlci5hc3luYyA9IG5ldyBEZWZhdWx0U2NoZWR1bGVyKCk7XG5cbiAgdmFyIENhdGNoU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDYXRjaFNjaGVkdWxlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIENhdGNoU2NoZWR1bGVyKHNjaGVkdWxlciwgaGFuZGxlcikge1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICB0aGlzLl9yZWN1cnNpdmVPcmlnaW5hbCA9IG51bGw7XG4gICAgICB0aGlzLl9yZWN1cnNpdmVXcmFwcGVyID0gbnVsbDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCB0aGlzLl93cmFwKGFjdGlvbikpO1xuICAgIH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuX3NjaGVkdWxlRnV0dXJlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIGR1ZVRpbWUsIHRoaXMuX3dyYXAoYWN0aW9uKSk7XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zY2hlZHVsZXIubm93KCk7IH07XG5cbiAgICBDYXRjaFNjaGVkdWxlci5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IENhdGNoU2NoZWR1bGVyKHNjaGVkdWxlciwgdGhpcy5faGFuZGxlcik7XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fd3JhcCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmLCBzdGF0ZSkge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2goYWN0aW9uKShwYXJlbnQuX2dldFJlY3Vyc2l2ZVdyYXBwZXIoc2VsZiksIHN0YXRlKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICBpZiAoIXBhcmVudC5faGFuZGxlcihyZXMuZSkpIHsgdGhyb3dlcihyZXMuZSk7IH1cbiAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRml4dXAocmVzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIENhdGNoU2NoZWR1bGVyLnByb3RvdHlwZS5fZ2V0UmVjdXJzaXZlV3JhcHBlciA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgIGlmICh0aGlzLl9yZWN1cnNpdmVPcmlnaW5hbCAhPT0gc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZU9yaWdpbmFsID0gc2NoZWR1bGVyO1xuICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuX2Nsb25lKHNjaGVkdWxlcik7XG4gICAgICAgIHdyYXBwZXIuX3JlY3Vyc2l2ZU9yaWdpbmFsID0gc2NoZWR1bGVyO1xuICAgICAgICB3cmFwcGVyLl9yZWN1cnNpdmVXcmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlV3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVjdXJzaXZlV3JhcHBlcjtcbiAgICB9O1xuXG4gICAgQ2F0Y2hTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlUGVyaW9kaWMgPSBmdW5jdGlvbiAoc3RhdGUsIHBlcmlvZCwgYWN0aW9uKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIGZhaWxlZCA9IGZhbHNlLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIGQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVQZXJpb2RpYyhzdGF0ZSwgcGVyaW9kLCBmdW5jdGlvbiAoc3RhdGUxKSB7XG4gICAgICAgIGlmIChmYWlsZWQpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKGFjdGlvbikoc3RhdGUxKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICghc2VsZi5faGFuZGxlcihyZXMuZSkpIHsgdGhyb3dlcihyZXMuZSk7IH1cbiAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhdGNoU2NoZWR1bGVyO1xuICB9KFNjaGVkdWxlcikpO1xuXG4gIGZ1bmN0aW9uIEluZGV4ZWRJdGVtKGlkLCB2YWx1ZSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBJbmRleGVkSXRlbS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGMgPSB0aGlzLnZhbHVlLmNvbXBhcmVUbyhvdGhlci52YWx1ZSk7XG4gICAgYyA9PT0gMCAmJiAoYyA9IHRoaXMuaWQgLSBvdGhlci5pZCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgdmFyIFByaW9yaXR5UXVldWUgPSBSeC5pbnRlcm5hbHMuUHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uIChjYXBhY2l0eSkge1xuICAgIHRoaXMuaXRlbXMgPSBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICB2YXIgcHJpb3JpdHlQcm90byA9IFByaW9yaXR5UXVldWUucHJvdG90eXBlO1xuICBwcmlvcml0eVByb3RvLmlzSGlnaGVyUHJpb3JpdHkgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tsZWZ0XS5jb21wYXJlVG8odGhpcy5pdGVtc1tyaWdodF0pIDwgMDtcbiAgfTtcblxuICBwcmlvcml0eVByb3RvLnBlcmNvbGF0ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHsgcmV0dXJuOyB9XG4gICAgdmFyIHBhcmVudCA9IGluZGV4IC0gMSA+PiAxO1xuICAgIGlmIChwYXJlbnQgPCAwIHx8IHBhcmVudCA9PT0gaW5kZXgpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMuaXNIaWdoZXJQcmlvcml0eShpbmRleCwgcGFyZW50KSkge1xuICAgICAgdmFyIHRlbXAgPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdGhpcy5pdGVtc1twYXJlbnRdO1xuICAgICAgdGhpcy5pdGVtc1twYXJlbnRdID0gdGVtcDtcbiAgICAgIHRoaXMucGVyY29sYXRlKHBhcmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8uaGVhcGlmeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICtpbmRleCB8fCAoaW5kZXggPSAwKTtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGggfHwgaW5kZXggPCAwKSB7IHJldHVybjsgfVxuICAgIHZhciBsZWZ0ID0gMiAqIGluZGV4ICsgMSxcbiAgICAgICAgcmlnaHQgPSAyICogaW5kZXggKyAyLFxuICAgICAgICBmaXJzdCA9IGluZGV4O1xuICAgIGlmIChsZWZ0IDwgdGhpcy5sZW5ndGggJiYgdGhpcy5pc0hpZ2hlclByaW9yaXR5KGxlZnQsIGZpcnN0KSkge1xuICAgICAgZmlyc3QgPSBsZWZ0O1xuICAgIH1cbiAgICBpZiAocmlnaHQgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLmlzSGlnaGVyUHJpb3JpdHkocmlnaHQsIGZpcnN0KSkge1xuICAgICAgZmlyc3QgPSByaWdodDtcbiAgICB9XG4gICAgaWYgKGZpcnN0ICE9PSBpbmRleCkge1xuICAgICAgdmFyIHRlbXAgPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gdGhpcy5pdGVtc1tmaXJzdF07XG4gICAgICB0aGlzLml0ZW1zW2ZpcnN0XSA9IHRlbXA7XG4gICAgICB0aGlzLmhlYXBpZnkoZmlyc3QpO1xuICAgIH1cbiAgfTtcblxuICBwcmlvcml0eVByb3RvLnBlZWsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZW1zWzBdLnZhbHVlOyB9O1xuXG4gIHByaW9yaXR5UHJvdG8ucmVtb3ZlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHRoaXMuaXRlbXNbLS10aGlzLmxlbmd0aF07XG4gICAgdGhpcy5pdGVtc1t0aGlzLmxlbmd0aF0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWFwaWZ5KCk7XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnBlZWsoKTtcbiAgICB0aGlzLnJlbW92ZUF0KDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcHJpb3JpdHlQcm90by5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gbmV3IEluZGV4ZWRJdGVtKFByaW9yaXR5UXVldWUuY291bnQrKywgaXRlbSk7XG4gICAgdGhpcy5wZXJjb2xhdGUoaW5kZXgpO1xuICB9O1xuXG4gIHByaW9yaXR5UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLml0ZW1zW2ldLnZhbHVlID09PSBpdGVtKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFByaW9yaXR5UXVldWUuY291bnQgPSAwO1xuXG4gIC8qKlxuICAgKiAgUmVwcmVzZW50cyBhIG5vdGlmaWNhdGlvbiB0byBhbiBvYnNlcnZlci5cbiAgICovXG4gIHZhciBOb3RpZmljYXRpb24gPSBSeC5Ob3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbigpIHtcblxuICAgIH1cblxuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG5cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHRPYnNlcnZlciA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBkZWxlZ2F0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBub3RpZmljYXRpb24gb3IgdGhlIG9ic2VydmVyJ3MgbWV0aG9kIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5vdGlmaWNhdGlvbiBhbmQgcmV0dXJucyB0aGUgcHJvZHVjZWQgcmVzdWx0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYnNlcnZlcn0gb2JzZXJ2ZXJPck9uTmV4dCBGdW5jdGlvbiB0byBpbnZva2UgZm9yIGFuIE9uTmV4dCBub3RpZmljYXRpb24gb3IgT2JzZXJ2ZXIgdG8gaW52b2tlIHRoZSBub3RpZmljYXRpb24gb24uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgRnVuY3Rpb24gdG8gaW52b2tlIGZvciBhbiBPbkVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBGdW5jdGlvbiB0byBpbnZva2UgZm9yIGFuIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QW55fSBSZXN1bHQgcHJvZHVjZWQgYnkgdGhlIG9ic2VydmF0aW9uLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXJPck9uTmV4dCAmJiB0eXBlb2Ygb2JzZXJ2ZXJPck9uTmV4dCA9PT0gJ29iamVjdCcgP1xuICAgICAgICB0aGlzLl9hY2NlcHRPYnNlcnZlcihvYnNlcnZlck9yT25OZXh0KSA6XG4gICAgICAgIHRoaXMuX2FjY2VwdChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBOb3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBzZW5kIG91dCB0aGUgbm90aWZpY2F0aW9uIGNhbGxzIG9uLlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHN1cmZhY2VzIHRoZSBiZWhhdmlvciBvZiB0aGUgbm90aWZpY2F0aW9uIHVwb24gc3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9PYnNlcnZhYmxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKHNlbGYsIGZ1bmN0aW9uIChfLCBub3RpZmljYXRpb24pIHtcbiAgICAgICAgICBub3RpZmljYXRpb24uX2FjY2VwdE9ic2VydmVyKG8pO1xuICAgICAgICAgIG5vdGlmaWNhdGlvbi5raW5kID09PSAnTicgJiYgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xuICB9KSgpO1xuXG4gIHZhciBPbk5leHROb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9uTmV4dE5vdGlmaWNhdGlvbiwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbk5leHROb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMua2luZCA9ICdOJztcbiAgICB9XG5cbiAgICBPbk5leHROb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHQgPSBmdW5jdGlvbiAob25OZXh0KSB7XG4gICAgICByZXR1cm4gb25OZXh0KHRoaXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBPbk5leHROb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHRPYnNlcnZlciA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5vbk5leHQodGhpcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIE9uTmV4dE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ09uTmV4dCgnICsgdGhpcy52YWx1ZSArICcpJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9uTmV4dE5vdGlmaWNhdGlvbjtcbiAgfShOb3RpZmljYXRpb24pKTtcblxuICB2YXIgT25FcnJvck5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25FcnJvck5vdGlmaWNhdGlvbiwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yTm90aWZpY2F0aW9uKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB0aGlzLmtpbmQgPSAnRSc7XG4gICAgfVxuXG4gICAgT25FcnJvck5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IpIHtcbiAgICAgIHJldHVybiBvbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgIH07XG5cbiAgICBPbkVycm9yTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0T2JzZXJ2ZXIgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICB9O1xuXG4gICAgT25FcnJvck5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ09uRXJyb3IoJyArIHRoaXMuZXJyb3IgKyAnKSc7XG4gICAgfTtcblxuICAgIHJldHVybiBPbkVycm9yTm90aWZpY2F0aW9uO1xuICB9KE5vdGlmaWNhdGlvbikpO1xuXG4gIHZhciBPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25Db21wbGV0ZWROb3RpZmljYXRpb24sIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gT25Db21wbGV0ZWROb3RpZmljYXRpb24oKSB7XG4gICAgICB0aGlzLmtpbmQgPSAnQyc7XG4gICAgfVxuXG4gICAgT25Db21wbGV0ZWROb3RpZmljYXRpb24ucHJvdG90eXBlLl9hY2NlcHQgPSBmdW5jdGlvbiAob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuIG9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWNjZXB0T2JzZXJ2ZXIgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgT25Db21wbGV0ZWROb3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdPbkNvbXBsZXRlZCgpJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9uQ29tcGxldGVkTm90aWZpY2F0aW9uO1xuICB9KE5vdGlmaWNhdGlvbikpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gT25OZXh0IG5vdGlmaWNhdGlvbiB0byBhbiBvYnNlcnZlci5cbiAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIG5vdGlmaWNhdGlvbi5cbiAgICogQHJldHVybnMge05vdGlmaWNhdGlvbn0gVGhlIE9uTmV4dCBub3RpZmljYXRpb24gY29udGFpbmluZyB0aGUgdmFsdWUuXG4gICAqL1xuICB2YXIgbm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0ID0gTm90aWZpY2F0aW9uLmNyZWF0ZU9uTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgT25OZXh0Tm90aWZpY2F0aW9uKHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIE9uRXJyb3Igbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxuICAgKiBAcGFyYW0ge0FueX0gZXJyb3IgVGhlIGV4Y2VwdGlvbiBjb250YWluZWQgaW4gdGhlIG5vdGlmaWNhdGlvbi5cbiAgICogQHJldHVybnMge05vdGlmaWNhdGlvbn0gVGhlIE9uRXJyb3Igbm90aWZpY2F0aW9uIGNvbnRhaW5pbmcgdGhlIGV4Y2VwdGlvbi5cbiAgICovXG4gIHZhciBub3RpZmljYXRpb25DcmVhdGVPbkVycm9yID0gTm90aWZpY2F0aW9uLmNyZWF0ZU9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IE9uRXJyb3JOb3RpZmljYXRpb24oZXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uIHRvIGFuIG9ic2VydmVyLlxuICAgKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9ufSBUaGUgT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgdmFyIG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkID0gTm90aWZpY2F0aW9uLmNyZWF0ZU9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgT25Db21wbGV0ZWROb3RpZmljYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogU3VwcG9ydHMgcHVzaC1zdHlsZSBpdGVyYXRpb24gb3ZlciBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKi9cbiAgdmFyIE9ic2VydmVyID0gUnguT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7IH07XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGEgbm90aWZpY2F0aW9uIGNhbGxiYWNrIGZyb20gYW4gb2JzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIFRoZSBhY3Rpb24gdGhhdCBmb3J3YXJkcyBpdHMgaW5wdXQgbm90aWZpY2F0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIG9ic2VydmVyLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLnRvTm90aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9ic2VydmVyID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4uYWNjZXB0KG9ic2VydmVyKTsgfTtcbiAgfTtcblxuICAvKipcbiAgICogIEhpZGVzIHRoZSBpZGVudGl0eSBvZiBhbiBvYnNlcnZlci5cbiAgICogQHJldHVybnMgQW4gb2JzZXJ2ZXIgdGhhdCBoaWRlcyB0aGUgaWRlbnRpdHkgb2YgdGhlIHNwZWNpZmllZCBvYnNlcnZlci5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS5hc09ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmVyKFxuICAgICAgZnVuY3Rpb24gKHgpIHsgc2VsZi5vbk5leHQoeCk7IH0sXG4gICAgICBmdW5jdGlvbiAoZXJyKSB7IHNlbGYub25FcnJvcihlcnIpOyB9LFxuICAgICAgZnVuY3Rpb24gKCkgeyBzZWxmLm9uQ29tcGxldGVkKCk7IH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgQ2hlY2tzIGFjY2VzcyB0byB0aGUgb2JzZXJ2ZXIgZm9yIGdyYW1tYXIgdmlvbGF0aW9ucy4gVGhpcyBpbmNsdWRlcyBjaGVja2luZyBmb3IgbXVsdGlwbGUgT25FcnJvciBvciBPbkNvbXBsZXRlZCBjYWxscywgYXMgd2VsbCBhcyByZWVudHJhbmN5IGluIGFueSBvZiB0aGUgb2JzZXJ2ZXIgbWV0aG9kcy5cbiAgICogIElmIGEgdmlvbGF0aW9uIGlzIGRldGVjdGVkLCBhbiBFcnJvciBpcyB0aHJvd24gZnJvbSB0aGUgb2ZmZW5kaW5nIG9ic2VydmVyIG1ldGhvZCBjYWxsLlxuICAgKiBAcmV0dXJucyBBbiBvYnNlcnZlciB0aGF0IGNoZWNrcyBjYWxsYmFja3MgaW52b2NhdGlvbnMgYWdhaW5zdCB0aGUgb2JzZXJ2ZXIgZ3JhbW1hciBhbmQsIGlmIHRoZSBjaGVja3MgcGFzcywgZm9yd2FyZHMgdGhvc2UgdG8gdGhlIHNwZWNpZmllZCBvYnNlcnZlci5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS5jaGVja2VkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENoZWNrZWRPYnNlcnZlcih0aGlzKTsgfTtcblxuICAvKipcbiAgICogIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgZnJvbSB0aGUgc3BlY2lmaWVkIE9uTmV4dCwgYWxvbmcgd2l0aCBvcHRpb25hbCBPbkVycm9yLCBhbmQgT25Db21wbGV0ZWQgYWN0aW9ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTmV4dF0gT2JzZXJ2ZXIncyBPbk5leHQgYWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gT2JzZXJ2ZXIncyBPbkVycm9yIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uQ29tcGxldGVkXSBPYnNlcnZlcidzIE9uQ29tcGxldGVkIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHJldHVybnMge09ic2VydmVyfSBUaGUgb2JzZXJ2ZXIgb2JqZWN0IGltcGxlbWVudGVkIHVzaW5nIHRoZSBnaXZlbiBhY3Rpb25zLlxuICAgKi9cbiAgdmFyIG9ic2VydmVyQ3JlYXRlID0gT2JzZXJ2ZXIuY3JlYXRlID0gZnVuY3Rpb24gKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQpIHtcbiAgICBvbk5leHQgfHwgKG9uTmV4dCA9IG5vb3ApO1xuICAgIG9uRXJyb3IgfHwgKG9uRXJyb3IgPSBkZWZhdWx0RXJyb3IpO1xuICAgIG9uQ29tcGxldGVkIHx8IChvbkNvbXBsZXRlZCA9IG5vb3ApO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2ZXIob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGFuIG9ic2VydmVyIGZyb20gYSBub3RpZmljYXRpb24gY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgQWN0aW9uIHRoYXQgaGFuZGxlcyBhIG5vdGlmaWNhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIG9ic2VydmVyIG9iamVjdCB0aGF0IGludm9rZXMgdGhlIHNwZWNpZmllZCBoYW5kbGVyIHVzaW5nIGEgbm90aWZpY2F0aW9uIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBtZXNzYWdlIGl0IHJlY2VpdmVzLlxuICAgKi9cbiAgT2JzZXJ2ZXIuZnJvbU5vdGlmaWVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIHRoaXNBcmcpIHtcbiAgICB2YXIgY2IgPSBiaW5kQ2FsbGJhY2soaGFuZGxlciwgdGhpc0FyZywgMSk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZlcihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGNiKG5vdGlmaWNhdGlvbkNyZWF0ZU9uTmV4dCh4KSk7XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBjYihub3RpZmljYXRpb25DcmVhdGVPbkVycm9yKGUpKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2Iobm90aWZpY2F0aW9uQ3JlYXRlT25Db21wbGV0ZWQoKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyB0aGUgaW52b2NhdGlvbiBvZiBvYnNlcnZlciBtZXRob2RzIG9uIHRoZSBnaXZlbiBzY2hlZHVsZXIuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHNjaGVkdWxlIG9ic2VydmVyIG1lc3NhZ2VzIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2ZXJ9IE9ic2VydmVyIHdob3NlIG1lc3NhZ2VzIGFyZSBzY2hlZHVsZWQgb24gdGhlIGdpdmVuIHNjaGVkdWxlci5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS5ub3RpZnlPbiA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmVPbk9ic2VydmVyKHNjaGVkdWxlciwgdGhpcyk7XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLm1ha2VTYWZlID0gZnVuY3Rpb24oZGlzcG9zYWJsZSkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzU2FmZU9ic2VydmVyKHRoaXMuX29uTmV4dCwgdGhpcy5fb25FcnJvciwgdGhpcy5fb25Db21wbGV0ZWQsIGRpc3Bvc2FibGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIE9ic2VydmVyIGNsYXNzLlxuICAgKiBUaGlzIGJhc2UgY2xhc3MgZW5mb3JjZXMgdGhlIGdyYW1tYXIgb2Ygb2JzZXJ2ZXJzIHdoZXJlIE9uRXJyb3IgYW5kIE9uQ29tcGxldGVkIGFyZSB0ZXJtaW5hbCBtZXNzYWdlcy5cbiAgICovXG4gIHZhciBBYnN0cmFjdE9ic2VydmVyID0gUnguaW50ZXJuYWxzLkFic3RyYWN0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEFic3RyYWN0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9ic2VydmVyIGluIGEgbm9uLXN0b3BwZWQgc3RhdGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RPYnNlcnZlcigpIHtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBvdGhlciBvYnNlcnZlcnNcbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gbm90SW1wbGVtZW50ZWQ7XG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBub3RJbXBsZW1lbnRlZDtcbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBub3RJbXBsZW1lbnRlZDtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBvYnNlcnZlciBvZiBhIG5ldyBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgTmV4dCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBBYnN0cmFjdE9ic2VydmVyLnByb3RvdHlwZS5vbk5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLm5leHQodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgb2JzZXJ2ZXIgdGhhdCBhbiBleGNlcHRpb24gaGFzIG9jY3VycmVkLlxuICAgICAqIEBwYXJhbSB7QW55fSBlcnJvciBUaGUgZXJyb3IgdGhhdCBoYXMgb2NjdXJyZWQuXG4gICAgICovXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgb2JzZXJ2ZXIgb2YgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICovXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUub25Db21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIG9ic2VydmVyLCBjYXVzaW5nIGl0IHRvIHRyYW5zaXRpb24gdG8gdGhlIHN0b3BwZWQgc3RhdGUuXG4gICAgICovXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pc1N0b3BwZWQgPSB0cnVlOyB9O1xuXG4gICAgQWJzdHJhY3RPYnNlcnZlci5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFic3RyYWN0T2JzZXJ2ZXI7XG4gIH0oT2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ2xhc3MgdG8gY3JlYXRlIGFuIE9ic2VydmVyIGluc3RhbmNlIGZyb20gZGVsZWdhdGUtYmFzZWQgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBvbiogbWV0aG9kcy5cbiAgICovXG4gIHZhciBBbm9ueW1vdXNPYnNlcnZlciA9IFJ4LkFub255bW91c09ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBbm9ueW1vdXNPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JzZXJ2ZXIgZnJvbSB0aGUgc3BlY2lmaWVkIE9uTmV4dCwgT25FcnJvciwgYW5kIE9uQ29tcGxldGVkIGFjdGlvbnMuXG4gICAgICogQHBhcmFtIHtBbnl9IG9uTmV4dCBPYnNlcnZlcidzIE9uTmV4dCBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IG9uRXJyb3IgT2JzZXJ2ZXIncyBPbkVycm9yIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gb25Db21wbGV0ZWQgT2JzZXJ2ZXIncyBPbkNvbXBsZXRlZCBhY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5vbnltb3VzT2JzZXJ2ZXIob25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9vbk5leHQgPSBvbk5leHQ7XG4gICAgICB0aGlzLl9vbkVycm9yID0gb25FcnJvcjtcbiAgICAgIHRoaXMuX29uQ29tcGxldGVkID0gb25Db21wbGV0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG9uTmV4dCBhY3Rpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIE5leHQgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICovXG4gICAgQW5vbnltb3VzT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX29uTmV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBvbkVycm9yIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gZXJyb3IgVGhlIGVycm9yIHRoYXQgaGFzIG9jY3VycmVkLlxuICAgICAqL1xuICAgIEFub255bW91c09ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdGhpcy5fb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBDYWxscyB0aGUgb25Db21wbGV0ZWQgYWN0aW9uLlxuICAgICAqL1xuICAgIEFub255bW91c09ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQW5vbnltb3VzT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBDaGVja2VkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENoZWNrZWRPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIENoZWNrZWRPYnNlcnZlcihvYnNlcnZlcikge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5fc3RhdGUgPSAwOyAvLyAwIC0gaWRsZSwgMSAtIGJ1c3ksIDIgLSBkb25lXG4gICAgfVxuXG4gICAgdmFyIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZSA9IENoZWNrZWRPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUub25OZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLmNoZWNrQWNjZXNzKCk7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fb2JzZXJ2ZXIub25OZXh0KS5jYWxsKHRoaXMuX29ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgIH07XG5cbiAgICBDaGVja2VkT2JzZXJ2ZXJQcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRoaXMuY2hlY2tBY2Nlc3MoKTtcbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9vYnNlcnZlci5vbkVycm9yKS5jYWxsKHRoaXMuX29ic2VydmVyLCBlcnIpO1xuICAgICAgdGhpcy5fc3RhdGUgPSAyO1xuICAgICAgcmVzID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlcy5lKTtcbiAgICB9O1xuXG4gICAgQ2hlY2tlZE9ic2VydmVyUHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jaGVja0FjY2VzcygpO1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX29ic2VydmVyLm9uQ29tcGxldGVkKS5jYWxsKHRoaXMuX29ic2VydmVyKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gMjtcbiAgICAgIHJlcyA9PT0gZXJyb3JPYmogJiYgdGhyb3dlcihyZXMuZSk7XG4gICAgfTtcblxuICAgIENoZWNrZWRPYnNlcnZlclByb3RvdHlwZS5jaGVja0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1JlLWVudHJhbmN5IGRldGVjdGVkJyk7IH1cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMikgeyB0aHJvdyBuZXcgRXJyb3IoJ09ic2VydmVyIGNvbXBsZXRlZCcpOyB9XG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDApIHsgdGhpcy5fc3RhdGUgPSAxOyB9XG4gICAgfTtcblxuICAgIHJldHVybiBDaGVja2VkT2JzZXJ2ZXI7XG4gIH0oT2JzZXJ2ZXIpKTtcblxuICB2YXIgU2NoZWR1bGVkT2JzZXJ2ZXIgPSBSeC5pbnRlcm5hbHMuU2NoZWR1bGVkT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNjaGVkdWxlZE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gU2NoZWR1bGVkT2JzZXJ2ZXIoc2NoZWR1bGVyLCBvYnNlcnZlcikge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuaXNBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5oYXNGYXVsdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICB0aGlzLmRpc3Bvc2FibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVucXVldWVOZXh0KG9ic2VydmVyLCB4KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IG9ic2VydmVyLm9uTmV4dCh4KTsgfTsgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVFcnJvcihvYnNlcnZlciwgZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyBvYnNlcnZlci5vbkVycm9yKGUpOyB9OyB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNvbXBsZXRlZChvYnNlcnZlcikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyBvYnNlcnZlci5vbkNvbXBsZXRlZCgpOyB9OyB9XG5cbiAgICBTY2hlZHVsZWRPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZW5xdWV1ZU5leHQodGhpcy5vYnNlcnZlciwgeCkpO1xuICAgIH07XG5cbiAgICBTY2hlZHVsZWRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKGVucXVldWVFcnJvcih0aGlzLm9ic2VydmVyLCBlKSk7XG4gICAgfTtcblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goZW5xdWV1ZUNvbXBsZXRlZCh0aGlzLm9ic2VydmVyKSk7XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHZhciB3b3JrO1xuICAgICAgaWYgKHN0YXRlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd29yayA9IHN0YXRlLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5pc0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh3b3JrKSgpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgc3RhdGUucXVldWUgPSBbXTtcbiAgICAgICAgc3RhdGUuaGFzRmF1bHRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aHJvd2VyKHJlcy5lKTtcbiAgICAgIH1cbiAgICAgIHJlY3Vyc2Uoc3RhdGUpO1xuICAgIH1cblxuICAgIFNjaGVkdWxlZE9ic2VydmVyLnByb3RvdHlwZS5lbnN1cmVBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNPd25lciA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLmhhc0ZhdWx0ZWQgJiYgdGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzT3duZXIgPSAhdGhpcy5pc0FjcXVpcmVkO1xuICAgICAgICB0aGlzLmlzQWNxdWlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaXNPd25lciAmJlxuICAgICAgICB0aGlzLmRpc3Bvc2FibGUuc2V0RGlzcG9zYWJsZSh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZSh0aGlzLCBzY2hlZHVsZU1ldGhvZCkpO1xuICAgIH07XG5cbiAgICBTY2hlZHVsZWRPYnNlcnZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjaGVkdWxlZE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgT2JzZXJ2ZU9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9ic2VydmVPbk9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uT2JzZXJ2ZXIoc2NoZWR1bGVyLCBvYnNlcnZlciwgY2FuY2VsKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCBzY2hlZHVsZXIsIG9ic2VydmVyKTtcbiAgICAgIHRoaXMuX2NhbmNlbCA9IGNhbmNlbDtcbiAgICB9XG5cbiAgICBPYnNlcnZlT25PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgX19zdXBlcl9fLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5lbnN1cmVBY3RpdmUoKTtcbiAgICB9O1xuXG4gICAgT2JzZXJ2ZU9uT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF9fc3VwZXJfXy5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlKTtcbiAgICAgIHRoaXMuZW5zdXJlQWN0aXZlKCk7XG4gICAgfTtcblxuICAgIE9ic2VydmVPbk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmNvbXBsZXRlZC5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5lbnN1cmVBY3RpdmUoKTtcbiAgICB9O1xuXG4gICAgT2JzZXJ2ZU9uT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuX2NhbmNlbCAmJiB0aGlzLl9jYW5jZWwuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FuY2VsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9ic2VydmVPbk9ic2VydmVyO1xuICB9KShTY2hlZHVsZWRPYnNlcnZlcik7XG5cbiAgdmFyIG9ic2VydmFibGVQcm90bztcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHB1c2gtc3R5bGUgY29sbGVjdGlvbi5cbiAgICovXG4gIHZhciBPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBtYWtlU3Vic2NyaWJlKHNlbGYsIHN1YnNjcmliZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBvbGRPbkVycm9yID0gby5vbkVycm9yO1xuICAgICAgICBvLm9uRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlLCBzZWxmKTtcbiAgICAgICAgICBvbGRPbkVycm9yLmNhbGwobywgZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZS5jYWxsKHNlbGYsIG8pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKCkge1xuICAgICAgaWYgKFJ4LmNvbmZpZy5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB2YXIgb2xkU3Vic2NyaWJlID0gdGhpcy5fc3Vic2NyaWJlO1xuICAgICAgICB2YXIgZSA9IHRyeUNhdGNoKHRocm93ZXIpKG5ldyBFcnJvcigpKS5lO1xuICAgICAgICB0aGlzLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKCdcXG4nKSArIDEpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBtYWtlU3Vic2NyaWJlKHRoaXMsIG9sZFN1YnNjcmliZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JzZXJ2YWJsZVByb3RvID0gT2JzZXJ2YWJsZS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIE9ic2VydmFibGVcbiAgICAqIEBwYXJhbSB7QW55fSBBbiBvYmplY3QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgaXQgaXMgYW4gT2JzZXJ2YWJsZVxuICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYW4gT2JzZXJ2YWJsZSwgZWxzZSBmYWxzZS5cbiAgICAqL1xuICAgIE9ic2VydmFibGUuaXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvICYmIGlzRnVuY3Rpb24oby5zdWJzY3JpYmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgU3Vic2NyaWJlcyBhbiBvIHRvIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgICAqICBAcGFyYW0ge01peGVkfSBbb09yT25OZXh0XSBUaGUgb2JqZWN0IHRoYXQgaXMgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9yIGFuIGFjdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIEFjdGlvbiB0byBpbnZva2UgdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW29uQ29tcGxldGVkXSBBY3Rpb24gdG8gaW52b2tlIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogIEByZXR1cm5zIHtEaXBvc2FibGV9IEEgZGlzcG9zYWJsZSBoYW5kbGluZyB0aGUgc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zLlxuICAgICAqL1xuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmUgPSBvYnNlcnZhYmxlUHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChvT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHR5cGVvZiBvT3JPbk5leHQgPT09ICdvYmplY3QnID9cbiAgICAgICAgb09yT25OZXh0IDpcbiAgICAgICAgb2JzZXJ2ZXJDcmVhdGUob09yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBzZXF1ZW5jZSB3aXRoIGFuIG9wdGlvbmFsIFwidGhpc1wiIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uTmV4dCBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uTmV4dCA9IGZ1bmN0aW9uIChvbk5leHQsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUob2JzZXJ2ZXJDcmVhdGUodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24oeCkgeyBvbk5leHQuY2FsbCh0aGlzQXJnLCB4KTsgfSA6IG9uTmV4dCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGFuIGV4Y2VwdGlvbmFsIGNvbmRpdGlvbiBpbiB0aGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBcInRoaXNcIiBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gQSBkaXNwb3NhYmxlIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLnN1YnNjcmliZU9uRXJyb3IgPSBmdW5jdGlvbiAob25FcnJvciwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlckNyZWF0ZShudWxsLCB0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcgPyBmdW5jdGlvbihlKSB7IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlKTsgfSA6IG9uRXJyb3IpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgbmV4dCB2YWx1ZSBpbiB0aGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBcInRoaXNcIiBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHVwb24gZ3JhY2VmdWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBPYmplY3QgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Rpc3Bvc2FibGV9IEEgZGlzcG9zYWJsZSBoYW5kbGluZyB0aGUgc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zLlxuICAgICAqL1xuICAgIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmVPbkNvbXBsZXRlZCA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlZCwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlckNyZWF0ZShudWxsLCBudWxsLCB0eXBlb2YgdGhpc0FyZyAhPT0gJ3VuZGVmaW5lZCcgPyBmdW5jdGlvbigpIHsgb25Db21wbGV0ZWQuY2FsbCh0aGlzQXJnKTsgfSA6IG9uQ29tcGxldGVkKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBPYnNlcnZhYmxlO1xuICB9KSgpO1xuXG4gIHZhciBPYnNlcnZhYmxlQmFzZSA9IFJ4Lk9ic2VydmFibGVCYXNlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhPYnNlcnZhYmxlQmFzZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIGZpeFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIgJiYgaXNGdW5jdGlvbihzdWJzY3JpYmVyLmRpc3Bvc2UpID8gc3Vic2NyaWJlciA6XG4gICAgICAgIGlzRnVuY3Rpb24oc3Vic2NyaWJlcikgPyBkaXNwb3NhYmxlQ3JlYXRlKHN1YnNjcmliZXIpIDogZGlzcG9zYWJsZUVtcHR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERpc3Bvc2FibGUocywgc3RhdGUpIHtcbiAgICAgIHZhciBhZG8gPSBzdGF0ZVswXSwgc2VsZiA9IHN0YXRlWzFdO1xuICAgICAgdmFyIHN1YiA9IHRyeUNhdGNoKHNlbGYuc3Vic2NyaWJlQ29yZSkuY2FsbChzZWxmLCBhZG8pO1xuICAgICAgaWYgKHN1YiA9PT0gZXJyb3JPYmogJiYgIWFkby5mYWlsKGVycm9yT2JqLmUpKSB7IHRocm93ZXIoZXJyb3JPYmouZSk7IH1cbiAgICAgIGFkby5zZXREaXNwb3NhYmxlKGZpeFN1YnNjcmliZXIoc3ViKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZUJhc2UoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBPYnNlcnZhYmxlQmFzZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYWRvID0gbmV3IEF1dG9EZXRhY2hPYnNlcnZlcihvKSwgc3RhdGUgPSBbYWRvLCB0aGlzXTtcblxuICAgICAgaWYgKGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGVSZXF1aXJlZCgpKSB7XG4gICAgICAgIGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNldERpc3Bvc2FibGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RGlzcG9zYWJsZShudWxsLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRvO1xuICAgIH07XG5cbiAgICBPYnNlcnZhYmxlQmFzZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgcmV0dXJuIE9ic2VydmFibGVCYXNlO1xuICB9KE9ic2VydmFibGUpKTtcblxudmFyIEZsYXRNYXBPYnNlcnZhYmxlID0gUnguRmxhdE1hcE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG5cbiAgICBpbmhlcml0cyhGbGF0TWFwT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIEZsYXRNYXBPYnNlcnZhYmxlKHNvdXJjZSwgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihyZXN1bHRTZWxlY3RvcikgPyByZXN1bHRTZWxlY3RvciA6IG51bGw7XG4gICAgICB0aGlzLnNlbGVjdG9yID0gYmluZENhbGxiYWNrKGlzRnVuY3Rpb24oc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGVjdG9yOyB9LCB0aGlzQXJnLCAzKTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmxhdE1hcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8sIHRoaXMuc2VsZWN0b3IsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvYnNlcnZlciwgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCBzb3VyY2UpIHtcbiAgICAgIHRoaXMuaSA9IDA7XG4gICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMubyA9IG9ic2VydmVyO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLl93cmFwUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0LCB4LCBpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRTZWxlY3RvciA/XG4gICAgICAgIHJlc3VsdC5tYXAoZnVuY3Rpb24oeSwgaTIpIHsgcmV0dXJuIHRoaXMucmVzdWx0U2VsZWN0b3IoeCwgeSwgaSwgaTIpOyB9LCB0aGlzKSA6XG4gICAgICAgIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5pKys7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5zZWxlY3RvcikoeCwgaSwgdGhpcy5zb3VyY2UpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlc3VsdC5lKTsgfVxuXG4gICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgKGlzQXJyYXlMaWtlKHJlc3VsdCkgfHwgaXNJdGVyYWJsZShyZXN1bHQpKSAmJiAocmVzdWx0ID0gT2JzZXJ2YWJsZS5mcm9tKHJlc3VsdCkpO1xuICAgICAgdGhpcy5vLm9uTmV4dCh0aGlzLl93cmFwUmVzdWx0KHJlc3VsdCwgeCwgaSkpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGUpIHsgdGhpcy5vLm9uRXJyb3IoZSk7IH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbigpIHsgdGhpcy5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gRmxhdE1hcE9ic2VydmFibGU7XG5cbn0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRW51bWVyYWJsZSA9IFJ4LmludGVybmFscy5FbnVtZXJhYmxlID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gIGZ1bmN0aW9uIElzRGlzcG9zZWREaXNwb3NhYmxlKHN0YXRlKSB7XG4gICAgdGhpcy5fcyA9IHN0YXRlO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICB9XG5cbiAgSXNEaXNwb3NlZERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLl9zLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ29uY2F0RW51bWVyYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29uY2F0RW51bWVyYWJsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0RW51bWVyYWJsZU9ic2VydmFibGUoc291cmNlcykge1xuICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgIHZhciBjdXJyZW50SXRlbSA9IHRyeUNhdGNoKHN0YXRlLmUubmV4dCkuY2FsbChzdGF0ZS5lKTtcbiAgICAgIGlmIChjdXJyZW50SXRlbSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihjdXJyZW50SXRlbS5lKTsgfVxuICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHsgcmV0dXJuIHN0YXRlLm8ub25Db21wbGV0ZWQoKTsgfVxuXG4gICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudEl0ZW0udmFsdWU7XG4gICAgICBpc1Byb21pc2UoY3VycmVudFZhbHVlKSAmJiAoY3VycmVudFZhbHVlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICB2YXIgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUoY3VycmVudFZhbHVlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkpKTtcbiAgICB9XG5cbiAgICBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIG86IG8sXG4gICAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLFxuICAgICAgICBlOiB0aGlzLnNvdXJjZXNbJGl0ZXJhdG9yJF0oKVxuICAgICAgfTtcblxuICAgICAgdmFyIGNhbmNlbGFibGUgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCBzY2hlZHVsZU1ldGhvZCk7XG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIG5ldyBJc0Rpc3Bvc2VkRGlzcG9zYWJsZShzdGF0ZSldKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX3JlY3Vyc2UgPSByZWN1cnNlO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3N0YXRlLm8ub25OZXh0KHgpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fc3RhdGUuby5vbkVycm9yKGUpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVjdXJzZSh0aGlzLl9zdGF0ZSk7IH07XG5cbiAgICByZXR1cm4gQ29uY2F0RW51bWVyYWJsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBFbnVtZXJhYmxlLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZSh0aGlzKTtcbiAgfTtcblxuICB2YXIgQ2F0Y2hFcnJvck9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hFcnJvck9ic2VydmFibGUoc291cmNlcykge1xuICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKENhdGNoRXJyb3JPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIGlmIChzdGF0ZS5pc0Rpc3Bvc2VkKSB7IHJldHVybjsgfVxuICAgICAgdmFyIGN1cnJlbnRJdGVtID0gdHJ5Q2F0Y2goc3RhdGUuZS5uZXh0KS5jYWxsKHN0YXRlLmUpO1xuICAgICAgaWYgKGN1cnJlbnRJdGVtID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKGN1cnJlbnRJdGVtLmUpOyB9XG4gICAgICBpZiAoY3VycmVudEl0ZW0uZG9uZSkgeyByZXR1cm4gc3RhdGUubGFzdEVycm9yICE9PSBudWxsID8gc3RhdGUuby5vbkVycm9yKHN0YXRlLmxhc3RFcnJvcikgOiBzdGF0ZS5vLm9uQ29tcGxldGVkKCk7IH1cblxuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRJdGVtLnZhbHVlO1xuICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHN0YXRlLnN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIoc3RhdGUsIHJlY3Vyc2UpKSk7XG4gICAgfVxuXG4gICAgQ2F0Y2hFcnJvck9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBlOiB0aGlzLnNvdXJjZXNbJGl0ZXJhdG9yJF0oKSxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgICAgIGxhc3RFcnJvcjogbnVsbCxcbiAgICAgICAgbzogb1xuICAgICAgfTtcblxuICAgICAgdmFyIGNhbmNlbGFibGUgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCBzY2hlZHVsZU1ldGhvZCk7XG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIG5ldyBJc0Rpc3Bvc2VkRGlzcG9zYWJsZShzdGF0ZSldKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX3JlY3Vyc2UgPSByZWN1cnNlO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3N0YXRlLm8ub25OZXh0KHgpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fc3RhdGUubGFzdEVycm9yID0gZTsgdGhpcy5fcmVjdXJzZSh0aGlzLl9zdGF0ZSk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zdGF0ZS5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gQ2F0Y2hFcnJvck9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBFbnVtZXJhYmxlLnByb3RvdHlwZS5jYXRjaEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ2F0Y2hFcnJvck9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFJlcGVhdEVudW1lcmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlcGVhdEVudW1lcmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVwZWF0RW51bWVyYWJsZSh2LCBjKSB7XG4gICAgICB0aGlzLnYgPSB2O1xuICAgICAgdGhpcy5jID0gYyA9PSBudWxsID8gLTEgOiBjO1xuICAgIH1cblxuICAgIFJlcGVhdEVudW1lcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXBlYXRFbnVtZXJhdG9yKHRoaXMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBSZXBlYXRFbnVtZXJhdG9yKHApIHtcbiAgICAgIHRoaXMudiA9IHAudjtcbiAgICAgIHRoaXMubCA9IHAuYztcbiAgICB9XG5cbiAgICBSZXBlYXRFbnVtZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMubCA9PT0gMCkgeyByZXR1cm4gZG9uZUVudW1lcmF0b3I7IH1cbiAgICAgIGlmICh0aGlzLmwgPiAwKSB7IHRoaXMubC0tOyB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMudiB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0RW51bWVyYWJsZTtcbiAgfShFbnVtZXJhYmxlKSk7XG5cbiAgdmFyIGVudW1lcmFibGVSZXBlYXQgPSBFbnVtZXJhYmxlLnJlcGVhdCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwZWF0Q291bnQpIHtcbiAgICByZXR1cm4gbmV3IFJlcGVhdEVudW1lcmFibGUodmFsdWUsIHJlcGVhdENvdW50KTtcbiAgfTtcblxuICB2YXIgT2ZFbnVtZXJhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9mRW51bWVyYWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPZkVudW1lcmFibGUocywgZm4sIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMucyA9IHM7XG4gICAgICB0aGlzLmZuID0gZm4gPyBiaW5kQ2FsbGJhY2soZm4sIHRoaXNBcmcsIDMpIDogbnVsbDtcbiAgICB9XG4gICAgT2ZFbnVtZXJhYmxlLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgT2ZFbnVtZXJhdG9yKHRoaXMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBPZkVudW1lcmF0b3IocCkge1xuICAgICAgdGhpcy5pID0gLTE7XG4gICAgICB0aGlzLnMgPSBwLnM7XG4gICAgICB0aGlzLmwgPSB0aGlzLnMubGVuZ3RoO1xuICAgICAgdGhpcy5mbiA9IHAuZm47XG4gICAgfVxuXG4gICAgT2ZFbnVtZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gKyt0aGlzLmkgPCB0aGlzLmwgP1xuICAgICAgIHsgZG9uZTogZmFsc2UsIHZhbHVlOiAhdGhpcy5mbiA/IHRoaXMuc1t0aGlzLmldIDogdGhpcy5mbih0aGlzLnNbdGhpcy5pXSwgdGhpcy5pLCB0aGlzLnMpIH0gOlxuICAgICAgIGRvbmVFbnVtZXJhdG9yO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2ZFbnVtZXJhYmxlO1xuICB9KEVudW1lcmFibGUpKTtcblxuICB2YXIgZW51bWVyYWJsZU9mID0gRW51bWVyYWJsZS5vZiA9IGZ1bmN0aW9uIChzb3VyY2UsIHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG5ldyBPZkVudW1lcmFibGUoc291cmNlLCBzZWxlY3RvciwgdGhpc0FyZyk7XG4gIH07XG5cbnZhciBPYnNlcnZlT25PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgaW5oZXJpdHMoT2JzZXJ2ZU9uT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gT2JzZXJ2ZU9uT2JzZXJ2YWJsZShzb3VyY2UsIHMpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9zID0gcztcbiAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgfVxuXG4gIE9ic2VydmVPbk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE9ic2VydmVPbk9ic2VydmVyKHRoaXMuX3MsIG8pKTtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2ZU9uT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAgLyoqXG4gICAqICBXcmFwcyB0aGUgc291cmNlIHNlcXVlbmNlIGluIG9yZGVyIHRvIHJ1biBpdHMgb2JzZXJ2ZXIgY2FsbGJhY2tzIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKlxuICAgKiAgVGhpcyBvbmx5IGludm9rZXMgb2JzZXJ2ZXIgY2FsbGJhY2tzIG9uIGEgc2NoZWR1bGVyLiBJbiBjYXNlIHRoZSBzdWJzY3JpcHRpb24gYW5kL29yIHVuc3Vic2NyaXB0aW9uIGFjdGlvbnMgaGF2ZSBzaWRlLWVmZmVjdHNcbiAgICogIHRoYXQgcmVxdWlyZSB0byBiZSBydW4gb24gYSBzY2hlZHVsZXIsIHVzZSBzdWJzY3JpYmVPbi5cbiAgICpcbiAgICogIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIG5vdGlmeSBvYnNlcnZlcnMgb24uXG4gICAqICBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBzZXF1ZW5jZSB3aG9zZSBvYnNlcnZhdGlvbnMgaGFwcGVuIG9uIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm9ic2VydmVPbiA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmVPbk9ic2VydmFibGUodGhpcywgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU3Vic2NyaWJlT25PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTdWJzY3JpYmVPbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlT25PYnNlcnZhYmxlKHNvdXJjZSwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHNjaGVkdWxlciwgc3RhdGUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZVswXSwgZCA9IHN0YXRlWzFdLCBvID0gc3RhdGVbMl07XG4gICAgICBkLnNldERpc3Bvc2FibGUobmV3IFNjaGVkdWxlZERpc3Bvc2FibGUoc2NoZWR1bGVyLCBzb3VyY2Uuc3Vic2NyaWJlKG8pKSk7XG4gICAgfVxuXG4gICAgU3Vic2NyaWJlT25PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksIGQgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKG0pO1xuICAgICAgbS5zZXREaXNwb3NhYmxlKHRoaXMuX3Muc2NoZWR1bGUoW3RoaXMuc291cmNlLCBkLCBvXSwgc2NoZWR1bGVNZXRob2QpKTtcbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3Vic2NyaWJlT25PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgIC8qKlxuICAgKiAgV3JhcHMgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpbiBvcmRlciB0byBydW4gaXRzIHN1YnNjcmlwdGlvbiBhbmQgdW5zdWJzY3JpcHRpb24gbG9naWMgb24gdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIuIFRoaXMgb3BlcmF0aW9uIGlzIG5vdCBjb21tb25seSB1c2VkO1xuICAgKiAgc2VlIHRoZSByZW1hcmtzIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gc3Vic2NyaWJlT24gYW5kIG9ic2VydmVPbi5cblxuICAgKiAgVGhpcyBvbmx5IHBlcmZvcm1zIHRoZSBzaWRlLWVmZmVjdHMgb2Ygc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci4gSW4gb3JkZXIgdG8gaW52b2tlIG9ic2VydmVyXG4gICAqICBjYWxsYmFja3Mgb24gYSBzY2hlZHVsZXIsIHVzZSBvYnNlcnZlT24uXG5cbiAgICogIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHBlcmZvcm0gc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiBhY3Rpb25zIG9uLlxuICAgKiAgQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2hvc2Ugc3Vic2NyaXB0aW9ucyBhbmQgdW5zdWJzY3JpcHRpb25zIGhhcHBlbiBvbiB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlci5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zdWJzY3JpYmVPbiA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZU9uT2JzZXJ2YWJsZSh0aGlzLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBGcm9tUHJvbWlzZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRnJvbVByb21pc2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZyb21Qcm9taXNlT2JzZXJ2YWJsZShwLCBzKSB7XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVOZXh0KHMsIHN0YXRlKSB7XG4gICAgICB2YXIgbyA9IHN0YXRlWzBdLCBkYXRhID0gc3RhdGVbMV07XG4gICAgICBvLm9uTmV4dChkYXRhKTtcbiAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yKHMsIHN0YXRlKSB7XG4gICAgICB2YXIgbyA9IHN0YXRlWzBdLCBlcnIgPSBzdGF0ZVsxXTtcbiAgICAgIG8ub25FcnJvcihlcnIpO1xuICAgIH1cblxuICAgIEZyb21Qcm9taXNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSwgc2VsZiA9IHRoaXMsIHAgPSB0aGlzLl9wO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihwKSkge1xuICAgICAgICBwID0gdHJ5Q2F0Y2gocCkoKTtcbiAgICAgICAgaWYgKHAgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgby5vbkVycm9yKHAuZSk7XG4gICAgICAgICAgcmV0dXJuIHNhZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc2VsZi5fcy5zY2hlZHVsZShbbywgZGF0YV0sIHNjaGVkdWxlTmV4dCkpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc2VsZi5fcy5zY2hlZHVsZShbbywgZXJyXSwgc2NoZWR1bGVFcnJvcikpO1xuICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNhZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZyb21Qcm9taXNlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqIENvbnZlcnRzIGEgUHJvbWlzZSB0byBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlXG4gICogQHBhcmFtIHtQcm9taXNlfSBBbiBFUzYgQ29tcGxpYW50IHByb21pc2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2Ugd2hpY2ggd3JhcHMgdGhlIGV4aXN0aW5nIHByb21pc2Ugc3VjY2VzcyBhbmQgZmFpbHVyZS5cbiAgKi9cbiAgdmFyIG9ic2VydmFibGVGcm9tUHJvbWlzZSA9IE9ic2VydmFibGUuZnJvbVByb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSwgc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEZyb21Qcm9taXNlT2JzZXJ2YWJsZShwcm9taXNlLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qXG4gICAqIENvbnZlcnRzIGFuIGV4aXN0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gRVM2IENvbXBhdGlibGUgUHJvbWlzZVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcHJvbWlzZSA9IFJ4Lk9ic2VydmFibGUucmV0dXJuKDQyKS50b1Byb21pc2UoUlNWUC5Qcm9taXNlKTtcbiAgICpcbiAgICogLy8gV2l0aCBjb25maWdcbiAgICogUnguY29uZmlnLlByb21pc2UgPSBSU1ZQLlByb21pc2U7XG4gICAqIHZhciBwcm9taXNlID0gUnguT2JzZXJ2YWJsZS5yZXR1cm4oNDIpLnRvUHJvbWlzZSgpO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvbWlzZUN0b3JdIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcHJvbWlzZS4gSWYgbm90IHByb3ZpZGVkLCBpdCBsb29rcyBmb3IgaXQgaW4gUnguY29uZmlnLlByb21pc2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBFUzYgY29tcGF0aWJsZSBwcm9taXNlIHdpdGggdGhlIGxhc3QgdmFsdWUgZnJvbSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50b1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZUN0b3IpIHtcbiAgICBwcm9taXNlQ3RvciB8fCAocHJvbWlzZUN0b3IgPSBSeC5jb25maWcuUHJvbWlzZSk7XG4gICAgaWYgKCFwcm9taXNlQ3RvcikgeyB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoJ1Byb21pc2UgdHlwZSBub3QgcHJvdmlkZWQgbm9yIGluIFJ4LmNvbmZpZy5Qcm9taXNlJyk7IH1cbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IHByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIE5vIGNhbmNlbGxhdGlvbiBjYW4gYmUgZG9uZVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAodikge1xuICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICB9LCByZWplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgVG9BcnJheU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVG9BcnJheU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVG9BcnJheU9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRvQXJyYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuYSA9IFtdO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5hLnB1c2goeCk7IH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLm8ub25FcnJvcihlKTsgIH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLm8ub25OZXh0KHRoaXMuYSk7IHRoaXMuby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFRvQXJyYXlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBlbGVtZW50IHdpdGggYSBsaXN0IGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFRvQXJyYXlPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYSBzcGVjaWZpZWQgc3Vic2NyaWJlIG1ldGhvZCBpbXBsZW1lbnRhdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfSApO1xuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gUnguRGlzcG9zYWJsZS5lbXB0eTsgfSApO1xuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikgeyB9ICk7XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgc2VxdWVuY2UncyBzdWJzY3JpYmUgbWV0aG9kLCByZXR1cm5pbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgd3JhcHBlZCBpbiBhIERpc3Bvc2FibGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBTdWJzY3JpYmUgbWV0aG9kLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlLCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoc3Vic2NyaWJlLCBwYXJlbnQpO1xuICB9O1xuXG4gIHZhciBEZWZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZWZlcihmYWN0b3J5KSB7XG4gICAgICB0aGlzLl9mID0gZmFjdG9yeTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERlZmVyLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9mKSgpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG9ic2VydmFibGVUaHJvdyhyZXN1bHQuZSkuc3Vic2NyaWJlKG8pO31cbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShvKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlZmVyO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpbnZva2VzIHRoZSBzcGVjaWZpZWQgZmFjdG9yeSBmdW5jdGlvbiB3aGVuZXZlciBhIG5ldyBvYnNlcnZlciBzdWJzY3JpYmVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZGVmZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tQXJyYXkoWzEsMiwzXSk7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYnNlcnZhYmxlRmFjdG9yeSBPYnNlcnZhYmxlIGZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIG9ic2VydmVyIHRoYXQgc3Vic2NyaWJlcyB0byB0aGUgcmVzdWx0aW5nIHNlcXVlbmNlIG9yIFByb21pc2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIG9ic2VydmVycyB0cmlnZ2VyIGFuIGludm9jYXRpb24gb2YgdGhlIGdpdmVuIG9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlRGVmZXIgPSBPYnNlcnZhYmxlLmRlZmVyID0gZnVuY3Rpb24gKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBEZWZlcihvYnNlcnZhYmxlRmFjdG9yeSk7XG4gIH07XG5cbiAgdmFyIEVtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhFbXB0eU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBFbXB0eU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBzaW5rID0gbmV3IEVtcHR5U2luayhvYnNlcnZlciwgdGhpcy5zY2hlZHVsZXIpO1xuICAgICAgcmV0dXJuIHNpbmsucnVuKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEVtcHR5U2luayhvYnNlcnZlciwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUl0ZW0ocywgc3RhdGUpIHtcbiAgICAgIHN0YXRlLm9uQ29tcGxldGVkKCk7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgIH1cblxuICAgIEVtcHR5U2luay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlciA9PT0gaW1tZWRpYXRlU2NoZWR1bGVyID9cbiAgICAgICAgc2NoZWR1bGVJdGVtKG51bGwsIHN0YXRlKSA6XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzY2hlZHVsZUl0ZW0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gRW1wdHlPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIEVNUFRZX09CU0VSVkFCTEUgPSBuZXcgRW1wdHlPYnNlcnZhYmxlKGltbWVkaWF0ZVNjaGVkdWxlcik7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGVtcHR5IG9ic2VydmFibGUgc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IHRoZSBzaW5nbGUgT25Db21wbGV0ZWQgbWVzc2FnZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmVtcHR5KCk7XG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5lbXB0eShSeC5TY2hlZHVsZXIudGltZW91dCk7XG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdG8gc2VuZCB0aGUgdGVybWluYXRpb24gY2FsbCBvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBubyBlbGVtZW50cy5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlRW1wdHkgPSBPYnNlcnZhYmxlLmVtcHR5ID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcik7XG4gICAgcmV0dXJuIHNjaGVkdWxlciA9PT0gaW1tZWRpYXRlU2NoZWR1bGVyID8gRU1QVFlfT0JTRVJWQUJMRSA6IG5ldyBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgRnJvbU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRnJvbU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRnJvbU9ic2VydmFibGUoaXRlcmFibGUsIGZuLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVNZXRob2QobywgaXQsIGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZShpLCByZWN1cnNlKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdHJ5Q2F0Y2goaXQubmV4dCkuY2FsbChpdCk7XG4gICAgICAgIGlmIChuZXh0ID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKG5leHQuZSk7IH1cbiAgICAgICAgaWYgKG5leHQuZG9uZSkgeyByZXR1cm4gby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5leHQudmFsdWU7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2goZm4pKHJlc3VsdCwgaSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIG8ub25OZXh0KHJlc3VsdCk7XG4gICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBGcm9tT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzLl9pdGVyYWJsZSksXG4gICAgICAgICAgaXQgPSBnZXRJdGVyYWJsZShsaXN0KTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZSgwLCBjcmVhdGVTY2hlZHVsZU1ldGhvZChvLCBpdCwgdGhpcy5fZm4pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZyb21PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICBmdW5jdGlvbiBTdHJpbmdJdGVyYWJsZShzKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gIH1cblxuICBTdHJpbmdJdGVyYWJsZS5wcm90b3R5cGVbJGl0ZXJhdG9yJF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcih0aGlzLl9zKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTdHJpbmdJdGVyYXRvcihzKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fbCA9IHMubGVuZ3RoO1xuICAgIHRoaXMuX2kgPSAwO1xuICB9XG5cbiAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pIDwgdGhpcy5fbCA/IHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9zLmNoYXJBdCh0aGlzLl9pKyspIH0gOiBkb25lRW51bWVyYXRvcjtcbiAgfTtcblxuICBmdW5jdGlvbiBBcnJheUl0ZXJhYmxlKGEpIHtcbiAgICB0aGlzLl9hID0gYTtcbiAgfVxuXG4gIEFycmF5SXRlcmFibGUucHJvdG90eXBlWyRpdGVyYXRvciRdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcih0aGlzLl9hKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBcnJheUl0ZXJhdG9yKGEpIHtcbiAgICB0aGlzLl9hID0gYTtcbiAgICB0aGlzLl9sID0gdG9MZW5ndGgoYSk7XG4gICAgdGhpcy5faSA9IDA7XG4gIH1cblxuICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVskaXRlcmF0b3IkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pIDwgdGhpcy5fbCA/IHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9hW3RoaXMuX2krK10gfSA6IGRvbmVFbnVtZXJhdG9yO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG51bWJlcklzRmluaXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgcm9vdC5pc0Zpbml0ZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hbihuKSB7XG4gICAgcmV0dXJuIG4gIT09IG47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYWJsZShvKSB7XG4gICAgdmFyIGkgPSBvWyRpdGVyYXRvciRdLCBpdDtcbiAgICBpZiAoIWkgJiYgdHlwZW9mIG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpdCA9IG5ldyBTdHJpbmdJdGVyYWJsZShvKTtcbiAgICAgIHJldHVybiBpdFskaXRlcmF0b3IkXSgpO1xuICAgIH1cbiAgICBpZiAoIWkgJiYgby5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXQgPSBuZXcgQXJyYXlJdGVyYWJsZShvKTtcbiAgICAgIHJldHVybiBpdFskaXRlcmF0b3IkXSgpO1xuICAgIH1cbiAgICBpZiAoIWkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IGlzIG5vdCBpdGVyYWJsZScpOyB9XG4gICAgcmV0dXJuIG9bJGl0ZXJhdG9yJF0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ24odmFsdWUpIHtcbiAgICB2YXIgbnVtYmVyID0gK3ZhbHVlO1xuICAgIGlmIChudW1iZXIgPT09IDApIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgIGlmIChpc05hTihudW1iZXIpKSB7IHJldHVybiBudW1iZXI7IH1cbiAgICByZXR1cm4gbnVtYmVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvTGVuZ3RoKG8pIHtcbiAgICB2YXIgbGVuID0gK28ubGVuZ3RoO1xuICAgIGlmIChpc05hTihsZW4pKSB7IHJldHVybiAwOyB9XG4gICAgaWYgKGxlbiA9PT0gMCB8fCAhbnVtYmVySXNGaW5pdGUobGVuKSkgeyByZXR1cm4gbGVuOyB9XG4gICAgbGVuID0gc2lnbihsZW4pICogTWF0aC5mbG9vcihNYXRoLmFicyhsZW4pKTtcbiAgICBpZiAobGVuIDw9IDApIHsgcmV0dXJuIDA7IH1cbiAgICBpZiAobGVuID4gbWF4U2FmZUludGVnZXIpIHsgcmV0dXJuIG1heFNhZmVJbnRlZ2VyOyB9XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxuXG4gIC8qKlxuICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBmcm9tIGFuIGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0LlxuICAqIEBwYXJhbSB7QW55fSBhcnJheUxpa2UgQW4gYXJyYXktbGlrZSBvciBpdGVyYWJsZSBvYmplY3QgdG8gY29udmVydCB0byBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFttYXBGbl0gTWFwIGZ1bmN0aW9uIHRvIGNhbGwgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gICogQHBhcmFtIHtBbnl9IFt0aGlzQXJnXSBUaGUgY29udGV4dCB0byB1c2UgY2FsbGluZyB0aGUgbWFwRm4gaWYgcHJvdmlkZWQuXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIE9wdGlvbmFsIHNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmcuICBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5jdXJyZW50VGhyZWFkLlxuICAqL1xuICB2YXIgb2JzZXJ2YWJsZUZyb20gPSBPYnNlcnZhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG1hcEZuLCB0aGlzQXJnLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoaXRlcmFibGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYWJsZSBjYW5ub3QgYmUgbnVsbC4nKVxuICAgIH1cbiAgICBpZiAobWFwRm4gJiYgIWlzRnVuY3Rpb24obWFwRm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcEZuIHdoZW4gcHJvdmlkZWQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGlmIChtYXBGbikge1xuICAgICAgdmFyIG1hcHBlciA9IGJpbmRDYWxsYmFjayhtYXBGbiwgdGhpc0FyZywgMik7XG4gICAgfVxuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgRnJvbU9ic2VydmFibGUoaXRlcmFibGUsIG1hcHBlciwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHZhciBGcm9tQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZyb21BcnJheU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRnJvbUFycmF5T2JzZXJ2YWJsZShhcmdzLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2QobywgYXJncykge1xuICAgICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUgKGksIHJlY3Vyc2UpIHtcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICBvLm9uTmV4dChhcmdzW2ldKTtcbiAgICAgICAgICByZWN1cnNlKGkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgRnJvbUFycmF5T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKDAsIHNjaGVkdWxlTWV0aG9kKG8sIHRoaXMuX2FyZ3MpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZyb21BcnJheU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiAgQ29udmVydHMgYW4gYXJyYXkgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSwgdXNpbmcgYW4gb3B0aW9uYWwgc2NoZWR1bGVyIHRvIGVudW1lcmF0ZSB0aGUgYXJyYXkuXG4gICogQGRlcHJlY2F0ZWQgdXNlIE9ic2VydmFibGUuZnJvbSBvciBPYnNlcnZhYmxlLm9mXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGVudW1lcmF0aW9uIG9mIHRoZSBpbnB1dCBzZXF1ZW5jZSBvbi5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHB1bGxlZCBmcm9tIHRoZSBnaXZlbiBlbnVtZXJhYmxlIHNlcXVlbmNlLlxuICAqL1xuICB2YXIgb2JzZXJ2YWJsZUZyb21BcnJheSA9IE9ic2VydmFibGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEZyb21BcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcilcbiAgfTtcblxuICB2YXIgR2VuZXJhdGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhHZW5lcmF0ZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gR2VuZXJhdGVPYnNlcnZhYmxlKHN0YXRlLCBjbmRGbiwgaXRyRm4sIHJlc0ZuLCBzKSB7XG4gICAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX2NuZEZuID0gY25kRm47XG4gICAgICB0aGlzLl9pdHJGbiA9IGl0ckZuO1xuICAgICAgdGhpcy5fcmVzRm4gPSByZXNGbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIGlmIChzdGF0ZS5maXJzdCkge1xuICAgICAgICBzdGF0ZS5maXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubmV3U3RhdGUgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9pdHJGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUubmV3U3RhdGUgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3Ioc3RhdGUubmV3U3RhdGUuZSk7IH1cbiAgICAgIH1cbiAgICAgIHZhciBoYXNSZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9jbmRGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgaWYgKGhhc1Jlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihoYXNSZXN1bHQuZSk7IH1cbiAgICAgIGlmIChoYXNSZXN1bHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX3Jlc0ZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICAgIHN0YXRlLm8ub25OZXh0KHJlc3VsdCk7XG4gICAgICAgIHJlY3Vyc2Uoc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlbmVyYXRlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIG86IG8sXG4gICAgICAgIHNlbGY6IHRoaXMsXG4gICAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgICBuZXdTdGF0ZTogdGhpcy5faW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX3Muc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlUmVjdXJzaXZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdlbmVyYXRlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgcnVubmluZyBhIHN0YXRlLWRyaXZlbiBsb29wIHByb2R1Y2luZyB0aGUgc2VxdWVuY2UncyBlbGVtZW50cywgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgb2JzZXJ2ZXIgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5nZW5lcmF0ZSgwLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA8IDEwOyB9LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICogIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmdlbmVyYXRlKDAsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IDwgMTA7IH0sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICsgMTsgfSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sIFJ4LlNjaGVkdWxlci50aW1lb3V0KTtcbiAgICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFN0YXRlIEluaXRpYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZSBJdGVyYXRpb24gc3RlcCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gZm9yIHJlc3VsdHMgcHJvZHVjZWQgaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3AuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmN1cnJlbnRUaHJlYWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGN1cnJlbnRUaHJlYWRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgTmV2ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE5ldmVyT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBOZXZlck9ic2VydmFibGUoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBOZXZlck9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfTtcblxuICAgIHJldHVybiBOZXZlck9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTkVWRVJfT0JTRVJWQUJMRSA9IG5ldyBOZXZlck9ic2VydmFibGUoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5vbi10ZXJtaW5hdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZW5vdGUgYW4gaW5maW5pdGUgZHVyYXRpb24gKGUuZy4gd2hlbiB1c2luZyByZWFjdGl2ZSBqb2lucykuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIG9ic2VydmVycyB3aWxsIG5ldmVyIGdldCBjYWxsZWQuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZU5ldmVyID0gT2JzZXJ2YWJsZS5uZXZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTkVWRVJfT0JTRVJWQUJMRTtcbiAgfTtcblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlT2YgKHNjaGVkdWxlciwgYXJyYXkpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEZyb21BcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gIH1cblxuICAvKipcbiAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlIGluc3RhbmNlIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mIG51bWJlciBvciB0eXBlIG9mIHRoZSBhcmd1bWVudHMuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSBwdWxsZWQgZnJvbSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAqL1xuICBPYnNlcnZhYmxlLm9mID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gbmV3IEZyb21BcnJheU9ic2VydmFibGUoYXJncywgY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gIH07XG5cbiAgLyoqXG4gICogIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSBpbnN0YW5jZSB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgcmVnYXJkbGVzcyBvZiBudW1iZXIgb3IgdHlwZSBvZiB0aGUgYXJndW1lbnRzLlxuICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgQSBzY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nIHRoZSBhcmd1bWVudHMuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSBwdWxsZWQgZnJvbSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAqL1xuICBPYnNlcnZhYmxlLm9mV2l0aFNjaGVkdWxlciA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICByZXR1cm4gbmV3IEZyb21BcnJheU9ic2VydmFibGUoYXJncywgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgUGFpcnNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFBhaXJzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBQYWlyc09ic2VydmFibGUobywgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2tleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKG8sIG9iaiwga2V5cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgICBpZiAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgby5vbk5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICAgICAgICByZWN1cnNlKGkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgUGFpcnNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoMCwgc2NoZWR1bGVNZXRob2QobywgdGhpcy5fbywgdGhpcy5fa2V5cykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGFpcnNPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMgZnJvbSB0aGUgb2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5wYWlycyA9IGZ1bmN0aW9uIChvYmosIHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlciB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBQYWlyc09ic2VydmFibGUob2JqLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gICAgdmFyIFJhbmdlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhSYW5nZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLnJhbmdlQ291bnQgPSBjb3VudDtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcFJlY3Vyc2l2ZShzdGFydCwgY291bnQsIG8pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wIChpLCByZWN1cnNlKSB7XG4gICAgICAgIGlmIChpIDwgY291bnQpIHtcbiAgICAgICAgICBvLm9uTmV4dChzdGFydCArIGkpO1xuICAgICAgICAgIHJlY3Vyc2UoaSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKFxuICAgICAgICAwLFxuICAgICAgICBsb29wUmVjdXJzaXZlKHRoaXMuc3RhcnQsIHRoaXMucmFuZ2VDb3VudCwgbylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBSYW5nZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgaW50ZWdyYWwgbnVtYmVycyB3aXRoaW4gYSBzcGVjaWZpZWQgcmFuZ2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludGVnZXIgaW4gdGhlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHNlcXVlbnRpYWwgaW50ZWdlcnMgdG8gZ2VuZXJhdGUuXG4gICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIuY3VycmVudFRocmVhZC5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIGEgcmFuZ2Ugb2Ygc2VxdWVudGlhbCBpbnRlZ3JhbCBudW1iZXJzLlxuICAqL1xuICBPYnNlcnZhYmxlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gY3VycmVudFRocmVhZFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBSYW5nZU9ic2VydmFibGUoc3RhcnQsIGNvdW50LCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBSZXBlYXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFJlcGVhdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gUmVwZWF0T2JzZXJ2YWJsZSh2YWx1ZSwgcmVwZWF0Q291bnQsIHNjaGVkdWxlcikge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5yZXBlYXRDb3VudCA9IHJlcGVhdENvdW50ID09IG51bGwgPyAtMSA6IHJlcGVhdENvdW50O1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBSZXBlYXRPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgc2luayA9IG5ldyBSZXBlYXRTaW5rKG9ic2VydmVyLCB0aGlzKTtcbiAgICAgIHJldHVybiBzaW5rLnJ1bigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIGZ1bmN0aW9uIFJlcGVhdFNpbmsob2JzZXJ2ZXIsIHBhcmVudCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuXG4gIFJlcGVhdFNpbmsucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLCB2YWx1ZSA9IHRoaXMucGFyZW50LnZhbHVlO1xuICAgIGZ1bmN0aW9uIGxvb3BSZWN1cnNpdmUoaSwgcmVjdXJzZSkge1xuICAgICAgaWYgKGkgPT09IC0xIHx8IGkgPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICAgIGkgPiAwICYmIGktLTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSAwKSB7IHJldHVybiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICByZWN1cnNlKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcmVudC5zY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUodGhpcy5wYXJlbnQucmVwZWF0Q291bnQsIGxvb3BSZWN1cnNpdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgRWxlbWVudCB0byByZXBlYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRDb3VudCBbT3B0aW9uYV0gTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCwgcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgcHJvZHVjZXIgbG9vcCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCByZXBlYXRzIHRoZSBnaXZlbiBlbGVtZW50IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS5yZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBjdXJyZW50VGhyZWFkU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFJlcGVhdE9ic2VydmFibGUodmFsdWUsIHJlcGVhdENvdW50LCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBKdXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhKdXN0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBKdXN0T2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSnVzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN0YXRlID0gW3RoaXMuX3ZhbHVlLCBvXTtcbiAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZXIgPT09IGltbWVkaWF0ZVNjaGVkdWxlciA/XG4gICAgICAgIHNjaGVkdWxlSXRlbShudWxsLCBzdGF0ZSkgOlxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGUoc3RhdGUsIHNjaGVkdWxlSXRlbSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSXRlbShzLCBzdGF0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGVbMF0sIG9ic2VydmVyID0gc3RhdGVbMV07XG4gICAgICBvYnNlcnZlci5vbk5leHQodmFsdWUpO1xuICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEp1c3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBhIHNpbmdsZSBlbGVtZW50LCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogIFRoZXJlIGlzIGFuIGFsaWFzIGNhbGxlZCAnanVzdCcgb3IgYnJvd3NlcnMgPElFOS5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgU2luZ2xlIGVsZW1lbnQgaW4gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIFNjaGVkdWxlciB0byBzZW5kIHRoZSBzaW5nbGUgZWxlbWVudCBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gU2NoZWR1bGVyLmltbWVkaWF0ZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgc2luZ2xlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVSZXR1cm4gPSBPYnNlcnZhYmxlWydyZXR1cm4nXSA9IE9ic2VydmFibGUuanVzdCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gaW1tZWRpYXRlU2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEp1c3RPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBUaHJvd09ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGhyb3dPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRocm93T2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGhyb3dPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdGF0ZSA9IFt0aGlzLl9lcnJvciwgb107XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVyID09PSBpbW1lZGlhdGVTY2hlZHVsZXIgP1xuICAgICAgICBzY2hlZHVsZUl0ZW0obnVsbCwgc3RhdGUpIDpcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzY2hlZHVsZUl0ZW0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUl0ZW0ocywgc3RhdGUpIHtcbiAgICAgIHZhciBlID0gc3RhdGVbMF0sIG8gPSBzdGF0ZVsxXTtcbiAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRocm93T2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgdGVybWluYXRlcyB3aXRoIGFuIGV4Y2VwdGlvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXIgdG8gc2VuZCBvdXQgdGhlIHNpbmdsZSBvbkVycm9yIG1lc3NhZ2UuXG4gICAqICBUaGVyZSBpcyBhbiBhbGlhcyB0byB0aGlzIG1ldGhvZCBjYWxsZWQgJ3Rocm93RXJyb3InIGZvciBicm93c2VycyA8SUU5LlxuICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBBbiBvYmplY3QgdXNlZCBmb3IgdGhlIHNlcXVlbmNlJ3MgdGVybWluYXRpb24uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHNlbmQgdGhlIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIGNhbGwgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFNjaGVkdWxlci5pbW1lZGlhdGUuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseSB3aXRoIHRoZSBzcGVjaWZpZWQgZXhjZXB0aW9uIG9iamVjdC5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlVGhyb3cgPSBPYnNlcnZhYmxlWyd0aHJvdyddID0gZnVuY3Rpb24gKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgVGhyb3dPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBVc2luZ09ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFVzaW5nT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBVc2luZ09ic2VydmFibGUocmVzRm4sIG9ic0ZuKSB7XG4gICAgICB0aGlzLl9yZXNGbiA9IHJlc0ZuO1xuICAgICAgdGhpcy5fb2JzRm4gPSBvYnNGbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFVzaW5nT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZGlzcG9zYWJsZSA9IGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIHZhciByZXNvdXJjZSA9IHRyeUNhdGNoKHRoaXMuX3Jlc0ZuKSgpO1xuICAgICAgaWYgKHJlc291cmNlID09PSBlcnJvck9iaikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUob2JzZXJ2YWJsZVRocm93KHJlc291cmNlLmUpLnN1YnNjcmliZShvKSwgZGlzcG9zYWJsZSk7XG4gICAgICB9XG4gICAgICByZXNvdXJjZSAmJiAoZGlzcG9zYWJsZSA9IHJlc291cmNlKTtcbiAgICAgIHZhciBzb3VyY2UgPSB0cnlDYXRjaCh0aGlzLl9vYnNGbikocmVzb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKG9ic2VydmFibGVUaHJvdyhzb3VyY2UuZSkuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG8pLCBkaXNwb3NhYmxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFVzaW5nT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBkZXBlbmRzIG9uIGEgcmVzb3VyY2Ugb2JqZWN0LCB3aG9zZSBsaWZldGltZSBpcyB0aWVkIHRvIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZSdzIGxpZmV0aW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvdXJjZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiB0byBvYnRhaW4gYSByZXNvdXJjZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ic2VydmFibGVGYWN0b3J5IEZhY3RvcnkgZnVuY3Rpb24gdG8gb2J0YWluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBkZXBlbmRzIG9uIHRoZSBvYnRhaW5lZCByZXNvdXJjZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgbGlmZXRpbWUgY29udHJvbHMgdGhlIGxpZmV0aW1lIG9mIHRoZSBkZXBlbmRlbnQgcmVzb3VyY2Ugb2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2YWJsZS51c2luZyA9IGZ1bmN0aW9uIChyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBVc2luZ09ic2VydmFibGUocmVzb3VyY2VGYWN0b3J5LCBvYnNlcnZhYmxlRmFjdG9yeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2Ugb3IgUHJvbWlzZSB0aGF0IHJlYWN0cyBmaXJzdC5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSByaWdodFNvdXJjZSBTZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzdXJmYWNlcyBlaXRoZXIgb2YgdGhlIGdpdmVuIHNlcXVlbmNlcywgd2hpY2hldmVyIHJlYWN0ZWQgZmlyc3QuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYW1iID0gZnVuY3Rpb24gKHJpZ2h0U291cmNlKSB7XG4gICAgdmFyIGxlZnRTb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBjaG9pY2UsXG4gICAgICAgIGxlZnRDaG9pY2UgPSAnTCcsIHJpZ2h0Q2hvaWNlID0gJ1InLFxuICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG5cbiAgICAgIGlzUHJvbWlzZShyaWdodFNvdXJjZSkgJiYgKHJpZ2h0U291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJpZ2h0U291cmNlKSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNob2ljZUwoKSB7XG4gICAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgICAgY2hvaWNlID0gbGVmdENob2ljZTtcbiAgICAgICAgICByaWdodFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hvaWNlUigpIHtcbiAgICAgICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgICAgICBjaG9pY2UgPSByaWdodENob2ljZTtcbiAgICAgICAgICBsZWZ0U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdFN1YnNjcmliZSA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25OZXh0KGxlZnQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNob2ljZUwoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IGxlZnRDaG9pY2UgJiYgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHZhciByaWdodFN1YnNjcmliZSA9IG9ic2VydmVyQ3JlYXRlKFxuICAgICAgICBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICBjaG9pY2VSKCk7XG4gICAgICAgICAgY2hvaWNlID09PSByaWdodENob2ljZSAmJiBvYnNlcnZlci5vbk5leHQocmlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNob2ljZVIoKTtcbiAgICAgICAgICBjaG9pY2UgPT09IHJpZ2h0Q2hvaWNlICYmIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjaG9pY2VSKCk7XG4gICAgICAgICAgY2hvaWNlID09PSByaWdodENob2ljZSAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBsZWZ0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUobGVmdFNvdXJjZS5zdWJzY3JpYmUobGVmdFN1YnNjcmliZSkpO1xuICAgICAgcmlnaHRTdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShyaWdodFNvdXJjZS5zdWJzY3JpYmUocmlnaHRTdWJzY3JpYmUpKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKGxlZnRTdWJzY3JpcHRpb24sIHJpZ2h0U3Vic2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBhbWIocCwgYykgeyByZXR1cm4gcC5hbWIoYyk7IH1cblxuICAvKipcbiAgICogUHJvcGFnYXRlcyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgcmVhY3RzIGZpcnN0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IHN1cmZhY2VzIGFueSBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2VzLCB3aGljaGV2ZXIgcmVhY3RlZCBmaXJzdC5cbiAgICovXG4gIE9ic2VydmFibGUuYW1iID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBvYnNlcnZhYmxlTmV2ZXIoKSwgaXRlbXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgaXRlbXMgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaXRlbXMgPSBuZXcgQXJyYXkoaXRlbXMpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGl0ZW1zW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYWNjID0gYW1iKGFjYywgaXRlbXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIHZhciBDYXRjaE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENhdGNoT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBDYXRjaE9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkMSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpLCBzdWJzY3JpcHRpb24gPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZDEpO1xuICAgICAgZDEuc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IENhdGNoT2JzZXJ2ZXIobywgc3Vic2NyaXB0aW9uLCB0aGlzLl9mbikpKTtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgQ2F0Y2hPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDYXRjaE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENhdGNoT2JzZXJ2ZXIobywgcywgZm4pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ2F0Y2hPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX28ub25OZXh0KHgpOyB9O1xuICAgIENhdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcbiAgICBDYXRjaE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZm4pKGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXN1bHQuZSk7IH1cbiAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG5cbiAgICAgIHZhciBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9zLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUocmVzdWx0LnN1YnNjcmliZSh0aGlzLl9vKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYXRjaE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGhhbmRsZXJPclNlY29uZCBFeGNlcHRpb24gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBnaXZlbiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UsIG9yIGEgc2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgZmlyc3Qgc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGZpcnN0IHNlcXVlbmNlJ3MgZWxlbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50cyBvZiB0aGUgaGFuZGxlciBzZXF1ZW5jZSBpbiBjYXNlIGFuIGV4Y2VwdGlvbiBvY2N1cnJlZC5cbiAgICovXG4gIG9ic2VydmFibGVQcm90b1snY2F0Y2gnXSA9IGZ1bmN0aW9uIChoYW5kbGVyT3JTZWNvbmQpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihoYW5kbGVyT3JTZWNvbmQpID8gbmV3IENhdGNoT2JzZXJ2YWJsZSh0aGlzLCBoYW5kbGVyT3JTZWNvbmQpIDogb2JzZXJ2YWJsZUNhdGNoKFt0aGlzLCBoYW5kbGVyT3JTZWNvbmRdKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udGludWVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0ZXJtaW5hdGVkIGJ5IGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBuZXh0IG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIHVzZSBhcyB0aGUgbmV4dCBzZXF1ZW5jZSBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgZWxlbWVudHMgZnJvbSBjb25zZWN1dGl2ZSBzb3VyY2Ugc2VxdWVuY2VzIHVudGlsIGEgc291cmNlIHNlcXVlbmNlIHRlcm1pbmF0ZXMgc3VjY2Vzc2Z1bGx5LlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVDYXRjaCA9IE9ic2VydmFibGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGl0ZW1zID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGl0ZW1zID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgaXRlbXNbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICB9XG4gICAgcmV0dXJuIGVudW1lcmFibGVPZihpdGVtcykuY2F0Y2hFcnJvcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbnkgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIFByb21pc2VzIHByb2R1Y2VzIGFuIGVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGluIHRoZSBmb3JtIG9mIGFuIGFyZ3VtZW50IGxpc3Qgb2Ygb2JzZXJ2YWJsZXMgb3IgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDEgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qob2JzMSwgb2JzMiwgb2JzMywgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XG4gICAqIDIgLSBvYnMgPSBvYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoW29iczEsIG9iczIsIG9iczNdLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb21iaW5lTGF0ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgYXJnc1swXS51bnNoaWZ0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlKHBhcmFtcywgY2IpIHtcbiAgICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICAgIHRoaXMuX2NiID0gY2I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5fcGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgaGFzVmFsdWU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgIGhhc1ZhbHVlQWxsOiBmYWxzZSxcbiAgICAgICAgaXNEb25lOiBhcnJheUluaXRpYWxpemUobGVuLCBmYWxzZUZhY3RvcnkpLFxuICAgICAgICB2YWx1ZXM6IG5ldyBBcnJheShsZW4pXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9wYXJhbXNbaV0sIHNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zW2ldID0gc2FkO1xuICAgICAgICBpc1Byb21pc2Uoc291cmNlKSAmJiAoc291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHNvdXJjZSkpO1xuICAgICAgICBzYWQuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIob2JzZXJ2ZXIsIGksIHRoaXMuX2NiLCBzdGF0ZSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIENvbWJpbmVMYXRlc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29tYmluZUxhdGVzdE9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIENvbWJpbmVMYXRlc3RPYnNlcnZlcihvLCBpLCBjYiwgc3RhdGUpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5faSA9IGk7XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9PSBpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fc3RhdGUudmFsdWVzW3RoaXMuX2ldID0geDtcbiAgICAgIHRoaXMuX3N0YXRlLmhhc1ZhbHVlW3RoaXMuX2ldID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZS5oYXNWYWx1ZUFsbCB8fCAodGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwgPSB0aGlzLl9zdGF0ZS5oYXNWYWx1ZS5ldmVyeShpZGVudGl0eSkpKSB7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9jYikuYXBwbHkobnVsbCwgdGhpcy5fc3RhdGUudmFsdWVzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUuaXNEb25lLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgQ29tYmluZUxhdGVzdE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0RvbmVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhdGUuaXNEb25lLmV2ZXJ5KGlkZW50aXR5KSAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFueSBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgb3IgUHJvbWlzZXMgcHJvZHVjZXMgYW4gZWxlbWVudC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogMSAtIG9icyA9IFJ4Lk9ic2VydmFibGUuY29tYmluZUxhdGVzdChvYnMxLCBvYnMyLCBvYnMzLCBmdW5jdGlvbiAobzEsIG8yLCBvMykgeyByZXR1cm4gbzEgKyBvMiArIG8zOyB9KTtcbiAgKiAyIC0gb2JzID0gUnguT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KFtvYnMxLCBvYnMyLCBvYnMzXSwgZnVuY3Rpb24gKG8xLCBvMiwgbzMpIHsgcmV0dXJuIG8xICsgbzIgKyBvMzsgfSk7XG4gICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgc291cmNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAgKi9cbiAgdmFyIGNvbWJpbmVMYXRlc3QgPSBPYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG4gICAgcmV0dXJuIG5ldyBDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzLiAgVGhpcyB0YWtlcyBpbiBlaXRoZXIgYW4gYXJyYXkgb3IgdmFyaWFibGUgYXJndW1lbnRzIHRvIGNvbmNhdGVuYXRlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdpdmVuIHNlcXVlbmNlLCBpbiBzZXF1ZW50aWFsIG9yZGVyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IodmFyIGFyZ3MgPSBbXSwgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZUNvbmNhdC5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgQ29uY2F0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQ29uY2F0T2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0T2JzZXJ2ZXIocywgZm4pIHtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIENvbmNhdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fcy5vLm9uTmV4dCh4KTsgfTtcbiAgICBDb25jYXRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm8ub25FcnJvcihlKTsgfTtcbiAgICBDb25jYXRPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zLmkrKzsgdGhpcy5fZm4odGhpcy5fcyk7IH07XG5cbiAgICByZXR1cm4gQ29uY2F0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBDb25jYXRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKENvbmNhdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gQ29uY2F0T2JzZXJ2YWJsZShzb3VyY2VzKSB7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlIChzdGF0ZSwgcmVjdXJzZSkge1xuICAgICAgaWYgKHN0YXRlLmRpc3Bvc2FibGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgIGlmIChzdGF0ZS5pID09PSBzdGF0ZS5zb3VyY2VzLmxlbmd0aCkgeyByZXR1cm4gc3RhdGUuby5vbkNvbXBsZXRlZCgpOyB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb21pc2VcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBzdGF0ZS5zb3VyY2VzW3N0YXRlLmldO1xuICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHN0YXRlLnN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgZC5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUobmV3IENvbmNhdE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSkpO1xuICAgIH1cblxuICAgIENvbmNhdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBkaXNwb3NhYmxlID0gZGlzcG9zYWJsZUNyZWF0ZShub29wKTtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbzogbyxcbiAgICAgICAgaTogMCxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgICAgIGRpc3Bvc2FibGU6IGRpc3Bvc2FibGUsXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXNcbiAgICAgIH07XG5cbiAgICAgIHZhciBjYW5jZWxhYmxlID0gaW1tZWRpYXRlU2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCBzY2hlZHVsZVJlY3Vyc2l2ZSk7XG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtzdWJzY3JpcHRpb24sIGRpc3Bvc2FibGUsIGNhbmNlbGFibGVdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbmNhdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFsbCB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBBcmd1bWVudHN9IGFyZ3MgQXJndW1lbnRzIG9yIGFuIGFycmF5IHRvIGNvbmNhdCB0byB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgb2YgZWFjaCBnaXZlbiBzZXF1ZW5jZSwgaW4gc2VxdWVudGlhbCBvcmRlci5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlQ29uY2F0ID0gT2JzZXJ2YWJsZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29uY2F0T2JzZXJ2YWJsZShhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggb2JzZXJ2ZWQgaW5uZXIgc2VxdWVuY2UsIGluIHNlcXVlbnRpYWwgb3JkZXIuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uY29uY2F0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlKDEpO1xuICB9O1xuXG4gIHZhciBNZXJnZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1lcmdlT2JzZXJ2YWJsZShzb3VyY2UsIG1heENvbmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5tYXhDb25jdXJyZW50ID0gbWF4Q29uY3VycmVudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIE1lcmdlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZyA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gICAgICBnLmFkZCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHRoaXMubWF4Q29uY3VycmVudCwgZykpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VPYnNlcnZhYmxlO1xuXG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTWVyZ2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VPYnNlcnZlcihvLCBtYXgsIGcpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgIHRoaXMuZyA9IGc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucSA9IFtdO1xuICAgICAgdGhpcy5hY3RpdmVDb3VudCA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhNZXJnZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUuaGFuZGxlU3Vic2NyaWJlID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICB2YXIgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLmcuYWRkKHNhZCk7XG4gICAgICBpc1Byb21pc2UoeHMpICYmICh4cyA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh4cykpO1xuICAgICAgc2FkLnNldERpc3Bvc2FibGUoeHMuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKHRoaXMsIHNhZCkpKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xuICAgICAgaWYodGhpcy5hY3RpdmVDb3VudCA8IHRoaXMubWF4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ291bnQrKztcbiAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpYmUoaW5uZXJTb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xLnB1c2goaW5uZXJTb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLm8ub25FcnJvcihlKTsgfTtcbiAgICBNZXJnZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZG9uZSA9IHRydWU7IHRoaXMuYWN0aXZlQ291bnQgPT09IDAgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICBmdW5jdGlvbiBJbm5lck9ic2VydmVyKHBhcmVudCwgc2FkKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuc2FkID0gc2FkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoSW5uZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLnBhcmVudC5vLm9uTmV4dCh4KTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMucGFyZW50Lm8ub25FcnJvcihlKTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBhcmVudC5nLnJlbW92ZSh0aGlzLnNhZCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQucS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmhhbmRsZVN1YnNjcmliZSh0aGlzLnBhcmVudC5xLnNoaWZ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWN0aXZlQ291bnQtLTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZG9uZSAmJiB0aGlzLnBhcmVudC5hY3RpdmVDb3VudCA9PT0gMCAmJiB0aGlzLnBhcmVudC5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNZXJnZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgKiBNZXJnZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UsIGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBzdWJzY3JpcHRpb25zIHRvIGlubmVyIHNlcXVlbmNlcy5cbiAgKiBPciBtZXJnZXMgdHdvIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcGFyYW0ge01peGVkfSBbbWF4Q29uY3VycmVudE9yT3RoZXJdIE1heGltdW0gbnVtYmVyIG9mIGlubmVyIG9ic2VydmFibGUgc2VxdWVuY2VzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5IG9yIHRoZSBzZWNvbmQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBtZXJnZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBzZXF1ZW5jZXMuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tZXJnZSA9IGZ1bmN0aW9uIChtYXhDb25jdXJyZW50T3JPdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgbWF4Q29uY3VycmVudE9yT3RoZXIgIT09ICdudW1iZXInID9cbiAgICAgIG9ic2VydmFibGVNZXJnZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcikgOlxuICAgICAgbmV3IE1lcmdlT2JzZXJ2YWJsZSh0aGlzLCBtYXhDb25jdXJyZW50T3JPdGhlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBhbGwgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gYSBzaW5nbGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogVGhlIHNjaGVkdWxlciBpcyBvcHRpb25hbCBhbmQgaWYgbm90IHNwZWNpZmllZCwgdGhlIGltbWVkaWF0ZSBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgbWVyZ2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMuXG4gICAqL1xuICB2YXIgb2JzZXJ2YWJsZU1lcmdlID0gT2JzZXJ2YWJsZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZWR1bGVyLCBzb3VyY2VzID0gW10sIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgIHNjaGVkdWxlciA9IGltbWVkaWF0ZVNjaGVkdWxlcjtcbiAgICAgIGZvcihpID0gMTsgaSA8IGxlbjsgaSsrKSB7IHNvdXJjZXMucHVzaChhcmd1bWVudHNbaV0pOyB9XG4gICAgfSBlbHNlIGlmIChpc1NjaGVkdWxlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IoaSA9IDE7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXI7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VzWzBdKSkge1xuICAgICAgc291cmNlcyA9IHNvdXJjZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlT2Yoc2NoZWR1bGVyLCBzb3VyY2VzKS5tZXJnZUFsbCgpO1xuICB9O1xuXG4gIHZhciBDb21wb3NpdGVFcnJvciA9IFJ4LkNvbXBvc2l0ZUVycm9yID0gZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgdGhpcy5pbm5lckVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVGhpcyBjb250YWlucyBtdWx0aXBsZSBlcnJvcnMuIENoZWNrIHRoZSBpbm5lckVycm9ycyc7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgfTtcbiAgQ29tcG9zaXRlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBDb21wb3NpdGVFcnJvci5wcm90b3R5cGUubmFtZSA9ICdDb21wb3NpdGVFcnJvcic7XG5cbiAgdmFyIE1lcmdlRGVsYXlFcnJvck9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWVyZ2VEZWxheUVycm9yT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBncm91cCA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCksXG4gICAgICAgIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgc3RhdGUgPSB7IGlzU3RvcHBlZDogZmFsc2UsIGVycm9yczogW10sIG86IG8gfTtcblxuICAgICAgZ3JvdXAuYWRkKG0pO1xuICAgICAgbS5zZXREaXNwb3NhYmxlKHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIoZ3JvdXAsIHN0YXRlKSkpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHJldHVybiBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1lcmdlRGVsYXlFcnJvck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIE1lcmdlRGVsYXlFcnJvck9ic2VydmVyKGdyb3VwLCBzdGF0ZSkge1xuICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDb21wbGV0aW9uKG8sIGVycm9ycykge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG8ub25FcnJvcihlcnJvcnNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgby5vbkVycm9yKG5ldyBDb21wb3NpdGVFcnJvcihlcnJvcnMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBNZXJnZURlbGF5RXJyb3JPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgaW5uZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX2dyb3VwLmFkZChpbm5lcik7XG5cbiAgICAgIC8vIENoZWNrIGZvciBwcm9taXNlcyBzdXBwb3J0XG4gICAgICBpc1Byb21pc2UoeCkgJiYgKHggPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoeCkpO1xuICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZSh4LnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihpbm5lciwgdGhpcy5fZ3JvdXAsIHRoaXMuX3N0YXRlKSkpO1xuICAgIH07XG5cbiAgICBNZXJnZURlbGF5RXJyb3JPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fc3RhdGUuZXJyb3JzLnB1c2goZSk7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fZ3JvdXAubGVuZ3RoID09PSAxICYmIHNldENvbXBsZXRpb24odGhpcy5fc3RhdGUubywgdGhpcy5fc3RhdGUuZXJyb3JzKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLl9ncm91cC5sZW5ndGggPT09IDEgJiYgc2V0Q29tcGxldGlvbih0aGlzLl9zdGF0ZS5vLCB0aGlzLl9zdGF0ZS5lcnJvcnMpO1xuICAgIH07XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIoaW5uZXIsIGdyb3VwLCBzdGF0ZSkge1xuICAgICAgdGhpcy5faW5uZXIgPSBpbm5lcjtcbiAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7IHRoaXMuX3N0YXRlLm8ub25OZXh0KHgpOyB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmVycm9ycy5wdXNoKGUpO1xuICAgICAgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMuX2lubmVyKTtcbiAgICAgIHRoaXMuX3N0YXRlLmlzU3RvcHBlZCAmJiB0aGlzLl9ncm91cC5sZW5ndGggPT09IDEgJiYgc2V0Q29tcGxldGlvbih0aGlzLl9zdGF0ZS5vLCB0aGlzLl9zdGF0ZS5lcnJvcnMpO1xuICAgIH07XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMuX2lubmVyKTtcbiAgICAgIHRoaXMuX3N0YXRlLmlzU3RvcHBlZCAmJiB0aGlzLl9ncm91cC5sZW5ndGggPT09IDEgJiYgc2V0Q29tcGxldGlvbih0aGlzLl9zdGF0ZS5vLCB0aGlzLl9zdGF0ZS5lcnJvcnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqIEZsYXR0ZW5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLCBpbiBhIHdheSB0aGF0IGFsbG93cyBhbiBPYnNlcnZlciB0b1xuICAqIHJlY2VpdmUgYWxsIHN1Y2Nlc3NmdWxseSBlbWl0dGVkIGl0ZW1zIGZyb20gYWxsIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZXMgd2l0aG91dCBiZWluZyBpbnRlcnJ1cHRlZCBieVxuICAqIGFuIGVycm9yIG5vdGlmaWNhdGlvbiBmcm9tIG9uZSBvZiB0aGVtLlxuICAqXG4gICogVGhpcyBiZWhhdmVzIGxpa2UgT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VBbGwgZXhjZXB0IHRoYXQgaWYgYW55IG9mIHRoZSBtZXJnZWQgT2JzZXJ2YWJsZXMgbm90aWZ5IG9mIGFuXG4gICogZXJyb3IgdmlhIHRoZSBPYnNlcnZlcidzIG9uRXJyb3IsIG1lcmdlRGVsYXlFcnJvciB3aWxsIHJlZnJhaW4gZnJvbSBwcm9wYWdhdGluZyB0aGF0XG4gICogZXJyb3Igbm90aWZpY2F0aW9uIHVudGlsIGFsbCBvZiB0aGUgbWVyZ2VkIE9ic2VydmFibGVzIGhhdmUgZmluaXNoZWQgZW1pdHRpbmcgaXRlbXMuXG4gICogQHBhcmFtIHtBcnJheSB8IEFyZ3VtZW50c30gYXJncyBBcmd1bWVudHMgb3IgYW4gYXJyYXkgdG8gbWVyZ2UuXG4gICogQHJldHVybnMge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgb2YgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIE9ic2VydmFibGVcbiAgKi9cbiAgT2JzZXJ2YWJsZS5tZXJnZURlbGF5RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBvYnNlcnZhYmxlT2YobnVsbCwgYXJncyk7XG4gICAgcmV0dXJuIG5ldyBNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlKHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIE1lcmdlQWxsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWVyZ2VBbGxPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxPYnNlcnZhYmxlKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNZXJnZUFsbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGcgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLCBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICBnLmFkZChtKTtcbiAgICAgIG0uc2V0RGlzcG9zYWJsZSh0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsT2JzZXJ2ZXIobywgZykpKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VBbGxPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE1lcmdlQWxsT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT2JzZXJ2ZXIobywgZykge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuZyA9IGc7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKE1lcmdlQWxsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBNZXJnZUFsbE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oaW5uZXJTb3VyY2UpIHtcbiAgICAgIHZhciBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuZy5hZGQoc2FkKTtcbiAgICAgIGlzUHJvbWlzZShpbm5lclNvdXJjZSkgJiYgKGlubmVyU291cmNlID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGlubmVyU291cmNlKSk7XG4gICAgICBzYWQuc2V0RGlzcG9zYWJsZShpbm5lclNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIodGhpcywgc2FkKSkpO1xuICAgIH07XG5cbiAgICBNZXJnZUFsbE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgTWVyZ2VBbGxPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuZy5sZW5ndGggPT09IDEgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIocGFyZW50LCBzYWQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5zYWQgPSBzYWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhJbm5lck9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnBhcmVudC5vLm9uTmV4dCh4KTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMucGFyZW50Lm8ub25FcnJvcihlKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFyZW50LmcucmVtb3ZlKHRoaXMuc2FkKTtcbiAgICAgIHRoaXMucGFyZW50LmRvbmUgJiYgdGhpcy5wYXJlbnQuZy5sZW5ndGggPT09IDEgJiYgdGhpcy5wYXJlbnQuby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVyZ2VBbGxPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICogTWVyZ2VzIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IG1lcmdlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGlubmVyIHNlcXVlbmNlcy5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLm1lcmdlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTWVyZ2VBbGxPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb250aW51ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGlzIHRlcm1pbmF0ZWQgbm9ybWFsbHkgb3IgYnkgYW4gZXhjZXB0aW9uIHdpdGggdGhlIG5leHQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBzZWNvbmQgU2Vjb25kIG9ic2VydmFibGUgc2VxdWVuY2UgdXNlZCB0byBwcm9kdWNlIHJlc3VsdHMgYWZ0ZXIgdGhlIGZpcnN0IHNlcXVlbmNlIHRlcm1pbmF0ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29uY2F0ZW5hdGVzIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHNlcXVlbmNlLCBldmVuIGlmIHRoZSBmaXJzdCBzZXF1ZW5jZSB0ZXJtaW5hdGVzIGV4Y2VwdGlvbmFsbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ub25FcnJvclJlc3VtZU5leHQgPSBmdW5jdGlvbiAoc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHsgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgb2JzZXJ2YWJsZSBpcyByZXF1aXJlZCcpOyB9XG4gICAgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0KFt0aGlzLCBzZWNvbmRdKTtcbiAgfTtcblxuICB2YXIgT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUoc291cmNlcykge1xuICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBpZiAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzdGF0ZS5zb3VyY2VzW3N0YXRlLnBvcysrXTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnQpICYmIChjdXJyZW50ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKGN1cnJlbnQpKTtcbiAgICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3RhdGUuc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICAgIGQuc2V0RGlzcG9zYWJsZShjdXJyZW50LnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlcihzdGF0ZSwgcmVjdXJzZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgICAgc3RhdGUgPSB7cG9zOiAwLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiwgbzogbywgc291cmNlczogdGhpcy5zb3VyY2VzIH0sXG4gICAgICAgICAgY2FuY2VsbGFibGUgPSBpbW1lZGlhdGVTY2hlZHVsZXIuc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHNjaGVkdWxlTWV0aG9kKTtcblxuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsbGFibGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoT25FcnJvclJlc3VtZU5leHRPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcmVjdXJzZSA9IHJlY3Vyc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fc3RhdGUuby5vbk5leHQoeCk7IH07XG4gICAgT25FcnJvclJlc3VtZU5leHRPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlY3Vyc2UodGhpcy5fc3RhdGUpOyB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVjdXJzZSh0aGlzLl9zdGF0ZSk7IH07XG5cbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIENvbnRpbnVlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGVybWluYXRlZCBub3JtYWxseSBvciBieSBhbiBleGNlcHRpb24gd2l0aCB0aGUgbmV4dCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbmNhdGVuYXRlcyB0aGUgc291cmNlIHNlcXVlbmNlcywgZXZlbiBpZiBhIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZXhjZXB0aW9uYWxseS5cbiAgICovXG4gIHZhciBvbkVycm9yUmVzdW1lTmV4dCA9IE9ic2VydmFibGUub25FcnJvclJlc3VtZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICBzb3VyY2VzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHNvdXJjZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBzb3VyY2VzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgT25FcnJvclJlc3VtZU5leHRPYnNlcnZhYmxlKHNvdXJjZXMpO1xuICB9O1xuXG4gIHZhciBTa2lwVW50aWxPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPYnNlcnZhYmxlKHNvdXJjZSwgb3RoZXIpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9vID0gaXNQcm9taXNlKG90aGVyKSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikgOiBvdGhlcjtcbiAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbGVmdFN1YnNjcmlwdGlvbiA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgbGVmdFN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHRoaXMuX3Muc3Vic2NyaWJlKG5ldyBTa2lwVW50aWxTb3VyY2VPYnNlcnZlcihvLCB0aGlzKSkpO1xuXG4gICAgICBpc1Byb21pc2UodGhpcy5fbykgJiYgKHRoaXMuX28gPSBvYnNlcnZhYmxlRnJvbVByb21pc2UodGhpcy5fbykpO1xuXG4gICAgICB2YXIgcmlnaHRTdWJzY3JpcHRpb24gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgIHJpZ2h0U3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5fby5zdWJzY3JpYmUobmV3IFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIobywgdGhpcywgcmlnaHRTdWJzY3JpcHRpb24pKSk7XG5cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShsZWZ0U3Vic2NyaXB0aW9uLCByaWdodFN1YnNjcmlwdGlvbik7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBVbnRpbFNvdXJjZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBVbnRpbFNvdXJjZU9ic2VydmVyKG8sIHApIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9wLl9vcGVuICYmIHRoaXMuX28ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuXG4gICAgU2tpcFVudGlsU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcC5fb3BlbiAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxTb3VyY2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgdmFyIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsT3RoZXJPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPdGhlck9ic2VydmVyKG8sIHAsIHIpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9yID0gcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbE90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wLl9vcGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3IuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxPdGhlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBTa2lwVW50aWxPdGhlck9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3IuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFVudGlsT3RoZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvbmx5IGFmdGVyIHRoZSBvdGhlciBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2VzIGEgdmFsdWUuXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZSB8IFByb21pc2V9IG90aGVyIFRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIFByb21pc2UgdGhhdCB0cmlnZ2VycyBwcm9wYWdhdGlvbiBvZiBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHN0YXJ0aW5nIGZyb20gdGhlIHBvaW50IHRoZSBvdGhlciBzZXF1ZW5jZSB0cmlnZ2VyZWQgcHJvcGFnYXRpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFVudGlsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBTa2lwVW50aWxPYnNlcnZhYmxlKHRoaXMsIG90aGVyKTtcbiAgfTtcblxuICB2YXIgU3dpdGNoT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTd2l0Y2hPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE9ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFN3aXRjaE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGlubmVyID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSwgcyA9IHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoT2JzZXJ2ZXIobywgaW5uZXIpKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzLCBpbm5lcik7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKFN3aXRjaE9ic2VydmVyLCBBYnN0cmFjdE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPYnNlcnZlcihvLCBpbm5lcikge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXRlc3QgPSAwO1xuICAgICAgdGhpcy5oYXNMYXRlc3QgPSBmYWxzZTtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTd2l0Y2hPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpbm5lclNvdXJjZSkge1xuICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSwgaWQgPSArK3RoaXMubGF0ZXN0O1xuICAgICAgdGhpcy5oYXNMYXRlc3QgPSB0cnVlO1xuICAgICAgdGhpcy5pbm5lci5zZXREaXNwb3NhYmxlKGQpO1xuICAgICAgaXNQcm9taXNlKGlubmVyU291cmNlKSAmJiAoaW5uZXJTb3VyY2UgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UoaW5uZXJTb3VyY2UpKTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShpbm5lclNvdXJjZS5zdWJzY3JpYmUobmV3IElubmVyT2JzZXJ2ZXIodGhpcywgaWQpKSk7XG4gICAgfTtcblxuICAgIFN3aXRjaE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLm8ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU3dpdGNoT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAhdGhpcy5oYXNMYXRlc3QgJiYgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIocGFyZW50LCBpZCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICBBYnN0cmFjdE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5wYXJlbnQubGF0ZXN0ID09PSB0aGlzLmlkICYmIHRoaXMucGFyZW50Lm8ub25OZXh0KHgpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnBhcmVudC5sYXRlc3QgPT09IHRoaXMuaWQgJiYgdGhpcy5wYXJlbnQuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQubGF0ZXN0ID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmhhc0xhdGVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmVudC5zdG9wcGVkICYmIHRoaXMucGFyZW50Lm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFN3aXRjaE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgKiBUcmFuc2Zvcm1zIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudCBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGF0IGFueSBwb2ludCBpbiB0aW1lIHByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgbW9zdCByZWNlbnQgaW5uZXIgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkLlxuICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ3N3aXRjaCddID0gb2JzZXJ2YWJsZVByb3RvLnN3aXRjaExhdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN3aXRjaE9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIFRha2VVbnRpbE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVVudGlsT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFRha2VVbnRpbE9ic2VydmFibGUoc291cmNlLCBvdGhlcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm90aGVyID0gaXNQcm9taXNlKG90aGVyKSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZShvdGhlcikgOiBvdGhlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VVbnRpbE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShvKSxcbiAgICAgICAgdGhpcy5vdGhlci5zdWJzY3JpYmUobmV3IFRha2VVbnRpbE9ic2VydmVyKG8pKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VVbnRpbE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZVVudGlsT2JzZXJ2ZXIgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVVudGlsT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlVW50aWxPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgVGFrZVVudGlsT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGVycik7XG4gICAgfTtcblxuICAgIFRha2VVbnRpbE9ic2VydmVyLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IG5vb3A7XG5cbiAgICByZXR1cm4gVGFrZVVudGlsT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUgc2VxdWVuY2UgdW50aWwgdGhlIG90aGVyIG9ic2VydmFibGUgc2VxdWVuY2UgcHJvZHVjZXMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlIHwgUHJvbWlzZX0gb3RoZXIgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBvciBQcm9taXNlIHRoYXQgdGVybWluYXRlcyBwcm9wYWdhdGlvbiBvZiBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIHNlcXVlbmNlIHVwIHRvIHRoZSBwb2ludCB0aGUgb3RoZXIgc2VxdWVuY2UgaW50ZXJydXB0ZWQgZnVydGhlciBwcm9wYWdhdGlvbi5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlVW50aWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IFRha2VVbnRpbE9ic2VydmFibGUodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZhbHNlRmFjdG9yeSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZ1bmN0aW9uIGFyZ3VtZW50c1RvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgdmFyIFdpdGhMYXRlc3RGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlKHNvdXJjZSwgc291cmNlcywgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX3MgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zcyA9IHNvdXJjZXM7XG4gICAgICB0aGlzLl9jYiA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9zcy5sZW5ndGg7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGhhc1ZhbHVlOiBhcnJheUluaXRpYWxpemUobGVuLCBmYWxzZUZhY3RvcnkpLFxuICAgICAgICBoYXNWYWx1ZUFsbDogZmFsc2UsXG4gICAgICAgIHZhbHVlczogbmV3IEFycmF5KGxlbilcbiAgICAgIH07XG5cbiAgICAgIHZhciBuID0gdGhpcy5fc3MubGVuZ3RoLCBzdWJzY3JpcHRpb25zID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHRoaXMuX3NzW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgaXNQcm9taXNlKG90aGVyKSAmJiAob3RoZXIgPSBvYnNlcnZhYmxlRnJvbVByb21pc2Uob3RoZXIpKTtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUob3RoZXIuc3Vic2NyaWJlKG5ldyBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIobywgaSwgc3RhdGUpKSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRlclNhZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgb3V0ZXJTYWQuc2V0RGlzcG9zYWJsZSh0aGlzLl9zLnN1YnNjcmliZShuZXcgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlcihvLCB0aGlzLl9jYiwgc3RhdGUpKSk7XG4gICAgICBzdWJzY3JpcHRpb25zW25dID0gb3V0ZXJTYWQ7XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyKG8sIGksIHN0YXRlKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9zdGF0ZS52YWx1ZXNbdGhpcy5faV0gPSB4O1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwgPSB0aGlzLl9zdGF0ZS5oYXNWYWx1ZS5ldmVyeShpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIFdpdGhMYXRlc3RGcm9tT3RoZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IG5vb3A7XG5cbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21PdGhlck9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICB2YXIgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyKG8sIGNiLCBzdGF0ZSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jYiA9IGNiO1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFdpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGFsbFZhbHVlcyA9IFt4XS5jb25jYXQodGhpcy5fc3RhdGUudmFsdWVzKTtcbiAgICAgIGlmICghdGhpcy5fc3RhdGUuaGFzVmFsdWVBbGwpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fY2IpLmFwcGx5KG51bGwsIGFsbFZhbHVlcyk7XG4gICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICB9O1xuXG4gICAgV2l0aExhdGVzdEZyb21Tb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbVNvdXJjZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogTWVyZ2VzIHRoZSBzcGVjaWZpZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gb25seSB3aGVuIHRoZSAoZmlyc3QpIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2VzIGFuIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIHNvdXJjZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2l0aExhdGVzdEZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cycpOyB9XG5cbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gaXNGdW5jdGlvbihhcmdzW2xlbiAtIDFdKSA/IGFyZ3MucG9wKCkgOiBhcmd1bWVudHNUb0FycmF5O1xuICAgIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgKGFyZ3MgPSBhcmdzWzBdKTtcblxuICAgIHJldHVybiBuZXcgV2l0aExhdGVzdEZyb21PYnNlcnZhYmxlKHRoaXMsIGFyZ3MsIHJlc3VsdFNlbGVjdG9yKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmYWxzZUZhY3RvcnkoKSB7IHJldHVybiBmYWxzZTsgfVxuICBmdW5jdGlvbiBlbXB0eUFycmF5RmFjdG9yeSgpIHsgcmV0dXJuIFtdOyB9XG5cbiAgdmFyIFppcE9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoWmlwT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBaaXBPYnNlcnZhYmxlKHNvdXJjZXMsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl9zID0gc291cmNlcztcbiAgICAgIHRoaXMuX2NiID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBaaXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5fcy5sZW5ndGgsXG4gICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBkb25lID0gYXJyYXlJbml0aWFsaXplKG4sIGZhbHNlRmFjdG9yeSksXG4gICAgICAgICAgcSA9IGFycmF5SW5pdGlhbGl6ZShuLCBlbXB0eUFycmF5RmFjdG9yeSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9zW2ldLCBzYWQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uc1tpXSA9IHNhZDtcbiAgICAgICAgaXNQcm9taXNlKHNvdXJjZSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShzb3VyY2UpKTtcbiAgICAgICAgc2FkLnNldERpc3Bvc2FibGUoc291cmNlLnN1YnNjcmliZShuZXcgWmlwT2JzZXJ2ZXIob2JzZXJ2ZXIsIGksIHRoaXMsIHEsIGRvbmUpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTkFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBaaXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFppcE9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhaaXBPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBaaXBPYnNlcnZlcihvLCBpLCBwLCBxLCBkKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2kgPSBpO1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICAgICB0aGlzLl9xID0gcTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90RW1wdHkoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9XG4gICAgZnVuY3Rpb24gc2hpZnRFYWNoKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfVxuICAgIGZ1bmN0aW9uIG5vdFRoZVNhbWUoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9PSBpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBaaXBPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9xW3RoaXMuX2ldLnB1c2goeCk7XG4gICAgICBpZiAodGhpcy5fcS5ldmVyeShub3RFbXB0eSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlZFZhbHVlcyA9IHRoaXMuX3EubWFwKHNoaWZ0RWFjaCk7XG4gICAgICAgIHZhciByZXMgPSB0cnlDYXRjaCh0aGlzLl9wLl9jYikuYXBwbHkobnVsbCwgcXVldWVkVmFsdWVzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICAgICAgdGhpcy5fby5vbk5leHQocmVzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZC5maWx0ZXIobm90VGhlU2FtZSh0aGlzLl9pKSkuZXZlcnkoaWRlbnRpdHkpKSB7XG4gICAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWmlwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgWmlwT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2RbdGhpcy5faV0gPSB0cnVlO1xuICAgICAgdGhpcy5fZC5ldmVyeShpZGVudGl0eSkgJiYgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWmlwT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbGwgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIGFuIGFycmF5IGhhdmUgcHJvZHVjZWQgYW4gZWxlbWVudCBhdCBhIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gICAqIFRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGFyZ3VtZW50cyBtdXN0IGJlIGEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHNlcmllcyBvZiBlbGVtZW50cyBhdCBjb3JyZXNwb25kaW5nIGluZGV4ZXMgaW4gdGhlIGFyZ3MuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcgZWxlbWVudHMgb2YgdGhlIGFyZ3MgdXNpbmcgdGhlIHNwZWNpZmllZCByZXN1bHQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uemlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudHMnKTsgfVxuXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGlzRnVuY3Rpb24oYXJnc1tsZW4gLSAxXSkgPyBhcmdzLnBvcCgpIDogYXJndW1lbnRzVG9BcnJheTtcbiAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIChhcmdzID0gYXJnc1swXSk7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICBhcmdzLnVuc2hpZnQocGFyZW50KTtcblxuICAgIHJldHVybiBuZXcgWmlwT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgc3BlY2lmaWVkIG9ic2VydmFibGUgc2VxdWVuY2VzIGludG8gb25lIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgdXNpbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHdoZW5ldmVyIGFsbCBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaGF2ZSBwcm9kdWNlZCBhbiBlbGVtZW50IGF0IGEgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICogQHBhcmFtIGFyZ3VtZW50cyBPYnNlcnZhYmxlIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc3VsdFNlbGVjdG9yIEZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBzb3VyY2VzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgY29tYmluaW5nIGVsZW1lbnRzIG9mIHRoZSBzb3VyY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmVzdWx0IHNlbGVjdG9yIGZ1bmN0aW9uLlxuICAgKi9cbiAgT2JzZXJ2YWJsZS56aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzID0gaXNGdW5jdGlvbihhcmdzWzFdKSA/IGFyZ3NbMF0uY29uY2F0KGFyZ3NbMV0pIDogYXJnc1swXTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gYXJncy5zaGlmdCgpO1xuICAgIHJldHVybiBmaXJzdC56aXAuYXBwbHkoZmlyc3QsIGFyZ3MpO1xuICB9O1xuXG5mdW5jdGlvbiBmYWxzZUZhY3RvcnkoKSB7IHJldHVybiBmYWxzZTsgfVxuZnVuY3Rpb24gZW1wdHlBcnJheUZhY3RvcnkoKSB7IHJldHVybiBbXTsgfVxuZnVuY3Rpb24gYXJndW1lbnRzVG9BcnJheSgpIHtcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbnZhciBaaXBJdGVyYWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gIGluaGVyaXRzKFppcEl0ZXJhYmxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gWmlwSXRlcmFibGVPYnNlcnZhYmxlKHNvdXJjZXMsIGNiKSB7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLl9jYiA9IGNiO1xuICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgWmlwSXRlcmFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuc291cmNlcywgbGVuID0gc291cmNlcy5sZW5ndGgsIHN1YnNjcmlwdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHE6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGVtcHR5QXJyYXlGYWN0b3J5KSxcbiAgICAgIGRvbmU6IGFycmF5SW5pdGlhbGl6ZShsZW4sIGZhbHNlRmFjdG9yeSksXG4gICAgICBjYjogdGhpcy5fY2IsXG4gICAgICBvOiBvXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXSwgc2FkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIChpc0FycmF5TGlrZShzb3VyY2UpIHx8IGlzSXRlcmFibGUoc291cmNlKSkgJiYgKHNvdXJjZSA9IG9ic2VydmFibGVGcm9tKHNvdXJjZSkpO1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNbaV0gPSBzYWQ7XG4gICAgICAgIHNhZC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUobmV3IFppcEl0ZXJhYmxlT2JzZXJ2ZXIoc3RhdGUsIGkpKSk7XG4gICAgICB9KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBaaXBJdGVyYWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVCYXNlKSk7XG5cbnZhciBaaXBJdGVyYWJsZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgaW5oZXJpdHMoWmlwSXRlcmFibGVPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgZnVuY3Rpb24gWmlwSXRlcmFibGVPYnNlcnZlcihzLCBpKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5faSA9IGk7XG4gICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RFbXB0eSh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH1cbiAgZnVuY3Rpb24gc2hpZnRFYWNoKHgpIHsgcmV0dXJuIHguc2hpZnQoKTsgfVxuICBmdW5jdGlvbiBub3RUaGVTYW1lKGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGopIHtcbiAgICAgIHJldHVybiBqICE9PSBpO1xuICAgIH07XG4gIH1cblxuICBaaXBJdGVyYWJsZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICB0aGlzLl9zLnFbdGhpcy5faV0ucHVzaCh4KTtcbiAgICBpZiAodGhpcy5fcy5xLmV2ZXJ5KG5vdEVtcHR5KSkge1xuICAgICAgdmFyIHF1ZXVlZFZhbHVlcyA9IHRoaXMuX3MucS5tYXAoc2hpZnRFYWNoKSxcbiAgICAgICAgICByZXMgPSB0cnlDYXRjaCh0aGlzLl9zLmNiKS5hcHBseShudWxsLCBxdWV1ZWRWYWx1ZXMpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuX3Muby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5fcy5vLm9uTmV4dChyZXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcy5kb25lLmZpbHRlcihub3RUaGVTYW1lKHRoaXMuX2kpKS5ldmVyeShpZGVudGl0eSkpIHtcbiAgICAgIHRoaXMuX3Muby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcblxuICBaaXBJdGVyYWJsZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX3Muby5vbkVycm9yKGUpOyB9O1xuXG4gIFppcEl0ZXJhYmxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zLmRvbmVbdGhpcy5faV0gPSB0cnVlO1xuICAgIHRoaXMuX3MuZG9uZS5ldmVyeShpZGVudGl0eSkgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gIH07XG5cbiAgcmV0dXJuIFppcEl0ZXJhYmxlT2JzZXJ2ZXI7XG59KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHNwZWNpZmllZCBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB3aGVuZXZlciBhbGwgb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2VzIG9yIGFuIGFycmF5IGhhdmUgcHJvZHVjZWQgYW4gZWxlbWVudCBhdCBhIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gKiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBhcmd1bWVudHMgbXVzdCBiZSBhIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBzZXJpZXMgb2YgZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzIGluIHRoZSBhcmdzLlxuICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGNvbWJpbmluZyBlbGVtZW50cyBvZiB0aGUgYXJncyB1c2luZyB0aGUgc3BlY2lmaWVkIHJlc3VsdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAqL1xub2JzZXJ2YWJsZVByb3RvLnppcEl0ZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzJyk7IH1cblxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgfVxuICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBpc0Z1bmN0aW9uKGFyZ3NbbGVuIC0gMV0pID8gYXJncy5wb3AoKSA6IGFyZ3VtZW50c1RvQXJyYXk7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG4gIGFyZ3MudW5zaGlmdChwYXJlbnQpO1xuICByZXR1cm4gbmV3IFppcEl0ZXJhYmxlT2JzZXJ2YWJsZShhcmdzLCByZXN1bHRTZWxlY3Rvcik7XG59O1xuXG4gIGZ1bmN0aW9uIGFzT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3Vic2NyaWJlKG8pIHsgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobyk7IH07XG4gIH1cblxuICAvKipcbiAgICogIEhpZGVzIHRoZSBpZGVudGl0eSBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGhpZGVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoYXNPYnNlcnZhYmxlKHRoaXMpLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0FycmF5KHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9XG4gIGZ1bmN0aW9uIG5vdEVtcHR5KHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfVxuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgYnVmZmVycyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gZWxlbWVudCBjb3VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IExlbmd0aCBvZiBlYWNoIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIGJ1ZmZlcnMuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gdGhlIGNvdW50LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBidWZmZXJzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmJ1ZmZlcldpdGhDb3VudCA9IG9ic2VydmFibGVQcm90by5idWZmZXJDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgc2tpcCkge1xuICAgIHR5cGVvZiBza2lwICE9PSAnbnVtYmVyJyAmJiAoc2tpcCA9IGNvdW50KTtcbiAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoQ291bnQoY291bnQsIHNraXApXG4gICAgICAuZmxhdE1hcCh0b0FycmF5KVxuICAgICAgLmZpbHRlcihub3RFbXB0eSk7XG4gIH07XG5cbiAgdmFyIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZW1hdGVyaWFsaXplT2JzZXJ2YWJsZShzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgRGVtYXRlcmlhbGl6ZU9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlbWF0ZXJpYWxpemVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIERlbWF0ZXJpYWxpemVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVtYXRlcmlhbGl6ZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRGVtYXRlcmlhbGl6ZU9ic2VydmVyKG8pIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgeC5hY2NlcHQodGhpcy5fbyk7IH07XG4gICAgRGVtYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBEZW1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIERlbWF0ZXJpYWxpemVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqIERlbWF0ZXJpYWxpemVzIHRoZSBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgaW1wbGljaXQgbm90aWZpY2F0aW9ucy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgZXhoaWJpdGluZyB0aGUgYmVoYXZpb3IgY29ycmVzcG9uZGluZyB0byB0aGUgc291cmNlIHNlcXVlbmNlJ3Mgbm90aWZpY2F0aW9uIHZhbHVlcy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kZW1hdGVyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGVtYXRlcmlhbGl6ZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgdmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZhYmxlKHNvdXJjZSwga2V5Rm4sIGNvbXBhcmVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMua2V5Rm4gPSBrZXlGbjtcbiAgICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyKG8sIHRoaXMua2V5Rm4sIHRoaXMuY29tcGFyZXIpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlcihvLCBrZXlGbiwgY29tcGFyZXIpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLmtleUZuID0ga2V5Rm47XG4gICAgICB0aGlzLmNvbXBhcmVyID0gY29tcGFyZXI7XG4gICAgICB0aGlzLmhhc0N1cnJlbnRLZXkgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudEtleSA9IG51bGw7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrZXkgPSB4LCBjb21wYXJlckVxdWFscztcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMua2V5Rm4pKSB7XG4gICAgICAgIGtleSA9IHRyeUNhdGNoKHRoaXMua2V5Rm4pKHgpO1xuICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3Ioa2V5LmUpOyB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNDdXJyZW50S2V5KSB7XG4gICAgICAgIGNvbXBhcmVyRXF1YWxzID0gdHJ5Q2F0Y2godGhpcy5jb21wYXJlcikodGhpcy5jdXJyZW50S2V5LCBrZXkpO1xuICAgICAgICBpZiAoY29tcGFyZXJFcXVhbHMgPT09IGVycm9yT2JqKSB7IHJldHVybiB0aGlzLm8ub25FcnJvcihjb21wYXJlckVxdWFscy5lKTsgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmhhc0N1cnJlbnRLZXkgfHwgIWNvbXBhcmVyRXF1YWxzKSB7XG4gICAgICAgIHRoaXMuaGFzQ3VycmVudEtleSA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudEtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5vLm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyBvbmx5IGRpc3RpbmN0IGNvbnRpZ3VvdXMgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBrZXlGbiBhbmQgdGhlIGNvbXBhcmVyLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtrZXlGbl0gQSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBjb21wYXJpc29uIGtleSBmb3IgZWFjaCBlbGVtZW50LiBJZiBub3QgcHJvdmlkZWQsIGl0IHByb2plY3RzIHRoZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyZXJdIEVxdWFsaXR5IGNvbXBhcmVyIGZvciBjb21wdXRlZCBrZXkgdmFsdWVzLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGFuIGVxdWFsaXR5IGNvbXBhcmVyIGZ1bmN0aW9uLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9ubHkgY29udGFpbmluZyB0aGUgZGlzdGluY3QgY29udGlndW91cyBlbGVtZW50cywgYmFzZWQgb24gYSBjb21wdXRlZCBrZXkgdmFsdWUsIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZnVuY3Rpb24gKGtleUZuLCBjb21wYXJlcikge1xuICAgIGNvbXBhcmVyIHx8IChjb21wYXJlciA9IGRlZmF1bHRDb21wYXJlcik7XG4gICAgcmV0dXJuIG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9ic2VydmFibGUodGhpcywga2V5Rm4sIGNvbXBhcmVyKTtcbiAgfTtcblxuICB2YXIgVGFwT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYXBPYnNlcnZhYmxlLF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFwT2JzZXJ2YWJsZShzb3VyY2UsIG9ic2VydmVyT3JPbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX29OID0gb2JzZXJ2ZXJPck9uTmV4dDtcbiAgICAgIHRoaXMuX29FID0gb25FcnJvcjtcbiAgICAgIHRoaXMuX29DID0gb25Db21wbGV0ZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMudCA9ICFwLl9vTiB8fCBpc0Z1bmN0aW9uKHAuX29OKSA/XG4gICAgICAgIG9ic2VydmVyQ3JlYXRlKHAuX29OIHx8IG5vb3AsIHAuX29FIHx8IG5vb3AsIHAuX29DIHx8IG5vb3ApIDpcbiAgICAgICAgcC5fb047XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMudC5vbk5leHQpLmNhbGwodGhpcy50LCB4KTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uTmV4dCh4KTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy50Lm9uRXJyb3IpLmNhbGwodGhpcy50LCBlcnIpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uRXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMudC5vbkNvbXBsZXRlZCkuY2FsbCh0aGlzLnQpO1xuICAgICAgaWYgKHJlcyA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHRoaXMuby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIGludm9rZXMgYW4gYWN0aW9uIHVwb24gZ3JhY2VmdWwgb3IgZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JzZXJ2ZXJ9IG9ic2VydmVyT3JPbk5leHQgQWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIG9yIGFuIG8uXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdICBBY3Rpb24gdG8gaW52b2tlIHVwb24gZXhjZXB0aW9uYWwgdGVybWluYXRpb24gb2YgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuIFVzZWQgaWYgb25seSB0aGUgb2JzZXJ2ZXJPck9uTmV4dCBwYXJhbWV0ZXIgaXMgYWxzbyBhIGZ1bmN0aW9uLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlZF0gIEFjdGlvbiB0byBpbnZva2UgdXBvbiBncmFjZWZ1bCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS4gVXNlZCBpZiBvbmx5IHRoZSBvYnNlcnZlck9yT25OZXh0IHBhcmFtZXRlciBpcyBhbHNvIGEgZnVuY3Rpb24uXG4gICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgc2lkZS1lZmZlY3RpbmcgYmVoYXZpb3IgYXBwbGllZC5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvWydkbyddID0gb2JzZXJ2YWJsZVByb3RvLnRhcCA9IG9ic2VydmFibGVQcm90by5kb0FjdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCkge1xuICAgIHJldHVybiBuZXcgVGFwT2JzZXJ2YWJsZSh0aGlzLCBvYnNlcnZlck9yT25OZXh0LCBvbkVycm9yLCBvbkNvbXBsZXRlZCk7XG4gIH07XG5cbiAgLyoqXG4gICogIEludm9rZXMgYW4gYWN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICogIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcsIGxvZ2dpbmcsIGV0Yy4gb2YgcXVlcnkgYmVoYXZpb3IgYnkgaW50ZXJjZXB0aW5nIHRoZSBtZXNzYWdlIHN0cmVhbSB0byBydW4gYXJiaXRyYXJ5IGFjdGlvbnMgZm9yIG1lc3NhZ2VzIG9uIHRoZSBwaXBlbGluZS5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgQWN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uTmV4dCA9IG9ic2VydmFibGVQcm90by50YXBPbk5leHQgPSBmdW5jdGlvbiAob25OZXh0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICh4KSB7IG9uTmV4dC5jYWxsKHRoaXNBcmcsIHgpOyB9IDogb25OZXh0KTtcbiAgfTtcblxuICAvKipcbiAgKiAgSW52b2tlcyBhbiBhY3Rpb24gdXBvbiBleGNlcHRpb25hbCB0ZXJtaW5hdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZywgbG9nZ2luZywgZXRjLiBvZiBxdWVyeSBiZWhhdmlvciBieSBpbnRlcmNlcHRpbmcgdGhlIG1lc3NhZ2Ugc3RyZWFtIHRvIHJ1biBhcmJpdHJhcnkgYWN0aW9ucyBmb3IgbWVzc2FnZXMgb24gdGhlIHBpcGVsaW5lLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRXJyb3IgQWN0aW9uIHRvIGludm9rZSB1cG9uIGV4Y2VwdGlvbmFsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uRXJyb3IgPSBvYnNlcnZhYmxlUHJvdG8udGFwT25FcnJvciA9IGZ1bmN0aW9uIChvbkVycm9yLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIChlKSB7IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlKTsgfSA6IG9uRXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAqICBJbnZva2VzIGFuIGFjdGlvbiB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgZGVidWdnaW5nLCBsb2dnaW5nLCBldGMuIG9mIHF1ZXJ5IGJlaGF2aW9yIGJ5IGludGVyY2VwdGluZyB0aGUgbWVzc2FnZSBzdHJlYW0gdG8gcnVuIGFyYml0cmFyeSBhY3Rpb25zIGZvciBtZXNzYWdlcyBvbiB0aGUgcGlwZWxpbmUuXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZWQgQWN0aW9uIHRvIGludm9rZSB1cG9uIGdyYWNlZnVsIHRlcm1pbmF0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIHNlcXVlbmNlIHdpdGggdGhlIHNpZGUtZWZmZWN0aW5nIGJlaGF2aW9yIGFwcGxpZWQuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5kb09uQ29tcGxldGVkID0gb2JzZXJ2YWJsZVByb3RvLnRhcE9uQ29tcGxldGVkID0gZnVuY3Rpb24gKG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFwKG5vb3AsIG51bGwsIHR5cGVvZiB0aGlzQXJnICE9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICgpIHsgb25Db21wbGV0ZWQuY2FsbCh0aGlzQXJnKTsgfSA6IG9uQ29tcGxldGVkKTtcbiAgfTtcblxuICB2YXIgRmluYWxseU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEZpbmFsbHlPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlPYnNlcnZhYmxlKHNvdXJjZSwgZm4sIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBiaW5kQ2FsbGJhY2soZm4sIHRoaXNBcmcsIDApO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmluYWxseU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGQgPSB0cnlDYXRjaCh0aGlzLnNvdXJjZS5zdWJzY3JpYmUpLmNhbGwodGhpcy5zb3VyY2UsIG8pO1xuICAgICAgaWYgKGQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX2ZuKCk7XG4gICAgICAgIHRocm93ZXIoZC5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBGaW5hbGx5RGlzcG9zYWJsZShkLCB0aGlzLl9mbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZpbmFsbHlEaXNwb3NhYmxlKHMsIGZuKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICB9XG4gICAgRmluYWxseURpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICB2YXIgcmVzID0gdHJ5Q2F0Y2godGhpcy5fcy5kaXNwb3NlKS5jYWxsKHRoaXMuX3MpO1xuICAgICAgICB0aGlzLl9mbigpO1xuICAgICAgICByZXMgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzLmUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmluYWxseU9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgSW52b2tlcyBhIHNwZWNpZmllZCBhY3Rpb24gYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMgZ3JhY2VmdWxseSBvciBleGNlcHRpb25hbGx5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5hbGx5QWN0aW9uIEFjdGlvbiB0byBpbnZva2UgYWZ0ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRlcm1pbmF0ZXMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBTb3VyY2Ugc2VxdWVuY2Ugd2l0aCB0aGUgYWN0aW9uLWludm9raW5nIHRlcm1pbmF0aW9uIGJlaGF2aW9yIGFwcGxpZWQuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG9bJ2ZpbmFsbHknXSA9IGZ1bmN0aW9uIChhY3Rpb24sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZpbmFsbHlPYnNlcnZhYmxlKHRoaXMsIGFjdGlvbiwgdGhpc0FyZyk7XG4gIH07XG5cbiAgdmFyIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhJZ25vcmVFbGVtZW50c09ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c09ic2VydmFibGUoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIElnbm9yZUVsZW1lbnRzT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8pKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5uZXJPYnNlcnZlcihvKSB7XG4gICAgICB0aGlzLm8gPSBvO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgSW5uZXJPYnNlcnZlci5wcm90b3R5cGUub25OZXh0ID0gbm9vcDtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vLm9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLm9uQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTsgfTtcbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBJZ25vcmVFbGVtZW50c09ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIElnbm9yZXMgYWxsIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgbGVhdmluZyBvbmx5IHRoZSB0ZXJtaW5hdGlvbiBtZXNzYWdlcy5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIGVtcHR5IG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBzaWduYWxzIHRlcm1pbmF0aW9uLCBzdWNjZXNzZnVsIG9yIGV4Y2VwdGlvbmFsLCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLmlnbm9yZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSWdub3JlRWxlbWVudHNPYnNlcnZhYmxlKHRoaXMpO1xuICB9O1xuXG4gIHZhciBNYXRlcmlhbGl6ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1hdGVyaWFsaXplT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbGl6ZU9ic2VydmFibGUoc291cmNlLCBmbikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNYXRlcmlhbGl6ZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgTWF0ZXJpYWxpemVPYnNlcnZlcihvKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXRlcmlhbGl6ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgTWF0ZXJpYWxpemVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTWF0ZXJpYWxpemVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplT2JzZXJ2ZXIobykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBNYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25OZXh0KHgpKSB9O1xuICAgIE1hdGVyaWFsaXplT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbk5leHQobm90aWZpY2F0aW9uQ3JlYXRlT25FcnJvcihlKSk7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcbiAgICBNYXRlcmlhbGl6ZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25OZXh0KG5vdGlmaWNhdGlvbkNyZWF0ZU9uQ29tcGxldGVkKCkpOyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gTWF0ZXJpYWxpemVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBNYXRlcmlhbGl6ZXMgdGhlIGltcGxpY2l0IG5vdGlmaWNhdGlvbnMgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBleHBsaWNpdCBub3RpZmljYXRpb24gdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBtYXRlcmlhbGl6ZWQgbm90aWZpY2F0aW9uIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ubWF0ZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRlcmlhbGl6ZU9ic2VydmFibGUodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICBSZXBlYXRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIHJlcGVhdCBjb3VudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc2VxdWVuY2UgcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVwZWF0Q291bnRdICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzZXF1ZW5jZS4gSWYgbm90IHByb3ZpZGVkLCByZXBlYXRzIHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBUaGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSBwcm9kdWNpbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzZXF1ZW5jZSByZXBlYXRlZGx5LlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIChyZXBlYXRDb3VudCkge1xuICAgIHJldHVybiBlbnVtZXJhYmxlUmVwZWF0KHRoaXMsIHJlcGVhdENvdW50KS5jb25jYXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogIFJlcGVhdHMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIG9yIHVudGlsIGl0IHN1Y2Nlc3NmdWxseSB0ZXJtaW5hdGVzLiBJZiB0aGUgcmV0cnkgY291bnQgaXMgbm90IHNwZWNpZmllZCwgaXQgcmV0cmllcyBpbmRlZmluaXRlbHkuXG4gICAqICBOb3RlIGlmIHlvdSBlbmNvdW50ZXIgYW4gZXJyb3IgYW5kIHdhbnQgaXQgdG8gcmV0cnkgb25jZSwgdGhlbiB5b3UgbXVzdCB1c2UgLnJldHJ5KDIpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHJldHJpZWQgPSByZXRyeS5yZXBlYXQoKTtcbiAgICogIHZhciByZXMgPSByZXRyaWVkID0gcmV0cnkucmVwZWF0KDIpO1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3JldHJ5Q291bnRdICBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgdGhlIHNlcXVlbmNlLiBJZiBub3QgcHJvdmlkZWQsIHJldHJ5IHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHByb2R1Y2luZyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNlcXVlbmNlIHJlcGVhdGVkbHkgdW50aWwgaXQgdGVybWluYXRlcyBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucmV0cnkgPSBmdW5jdGlvbiAocmV0cnlDb3VudCkge1xuICAgIHJldHVybiBlbnVtZXJhYmxlUmVwZWF0KHRoaXMsIHJldHJ5Q291bnQpLmNhdGNoRXJyb3IoKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAaXRlcmF0b3InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIFJldHJ5V2hlbk9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGlzcG9zYWJsZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNEaXNwb3NlZDogZmFsc2UsXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5PYnNlcnZhYmxlKHNvdXJjZSwgbm90aWZpZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fbm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFJldHJ5V2hlbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBSZXRyeVdoZW5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBleGNlcHRpb25zID0gbmV3IFN1YmplY3QoKSxcbiAgICAgICAgbm90aWZpZXIgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBoYW5kbGVkID0gdGhpcy5fbm90aWZpZXIoZXhjZXB0aW9ucyksXG4gICAgICAgIG5vdGlmaWNhdGlvbkRpc3Bvc2FibGUgPSBoYW5kbGVkLnN1YnNjcmliZShub3RpZmllcik7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zb3VyY2VbJ0BAaXRlcmF0b3InXSgpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB7IGlzRGlzcG9zZWQ6IGZhbHNlIH0sXG4gICAgICAgIGxhc3RFcnJvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShudWxsLCBmdW5jdGlvbiAoXywgcmVjdXJzZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gZS5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHtcbiAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IobGFzdEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG5ldyBCaW5hcnlEaXNwb3NhYmxlKGlubmVyLCBvdXRlcikpO1xuICAgICAgICBvdXRlci5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24oeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7XG4gICAgICAgICAgICBpbm5lci5zZXREaXNwb3NhYmxlKG5vdGlmaWVyLnN1YnNjcmliZShyZWN1cnNlLCBmdW5jdGlvbihleCkge1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZXhjZXB0aW9ucy5vbk5leHQoZXhuKTtcbiAgICAgICAgICAgIG91dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvLm9uQ29tcGxldGVkKCk7IH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IE5BcnlEaXNwb3NhYmxlKFtub3RpZmljYXRpb25EaXNwb3NhYmxlLCBzdWJzY3JpcHRpb24sIGNhbmNlbGFibGUsIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXRyeVdoZW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgb2JzZXJ2YWJsZVByb3RvLnJldHJ5V2hlbiA9IGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgIHJldHVybiBuZXcgUmV0cnlXaGVuT2JzZXJ2YWJsZShyZXBlYXQodGhpcyksIG5vdGlmaWVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAaXRlcmF0b3InOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIFJlcGVhdFdoZW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURpc3Bvc2FibGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVwZWF0V2hlbk9ic2VydmFibGUoc291cmNlLCBub3RpZmllcikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoUmVwZWF0V2hlbk9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBSZXBlYXRXaGVuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgY29tcGxldGlvbnMgPSBuZXcgU3ViamVjdCgpLFxuICAgICAgICBub3RpZmllciA9IG5ldyBTdWJqZWN0KCksXG4gICAgICAgIGhhbmRsZWQgPSB0aGlzLl9ub3RpZmllcihjb21wbGV0aW9ucyksXG4gICAgICAgIG5vdGlmaWNhdGlvbkRpc3Bvc2FibGUgPSBoYW5kbGVkLnN1YnNjcmliZShub3RpZmllcik7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zb3VyY2VbJ0BAaXRlcmF0b3InXSgpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB7IGlzRGlzcG9zZWQ6IGZhbHNlIH0sXG4gICAgICAgIGxhc3RFcnJvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcbiAgICAgIHZhciBjYW5jZWxhYmxlID0gY3VycmVudFRocmVhZFNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZShudWxsLCBmdW5jdGlvbiAoXywgcmVjdXJzZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gZS5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmRvbmUpIHtcbiAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBvLm9uRXJyb3IobGFzdEVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwcm9taXNlXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50SXRlbS52YWx1ZTtcbiAgICAgICAgaXNQcm9taXNlKGN1cnJlbnRWYWx1ZSkgJiYgKGN1cnJlbnRWYWx1ZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShjdXJyZW50VmFsdWUpKTtcblxuICAgICAgICB2YXIgb3V0ZXIgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgdmFyIGlubmVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG5ldyBCaW5hcnlEaXNwb3NhYmxlKGlubmVyLCBvdXRlcikpO1xuICAgICAgICBvdXRlci5zZXREaXNwb3NhYmxlKGN1cnJlbnRWYWx1ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24oeCkgeyBvLm9uTmV4dCh4KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXhuKSB7IG8ub25FcnJvcihleG4pOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5uZXIuc2V0RGlzcG9zYWJsZShub3RpZmllci5zdWJzY3JpYmUocmVjdXJzZSwgZnVuY3Rpb24oZXgpIHtcbiAgICAgICAgICAgICAgby5vbkVycm9yKGV4KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNvbXBsZXRpb25zLm9uTmV4dChudWxsKTtcbiAgICAgICAgICAgIG91dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBOQXJ5RGlzcG9zYWJsZShbbm90aWZpY2F0aW9uRGlzcG9zYWJsZSwgc3Vic2NyaXB0aW9uLCBjYW5jZWxhYmxlLCBjcmVhdGVEaXNwb3NhYmxlKHN0YXRlKV0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0V2hlbk9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBvYnNlcnZhYmxlUHJvdG8ucmVwZWF0V2hlbiA9IGZ1bmN0aW9uIChub3RpZmllcikge1xuICAgIHJldHVybiBuZXcgUmVwZWF0V2hlbk9ic2VydmFibGUocmVwZWF0KHRoaXMpLCBub3RpZmllcik7XG4gIH07XG5cbiAgdmFyIFNjYW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNjYW5PYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNjYW5PYnNlcnZhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIGhhc1NlZWQsIHNlZWQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTY2FuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNjYW5PYnNlcnZlcihvLHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjYW5PYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNjYW5PYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2Nhbk9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNjYW5PYnNlcnZlcihvLCBwYXJlbnQpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fcCA9IHBhcmVudDtcbiAgICAgIHRoaXMuX2ZuID0gcGFyZW50LmFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5faHMgPSBwYXJlbnQuaGFzU2VlZDtcbiAgICAgIHRoaXMuX3MgPSBwYXJlbnQuc2VlZDtcbiAgICAgIHRoaXMuX2hhID0gZmFsc2U7XG4gICAgICB0aGlzLl9hID0gbnVsbDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pID0gMDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNjYW5PYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAhdGhpcy5faHYgJiYgKHRoaXMuX2h2ID0gdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5faGEpIHtcbiAgICAgICAgdGhpcy5fYSA9IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9hLCB4LCB0aGlzLl9pLCB0aGlzLl9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2EgPSB0aGlzLl9ocyA/IHRyeUNhdGNoKHRoaXMuX2ZuKSh0aGlzLl9zLCB4LCB0aGlzLl9pLCB0aGlzLl9wKSA6IHg7XG4gICAgICAgIHRoaXMuX2hhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX2EuZSk7IH1cbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX2EpO1xuICAgICAgdGhpcy5faSsrO1xuICAgIH07XG5cbiAgICBTY2FuT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgU2Nhbk9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAhdGhpcy5faHYgJiYgdGhpcy5faHMgJiYgdGhpcy5fby5vbk5leHQodGhpcy5fcyk7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2FuT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAqICBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgcmV0dXJucyBlYWNoIGludGVybWVkaWF0ZSByZXN1bHQuIFRoZSBvcHRpb25hbCBzZWVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICogIEZvciBhZ2dyZWdhdGlvbiBiZWhhdmlvciB3aXRoIG5vIGludGVybWVkaWF0ZSByZXN1bHRzLCBzZWUgT2JzZXJ2YWJsZS5hZ2dyZWdhdGUuXG4gICogQHBhcmFtIHtNaXhlZH0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdG9yIEFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50LlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIGFjY3VtdWxhdGVkIHZhbHVlcy5cbiAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNjYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZSwgc2VlZCwgYWNjdW11bGF0b3IgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgICAgc2VlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTY2FuT2JzZXJ2YWJsZSh0aGlzLCBhY2N1bXVsYXRvciwgaGFzU2VlZCwgc2VlZCk7XG4gIH07XG5cbiAgdmFyIFNraXBMYXN0T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0T2JzZXJ2YWJsZShzb3VyY2UsIGMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcExhc3RPYnNlcnZlcihvLCB0aGlzLl9jKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwTGFzdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcExhc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcExhc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwTGFzdE9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkpO1xuICAgIH07XG5cbiAgICBTa2lwTGFzdE9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFNraXBMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNraXBMYXN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgQnlwYXNzZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgdGhlIGZpcnN0IGBjb3VudGAgZWxlbWVudHMuIEFzIG1vcmUgZWxlbWVudHMgYXJlXG4gICAqICByZWNlaXZlZCwgZWxlbWVudHMgYXJlIHRha2VuIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZC5cbiAgICogQHBhcmFtIGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byBieXBhc3MgYXQgdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBzb3VyY2Ugc2VxdWVuY2UgZWxlbWVudHMgZXhjZXB0IGZvciB0aGUgYnlwYXNzZWQgb25lcyBhdCB0aGUgZW5kLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBMYXN0ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgU2tpcExhc3RPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICAvKipcbiAgICogIFByZXBlbmRzIGEgc2VxdWVuY2Ugb2YgdmFsdWVzIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCBhbiBvcHRpb25hbCBzY2hlZHVsZXIgYW5kIGFuIGFyZ3VtZW50IGxpc3Qgb2YgdmFsdWVzIHRvIHByZXBlbmQuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5zdGFydFdpdGgoMSwgMiwgMyk7XG4gICAqICB2YXIgcmVzID0gc291cmNlLnN0YXJ0V2l0aChSeC5TY2hlZHVsZXIudGltZW91dCwgMSwgMiwgMyk7XG4gICAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmdzIFRoZSBzcGVjaWZpZWQgdmFsdWVzIHRvIHByZXBlbmQgdG8gdGhlIG9ic2VydmFibGUgc2VxdWVuY2VcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBzb3VyY2Ugc2VxdWVuY2UgcHJlcGVuZGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc3RhcnRXaXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMsIHNjaGVkdWxlciwgc3RhcnQgPSAwO1xuICAgIGlmICghIWFyZ3VtZW50cy5sZW5ndGggJiYgaXNTY2hlZHVsZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZXIgPSBpbW1lZGlhdGVTY2hlZHVsZXI7XG4gICAgfVxuICAgIGZvcih2YXIgYXJncyA9IFtdLCBpID0gc3RhcnQsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTsgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlQ29uY2F0LmFwcGx5KG51bGwsIFtvYnNlcnZhYmxlRnJvbUFycmF5KGFyZ3MsIHNjaGVkdWxlciksIHRoaXNdKTtcbiAgfTtcblxuICB2YXIgVGFrZUxhc3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZUxhc3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdE9ic2VydmVyKG8sIGMpIHtcbiAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlTGFzdE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3EucHVzaCh4KTtcbiAgICAgIHRoaXMuX3EubGVuZ3RoID4gdGhpcy5fYyAmJiB0aGlzLl9xLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVGFrZUxhc3RPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMuX3EubGVuZ3RoID4gMCkgeyB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkpOyB9XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlTGFzdE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJldHVybnMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNvbnRpZ3VvdXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIGJ1ZmZlciB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyBjb3VudCBlbGVtZW50cy4gVXBvbiBjb21wbGV0aW9uIG9mXG4gICAqICB0aGUgc291cmNlIHNlcXVlbmNlLCB0aGlzIGJ1ZmZlciBpcyBkcmFpbmVkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBkZWxheWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8udGFrZUxhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPCAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RPYnNlcnZlcihvLCBjb3VudCkpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RCdWZmZXJPYnNlcnZlcihvLCBjKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2MgPSBjO1xuICAgICAgdGhpcy5fcSA9IFtdO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGFrZUxhc3RCdWZmZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9xLnB1c2goeCk7XG4gICAgICB0aGlzLl9xLmxlbmd0aCA+IHRoaXMuX2MgJiYgdGhpcy5fcS5zaGlmdCgpO1xuICAgIH07XG5cbiAgICBUYWtlTGFzdEJ1ZmZlck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9vLm9uRXJyb3IoZSk7XG4gICAgfTtcblxuICAgIFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3EpO1xuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZUxhc3RCdWZmZXJPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgYnVmZmVyIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGNvdW50IGVsZW1lbnRzLiBVcG9uIGNvbXBsZXRpb24gb2YgdGhlXG4gICAqICBzb3VyY2Ugc2VxdWVuY2UsIHRoaXMgYnVmZmVyIGlzIHByb2R1Y2VkIG9uIHRoZSByZXN1bHQgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZSBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyBhIHNpbmdsZSBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VMYXN0QnVmZmVyID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIobywgY291bnQpKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gZWxlbWVudCBjb3VudCBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IExlbmd0aCBvZiBlYWNoIHdpbmRvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIHdpbmRvd3MuIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBjb3VudC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2Ygd2luZG93cy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by53aW5kb3dXaXRoQ291bnQgPSBvYnNlcnZhYmxlUHJvdG8ud2luZG93Q291bnQgPSBmdW5jdGlvbiAoY291bnQsIHNraXApIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICArY291bnQgfHwgKGNvdW50ID0gMCk7XG4gICAgTWF0aC5hYnMoY291bnQpID09PSBJbmZpbml0eSAmJiAoY291bnQgPSAwKTtcbiAgICBpZiAoY291bnQgPD0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHNraXAgPT0gbnVsbCAmJiAoc2tpcCA9IGNvdW50KTtcbiAgICArc2tpcCB8fCAoc2tpcCA9IDApO1xuICAgIE1hdGguYWJzKHNraXApID09PSBJbmZpbml0eSAmJiAoc2tpcCA9IDApO1xuXG4gICAgaWYgKHNraXAgPD0gMCkgeyB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBtID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCksXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUobSksXG4gICAgICAgIG4gPSAwLFxuICAgICAgICBxID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyAoKSB7XG4gICAgICAgIHZhciBzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgcS5wdXNoKHMpO1xuICAgICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHMsIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVXaW5kb3coKTtcblxuICAgICAgbS5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgcVtpXS5vbk5leHQoeCk7IH1cbiAgICAgICAgICB2YXIgYyA9IG4gLSBjb3VudCArIDE7XG4gICAgICAgICAgYyA+PSAwICYmIGMgJSBza2lwID09PSAwICYmIHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICsrbiAlIHNraXAgPT09IDAgJiYgY3JlYXRlV2luZG93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkgeyBxLnNoaWZ0KCkub25FcnJvcihlKTsgfVxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7IHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpOyB9XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgICByZXR1cm4gcmVmQ291bnREaXNwb3NhYmxlO1xuICAgIH0sIHNvdXJjZSk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwQ29uY2F0ID0gb2JzZXJ2YWJsZVByb3RvLmNvbmNhdE1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5tZXJnZSgxKTtcbn07XG4gIC8qKlxuICAgKiBQcm9qZWN0cyBlYWNoIG5vdGlmaWNhdGlvbiBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYW5kIGNvbmNhdHMgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHNlcXVlbmNlcyBpbnRvIG9uZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbk5leHQgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50OyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHdoZW4gYW4gZXJyb3Igb2NjdXJzIGluIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGVkIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHdoZW4gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlIGlzIHJlYWNoZWQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgXCJ0aGlzXCIgdG8gdXNlIHRvIGludm9rZSBlYWNoIHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgYXJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIG9uZS10by1tYW55IHRyYW5zZm9ybSBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggbm90aWZpY2F0aW9uIGluIHRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5jb25jYXRNYXBPYnNlcnZlciA9IG9ic2VydmFibGVQcm90by5zZWxlY3RDb25jYXRPYnNlcnZlciA9IGZ1bmN0aW9uKG9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZWQsIHRoaXNBcmcpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcyxcbiAgICAgICAgb25OZXh0RnVuYyA9IGJpbmRDYWxsYmFjayhvbk5leHQsIHRoaXNBcmcsIDIpLFxuICAgICAgICBvbkVycm9yRnVuYyA9IGJpbmRDYWxsYmFjayhvbkVycm9yLCB0aGlzQXJnLCAxKSxcbiAgICAgICAgb25Db21wbGV0ZWRGdW5jID0gYmluZENhbGxiYWNrKG9uQ29tcGxldGVkLCB0aGlzQXJnLCAwKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25OZXh0RnVuYyh4LCBpbmRleCsrKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25FcnJvckZ1bmMoZXJyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvbkNvbXBsZXRlZEZ1bmMoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1Byb21pc2UocmVzdWx0KSAmJiAocmVzdWx0ID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKHJlc3VsdCkpO1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dChyZXN1bHQpO1xuICAgICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpLmNvbmNhdEFsbCgpO1xuICB9O1xuXG4gIHZhciBEZWZhdWx0SWZFbXB0eU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWZhdWx0SWZFbXB0eU9ic2VydmVyLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIobywgZCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX2YgPSBmYWxzZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy5fZiA9IHRydWU7XG4gICAgICB0aGlzLl9vLm9uTmV4dCh4KTtcbiAgICB9O1xuXG4gICAgRGVmYXVsdElmRW1wdHlPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBEZWZhdWx0SWZFbXB0eU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAhdGhpcy5fZiAmJiB0aGlzLl9vLm9uTmV4dCh0aGlzLl9kKTtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIHNwZWNpZmllZCBzZXF1ZW5jZSBvciB0aGUgc3BlY2lmaWVkIHZhbHVlIGluIGEgc2luZ2xldG9uIHNlcXVlbmNlIGlmIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS5cbiAgICpcbiAgICogIHZhciByZXMgPSBvYnMgPSB4cy5kZWZhdWx0SWZFbXB0eSgpO1xuICAgKiAgMiAtIG9icyA9IHhzLmRlZmF1bHRJZkVtcHR5KGZhbHNlKTtcbiAgICpcbiAgICogQG1lbWJlck9mIE9ic2VydmFibGUjXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuIElmIG5vdCBwcm92aWRlZCwgdGhpcyBkZWZhdWx0cyB0byBudWxsLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgc291cmNlIGlzIGVtcHR5OyBvdGhlcndpc2UsIHRoZSBlbGVtZW50cyBvZiB0aGUgc291cmNlIGl0c2VsZi5cbiAgICovXG4gICAgb2JzZXJ2YWJsZVByb3RvLmRlZmF1bHRJZkVtcHR5ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgICBkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCAmJiAoZGVmYXVsdFZhbHVlID0gbnVsbCk7XG4gICAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIobywgZGVmYXVsdFZhbHVlKSk7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH07XG5cbiAgLy8gU3dhcCBvdXQgZm9yIEFycmF5LmZpbmRJbmRleFxuICBmdW5jdGlvbiBhcnJheUluZGV4T2ZDb21wYXJlcihhcnJheSwgaXRlbSwgY29tcGFyZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjb21wYXJlcihhcnJheVtpXSwgaXRlbSkpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gSGFzaFNldChjb21wYXJlcikge1xuICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICB0aGlzLnNldCA9IFtdO1xuICB9XG4gIEhhc2hTZXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXRWYWx1ZSA9IGFycmF5SW5kZXhPZkNvbXBhcmVyKHRoaXMuc2V0LCB2YWx1ZSwgdGhpcy5jb21wYXJlcikgPT09IC0xO1xuICAgIHJldFZhbHVlICYmIHRoaXMuc2V0LnB1c2godmFsdWUpO1xuICAgIHJldHVybiByZXRWYWx1ZTtcbiAgfTtcblxuICB2YXIgRGlzdGluY3RPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEaXN0aW5jdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RPYnNlcnZhYmxlKHNvdXJjZSwga2V5Rm4sIGNtcEZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2tleUZuID0ga2V5Rm47XG4gICAgICB0aGlzLl9jbXBGbiA9IGNtcEZuO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRGlzdGluY3RPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0T2JzZXJ2ZXIobywgdGhpcy5fa2V5Rm4sIHRoaXMuX2NtcEZuKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBEaXN0aW5jdE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRGlzdGluY3RPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGlzdGluY3RPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdE9ic2VydmVyKG8sIGtleUZuLCBjbXBGbikge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9rZXlGbiA9IGtleUZuO1xuICAgICAgdGhpcy5faCA9IG5ldyBIYXNoU2V0KGNtcEZuKTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERpc3RpbmN0T2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIGtleSA9IHg7XG4gICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9rZXlGbikpIHtcbiAgICAgICAga2V5ID0gdHJ5Q2F0Y2godGhpcy5fa2V5Rm4pKHgpO1xuICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKGtleS5lKTsgfVxuICAgICAgfVxuICAgICAgdGhpcy5faC5wdXNoKGtleSkgJiYgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIERpc3RpbmN0T2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIERpc3RpbmN0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIERpc3RpbmN0T2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgb25seSBkaXN0aW5jdCBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGtleVNlbGVjdG9yIGFuZCB0aGUgY29tcGFyZXIuXG4gICAqICBVc2FnZSBvZiB0aGlzIG9wZXJhdG9yIHNob3VsZCBiZSBjb25zaWRlcmVkIGNhcmVmdWxseSBkdWUgdG8gdGhlIG1haW50ZW5hbmNlIG9mIGFuIGludGVybmFsIGxvb2t1cCBzdHJ1Y3R1cmUgd2hpY2ggY2FuIGdyb3cgbGFyZ2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICB2YXIgcmVzID0gb2JzID0geHMuZGlzdGluY3QoKTtcbiAgICogIDIgLSBvYnMgPSB4cy5kaXN0aW5jdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSk7XG4gICAqICAyIC0gb2JzID0geHMuZGlzdGluY3QoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0sIGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEgPT09IGI7IH0pO1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBba2V5U2VsZWN0b3JdICBBIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbXBhcmlzb24ga2V5IGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gIFVzZWQgdG8gY29tcGFyZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb25seSBjb250YWluaW5nIHRoZSBkaXN0aW5jdCBlbGVtZW50cywgYmFzZWQgb24gYSBjb21wdXRlZCBrZXkgdmFsdWUsIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kaXN0aW5jdCA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgY29tcGFyZXIpIHtcbiAgICBjb21wYXJlciB8fCAoY29tcGFyZXIgPSBkZWZhdWx0Q29tcGFyZXIpO1xuICAgIHJldHVybiBuZXcgRGlzdGluY3RPYnNlcnZhYmxlKHRoaXMsIGtleVNlbGVjdG9yLCBjb21wYXJlcik7XG4gIH07XG5cbiAgdmFyIE1hcE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKE1hcE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBNYXBPYnNlcnZhYmxlKHNvdXJjZSwgc2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IGJpbmRDYWxsYmFjayhzZWxlY3RvciwgdGhpc0FyZywgMyk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbm5lck1hcChzZWxlY3Rvciwgc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBpLCBvKSB7IHJldHVybiBzZWxlY3Rvci5jYWxsKHRoaXMsIHNlbGYuc2VsZWN0b3IoeCwgaSwgbyksIGksIG8pOyB9O1xuICAgIH1cblxuICAgIE1hcE9ic2VydmFibGUucHJvdG90eXBlLmludGVybmFsTWFwID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcE9ic2VydmFibGUodGhpcy5zb3VyY2UsIGlubmVyTWFwKHNlbGVjdG9yLCB0aGlzKSwgdGhpc0FyZyk7XG4gICAgfTtcblxuICAgIE1hcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgSW5uZXJPYnNlcnZlcihvLCB0aGlzLnNlbGVjdG9yLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgc2VsZWN0b3IsIHNvdXJjZSkge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuc2VsZWN0b3IpKHgsIHRoaXMuaSsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5vLm9uRXJyb3IocmVzdWx0LmUpOyB9XG4gICAgICB0aGlzLm8ub25OZXh0KHJlc3VsdCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcE9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gYSBuZXcgZm9ybSBieSBpbmNvcnBvcmF0aW5nIHRoZSBlbGVtZW50J3MgaW5kZXguXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgQSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBzb3VyY2UgZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyBhcmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBzb3VyY2UuXG4gICovXG4gIG9ic2VydmFibGVQcm90by5tYXAgPSBvYnNlcnZhYmxlUHJvdG8uc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNlbGVjdG9yRm4gPSB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RvciA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yOyB9O1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgTWFwT2JzZXJ2YWJsZSA/XG4gICAgICB0aGlzLmludGVybmFsTWFwKHNlbGVjdG9yRm4sIHRoaXNBcmcpIDpcbiAgICAgIG5ldyBNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yRm4sIHRoaXNBcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBsdWNrZXIoYXJncywgbGVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcHBlcih4KSB7XG4gICAgICB2YXIgY3VycmVudFByb3AgPSB4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IGN1cnJlbnRQcm9wW2FyZ3NbaV1dO1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3VycmVudFByb3AgPSBwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50UHJvcDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluXG4gICAqIHRoZSBPYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0FyZ3VtZW50c30gYXJndW1lbnRzIFRoZSBuZXN0ZWQgcHJvcGVydGllcyB0byBwbHVjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ucGx1Y2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBpZiAobGVuID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignTGlzdCBvZiBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBlbXB0eS4nKTsgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgcmV0dXJuIHRoaXMubWFwKHBsdWNrZXIoYXJncywgbGVuKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGVhY2ggbm90aWZpY2F0aW9uIG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhbmQgbWVyZ2VzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW50byBvbmUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25OZXh0IEEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZWxlbWVudDsgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgdGhlIGZ1bmN0aW9uIHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlZCBBIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB3aGVuIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZSBpcyByZWFjaGVkLlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIFwidGhpc1wiIHRvIHVzZSB0byBpbnZva2UgZWFjaCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIGFyZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBvbmUtdG8tbWFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byBlYWNoIG5vdGlmaWNhdGlvbiBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uZmxhdE1hcE9ic2VydmVyID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnlPYnNlcnZlciA9IGZ1bmN0aW9uIChvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGVkLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb25OZXh0LmNhbGwodGhpc0FyZywgeCwgaW5kZXgrKyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uRXJyb3IuY2FsbCh0aGlzQXJnLCBlcnIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzUHJvbWlzZShyZXN1bHQpICYmIChyZXN1bHQgPSBvYnNlcnZhYmxlRnJvbVByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KHJlc3VsdCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9uQ29tcGxldGVkLmNhbGwodGhpc0FyZyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNQcm9taXNlKHJlc3VsdCkgJiYgKHJlc3VsdCA9IG9ic2VydmFibGVGcm9tUHJvbWlzZShyZXN1bHQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQocmVzdWx0KTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9LCBzb3VyY2UpLm1lcmdlQWxsKCk7XG4gIH07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwID0gb2JzZXJ2YWJsZVByb3RvLnNlbGVjdE1hbnkgPSBvYnNlcnZhYmxlUHJvdG8ubWVyZ2VNYXAgPSBmdW5jdGlvbihzZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRNYXBPYnNlcnZhYmxlKHRoaXMsIHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykubWVyZ2VBbGwoKTtcbn07XG5cbm9ic2VydmFibGVQcm90by5mbGF0TWFwTGF0ZXN0ID0gb2JzZXJ2YWJsZVByb3RvLnN3aXRjaE1hcCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgdGhpc0FyZykge1xuICAgIHJldHVybiBuZXcgRmxhdE1hcE9ic2VydmFibGUodGhpcywgc2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCB0aGlzQXJnKS5zd2l0Y2hMYXRlc3QoKTtcbn07XG5cbiAgdmFyIFNraXBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBPYnNlcnZhYmxlKHNvdXJjZSwgY291bnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBPYnNlcnZlcihvLCB0aGlzLl9jb3VudCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBTa2lwT2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9yID0gYztcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhTa2lwT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuXG4gICAgU2tpcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh0aGlzLl9yIDw9IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yLS07XG4gICAgICB9XG4gICAgfTtcbiAgICBTa2lwT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbigpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqIEJ5cGFzc2VzIGEgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFuZCB0aGVuIHJldHVybnMgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIHRoYXQgb2NjdXIgYWZ0ZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpbiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICByZXR1cm4gbmV3IFNraXBPYnNlcnZhYmxlKHRoaXMsIGNvdW50KTtcbiAgfTtcblxuICB2YXIgU2tpcFdoaWxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdoaWxlT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPYnNlcnZhYmxlKHNvdXJjZSwgZm4pIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBXaGlsZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdoaWxlT2JzZXJ2ZXIobywgdGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFdoaWxlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwV2hpbGVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdoaWxlT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgdGhpcy5faSA9IDA7XG4gICAgICB0aGlzLl9yID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXRoaXMuX3IpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3AuX2ZuKSh4LCB0aGlzLl9pKyssIHRoaXMuX3ApO1xuICAgICAgICBpZiAocmVzID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHJlcy5lKTsgfVxuICAgICAgICB0aGlzLl9yID0gIXJlcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3IgJiYgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgfTtcbiAgICBTa2lwV2hpbGVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgU2tpcFdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBXaGlsZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIEJ5cGFzc2VzIGVsZW1lbnRzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYXMgbG9uZyBhcyBhIHNwZWNpZmllZCBjb25kaXRpb24gaXMgdHJ1ZSBhbmQgdGhlbiByZXR1cm5zIHRoZSByZW1haW5pbmcgZWxlbWVudHMuXG4gICAqICBUaGUgZWxlbWVudCdzIGluZGV4IGlzIHVzZWQgaW4gdGhlIGxvZ2ljIG9mIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqICB2YXIgcmVzID0gc291cmNlLnNraXBXaGlsZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlIDwgMTA7IH0pO1xuICAgKiAgdmFyIHJlcyA9IHNvdXJjZS5za2lwV2hpbGUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gdmFsdWUgPCAxMCB8fCBpbmRleCA8IDEwOyB9KTtcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0FueX0gW3RoaXNBcmddIE9iamVjdCB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2Ugc3RhcnRpbmcgYXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpbmVhciBzZXJpZXMgdGhhdCBkb2VzIG5vdCBwYXNzIHRoZSB0ZXN0IHNwZWNpZmllZCBieSBwcmVkaWNhdGUuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uc2tpcFdoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBmbiA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgIHJldHVybiBuZXcgU2tpcFdoaWxlT2JzZXJ2YWJsZSh0aGlzLCBmbik7XG4gIH07XG5cbiAgdmFyIFRha2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRha2VPYnNlcnZhYmxlKHNvdXJjZSwgY291bnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VPYnNlcnZlcihvLCB0aGlzLl9jb3VudCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBUYWtlT2JzZXJ2ZXIobywgYykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHRoaXMuX3IgPSBjO1xuICAgICAgQWJzdHJhY3RPYnNlcnZlci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGluaGVyaXRzKFRha2VPYnNlcnZlciwgQWJzdHJhY3RPYnNlcnZlcik7XG5cbiAgICBUYWtlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHRoaXMuX3ItLSA+IDApIHtcbiAgICAgICAgdGhpcy5fby5vbk5leHQoeCk7XG4gICAgICAgIHRoaXMuX3IgPD0gMCAmJiB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRha2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGFrZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUYWtlT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIHNwZWNpZmllZCBudW1iZXIgb2YgY29udGlndW91cyBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciBmb3IgdGhlIGVkZ2UgY2FzZSBvZiB0YWtlKDApLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgdXNlZCB0byBwcm9kdWNlIGFuIE9uQ29tcGxldGVkIG1lc3NhZ2UgaW4gY2FzZSA8cGFyYW1yZWYgbmFtZT1cImNvdW50IGNvdW50PC9wYXJhbXJlZj4gaXMgc2V0IHRvIDAuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2UgPSBmdW5jdGlvbiAoY291bnQsIHNjaGVkdWxlcikge1xuICAgIGlmIChjb3VudCA8IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cbiAgICBpZiAoY291bnQgPT09IDApIHsgcmV0dXJuIG9ic2VydmFibGVFbXB0eShzY2hlZHVsZXIpOyB9XG4gICAgcmV0dXJuIG5ldyBUYWtlT2JzZXJ2YWJsZSh0aGlzLCBjb3VudCk7XG4gIH07XG5cbiAgdmFyIFRha2VXaGlsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaGlsZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT2JzZXJ2YWJsZShzb3VyY2UsIGZuKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlV2hpbGVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VXaGlsZU9ic2VydmVyKG8sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VXaGlsZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGFrZVdoaWxlT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VXaGlsZU9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIHRoaXMuX2kgPSAwO1xuICAgICAgdGhpcy5fciA9IHRydWU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlV2hpbGVPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAodGhpcy5fcikge1xuICAgICAgICB0aGlzLl9yID0gdHJ5Q2F0Y2godGhpcy5fcC5fZm4pKHgsIHRoaXMuX2krKywgdGhpcy5fcCk7XG4gICAgICAgIGlmICh0aGlzLl9yID09PSBlcnJvck9iaikgeyByZXR1cm4gdGhpcy5fby5vbkVycm9yKHRoaXMuX3IuZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgVGFrZVdoaWxlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFRha2VXaGlsZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUYWtlV2hpbGVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGVsZW1lbnRzIGZyb20gYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBhcyBsb25nIGFzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbiBpcyB0cnVlLlxuICAgKiAgVGhlIGVsZW1lbnQncyBpbmRleCBpcyB1c2VkIGluIHRoZSBsb2dpYyBvZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBmb3IgYSBjb25kaXRpb247IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBzZXF1ZW5jZSB0aGF0IG9jY3VyIGJlZm9yZSB0aGUgZWxlbWVudCBhdCB3aGljaCB0aGUgdGVzdCBubyBsb25nZXIgcGFzc2VzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm4gPSBiaW5kQ2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICByZXR1cm4gbmV3IFRha2VXaGlsZU9ic2VydmFibGUodGhpcywgZm4pO1xuICB9O1xuXG4gIHZhciBGaWx0ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhGaWx0ZXJPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gRmlsdGVyT2JzZXJ2YWJsZShzb3VyY2UsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgRmlsdGVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBJbm5lck9ic2VydmVyKG8sIHRoaXMucHJlZGljYXRlLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlubmVyUHJlZGljYXRlKHByZWRpY2F0ZSwgc2VsZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgsIGksIG8pIHsgcmV0dXJuIHNlbGYucHJlZGljYXRlKHgsIGksIG8pICYmIHByZWRpY2F0ZS5jYWxsKHRoaXMsIHgsIGksIG8pOyB9XG4gICAgfVxuXG4gICAgRmlsdGVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW50ZXJuYWxGaWx0ZXIgPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBuZXcgRmlsdGVyT2JzZXJ2YWJsZSh0aGlzLnNvdXJjZSwgaW5uZXJQcmVkaWNhdGUocHJlZGljYXRlLCB0aGlzKSwgdGhpc0FyZyk7XG4gICAgfTtcblxuICAgIGluaGVyaXRzKElubmVyT2JzZXJ2ZXIsIEFic3RyYWN0T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyT2JzZXJ2ZXIobywgcHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5pID0gMDtcbiAgICAgIEFic3RyYWN0T2JzZXJ2ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHNob3VsZFlpZWxkID0gdHJ5Q2F0Y2godGhpcy5wcmVkaWNhdGUpKHgsIHRoaXMuaSsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICBpZiAoc2hvdWxkWWllbGQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm8ub25FcnJvcihzaG91bGRZaWVsZC5lKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFlpZWxkICYmIHRoaXMuby5vbk5leHQoeCk7XG4gICAgfTtcblxuICAgIElubmVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuby5vbkVycm9yKGUpO1xuICAgIH07XG5cbiAgICBJbm5lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm8ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbHRlck9ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAqICBGaWx0ZXJzIHRoZSBlbGVtZW50cyBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJhc2VkIG9uIGEgcHJlZGljYXRlIGJ5IGluY29ycG9yYXRpbmcgdGhlIGVsZW1lbnQncyBpbmRleC5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggc291cmNlIGVsZW1lbnQgZm9yIGEgY29uZGl0aW9uOyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBlbGVtZW50LlxuICAqIEBwYXJhbSB7QW55fSBbdGhpc0FyZ10gT2JqZWN0IHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgc2VxdWVuY2UgdGhhdCBzYXRpc2Z5IHRoZSBjb25kaXRpb24uXG4gICovXG4gIG9ic2VydmFibGVQcm90by5maWx0ZXIgPSBvYnNlcnZhYmxlUHJvdG8ud2hlcmUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBGaWx0ZXJPYnNlcnZhYmxlID8gdGhpcy5pbnRlcm5hbEZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIDpcbiAgICAgIG5ldyBGaWx0ZXJPYnNlcnZhYmxlKHRoaXMsIHByZWRpY2F0ZSwgdGhpc0FyZyk7XG4gIH07XG5cbiAgdmFyIFRyYW5zZHVjZU9ic2VydmVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUcmFuc2R1Y2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUcmFuc2R1Y2VPYnNlcnZlcihvLCB4Zm9ybSkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl94Zm9ybSA9IHhmb3JtO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVHJhbnNkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlcyA9IHRyeUNhdGNoKHRoaXMuX3hmb3JtWydAQHRyYW5zZHVjZXIvc3RlcCddKS5jYWxsKHRoaXMuX3hmb3JtLCB0aGlzLl9vLCB4KTtcbiAgICAgIGlmIChyZXMgPT09IGVycm9yT2JqKSB7IHRoaXMuX28ub25FcnJvcihyZXMuZSk7IH1cbiAgICB9O1xuXG4gICAgVHJhbnNkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuXG4gICAgVHJhbnNkdWNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3hmb3JtWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy5fbyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmFuc2R1Y2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtRm9yT2JzZXJ2ZXIobykge1xuICAgIHJldHVybiB7XG4gICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LFxuICAgICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24ob2JzLCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gb2JzLm9uTmV4dChpbnB1dCk7XG4gICAgICB9LFxuICAgICAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBmdW5jdGlvbihvYnMpIHtcbiAgICAgICAgcmV0dXJuIG9icy5vbkNvbXBsZXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSB0cmFuc2R1Y2VyIHRvIHRyYW5zZm9ybSB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZVxuICAgKiBAcGFyYW0ge1RyYW5zZHVjZXJ9IHRyYW5zZHVjZXIgQSB0cmFuc2R1Y2VyIHRvIGV4ZWN1dGVcbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgcmVzdWx0cyBmcm9tIHRoZSB0cmFuc2R1Y2VyLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRyYW5zZHVjZSA9IGZ1bmN0aW9uKHRyYW5zZHVjZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24obykge1xuICAgICAgdmFyIHhmb3JtID0gdHJhbnNkdWNlcih0cmFuc2Zvcm1Gb3JPYnNlcnZlcihvKSk7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVHJhbnNkdWNlT2JzZXJ2ZXIobywgeGZvcm0pKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBBbm9ueW1vdXNPYnNlcnZhYmxlID0gUnguQW5vbnltb3VzT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQW5vbnltb3VzT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIC8vIEZpeCBzdWJzY3JpYmVyIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb3IgZnVuY3Rpb24gcmV0dXJuZWQgdG8gZGVjb3JhdGUgYXMgRGlzcG9zYWJsZVxuICAgIGZ1bmN0aW9uIGZpeFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIgJiYgaXNGdW5jdGlvbihzdWJzY3JpYmVyLmRpc3Bvc2UpID8gc3Vic2NyaWJlciA6XG4gICAgICAgIGlzRnVuY3Rpb24oc3Vic2NyaWJlcikgPyBkaXNwb3NhYmxlQ3JlYXRlKHN1YnNjcmliZXIpIDogZGlzcG9zYWJsZUVtcHR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldERpc3Bvc2FibGUocywgc3RhdGUpIHtcbiAgICAgIHZhciBhZG8gPSBzdGF0ZVswXSwgc2VsZiA9IHN0YXRlWzFdO1xuICAgICAgdmFyIHN1YiA9IHRyeUNhdGNoKHNlbGYuX19zdWJzY3JpYmUpLmNhbGwoc2VsZiwgYWRvKTtcbiAgICAgIGlmIChzdWIgPT09IGVycm9yT2JqICYmICFhZG8uZmFpbChlcnJvck9iai5lKSkgeyB0aHJvd2VyKGVycm9yT2JqLmUpOyB9XG4gICAgICBhZG8uc2V0RGlzcG9zYWJsZShmaXhTdWJzY3JpYmVyKHN1YikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFub255bW91c09ic2VydmFibGUoc3Vic2NyaWJlLCBwYXJlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gcGFyZW50O1xuICAgICAgdGhpcy5fX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEFub255bW91c09ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGFkbyA9IG5ldyBBdXRvRGV0YWNoT2JzZXJ2ZXIobyksIHN0YXRlID0gW2FkbywgdGhpc107XG5cbiAgICAgIGlmIChjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlUmVxdWlyZWQoKSkge1xuICAgICAgICBjdXJyZW50VGhyZWFkU2NoZWR1bGVyLnNjaGVkdWxlKHN0YXRlLCBzZXREaXNwb3NhYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldERpc3Bvc2FibGUobnVsbCwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFub255bW91c09ic2VydmFibGU7XG5cbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIEF1dG9EZXRhY2hPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQXV0b0RldGFjaE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gQXV0b0RldGFjaE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMubSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgIH1cblxuICAgIHZhciBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUgPSBBdXRvRGV0YWNoT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uTmV4dCkuY2FsbCh0aGlzLm9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhyb3dlcihyZXN1bHQuZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uRXJyb3IpLmNhbGwodGhpcy5vYnNlcnZlciwgZXJyKTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgcmVzdWx0ID09PSBlcnJvck9iaiAmJiB0aHJvd2VyKHJlc3VsdC5lKTtcbiAgICB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLm9ic2VydmVyLm9uQ29tcGxldGVkKS5jYWxsKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICByZXN1bHQgPT09IGVycm9yT2JqICYmIHRocm93ZXIocmVzdWx0LmUpO1xuICAgIH07XG5cbiAgICBBdXRvRGV0YWNoT2JzZXJ2ZXJQcm90b3R5cGUuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLm0uc2V0RGlzcG9zYWJsZSh2YWx1ZSk7IH07XG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmdldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm0uZ2V0RGlzcG9zYWJsZSgpOyB9O1xuXG4gICAgQXV0b0RldGFjaE9ic2VydmVyUHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfX3N1cGVyX18ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBdXRvRGV0YWNoT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBJbm5lclN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzLCBvKSB7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fbyA9IG87XG4gIH07XG5cbiAgSW5uZXJTdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9zLmlzRGlzcG9zZWQgJiYgdGhpcy5fbyAhPT0gbnVsbCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuX3Mub2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5fbyk7XG4gICAgICB0aGlzLl9zLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHRoaXMuX28gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIFJlcHJlc2VudHMgYW4gb2JqZWN0IHRoYXQgaXMgYm90aCBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGFzIHdlbGwgYXMgYW4gb2JzZXJ2ZXIuXG4gICAqICBFYWNoIG5vdGlmaWNhdGlvbiBpcyBicm9hZGNhc3RlZCB0byBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMuXG4gICAqL1xuICB2YXIgU3ViamVjdCA9IFJ4LlN1YmplY3QgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFN1YmplY3QsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKFN1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTdWJzY3JpcHRpb24odGhpcywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICBvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3ViamVjdCBoYXMgb2JzZXJ2ZXJzIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICovXG4gICAgICBoYXNPYnNlcnZlcnM6IGZ1bmN0aW9uICgpIHsgY2hlY2tEaXNwb3NlZCh0aGlzKTsgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7IH0sXG4gICAgICAvKipcbiAgICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIG9ic2VydmVycyBhYm91dCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAqL1xuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG9zW2ldLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSBlcnJvciBUaGUgZXhjZXB0aW9uIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvcyA9IGNsb25lQXJyYXkodGhpcy5vYnNlcnZlcnMpLCBsZW4gPSBvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb3NbaV0ub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzIGFib3V0IHRoZSBhcnJpdmFsIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VuZCB0byBhbGwgb2JzZXJ2ZXJzLlxuICAgICAgICovXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjaGVja0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvc1tpXS5vbk5leHQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zdWJzY3JpYmUgYWxsIG9ic2VydmVycyBhbmQgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICAgKi9cbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN1YmplY3QgZnJvbSB0aGUgc3BlY2lmaWVkIG9ic2VydmVyIGFuZCBvYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ9IG9ic2VydmVyIFRoZSBvYnNlcnZlciB1c2VkIHRvIHNlbmQgbWVzc2FnZXMgdG8gdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSBvYnNlcnZhYmxlIFRoZSBvYnNlcnZhYmxlIHVzZWQgdG8gc3Vic2NyaWJlIHRvIG1lc3NhZ2VzIHNlbnQgZnJvbSB0aGUgc3ViamVjdC5cbiAgICAgKiBAcmV0dXJucyB7U3ViamVjdH0gU3ViamVjdCBpbXBsZW1lbnRlZCB1c2luZyB0aGUgZ2l2ZW4gb2JzZXJ2ZXIgYW5kIG9ic2VydmFibGUuXG4gICAgICovXG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIG9ic2VydmFibGUpIHtcbiAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChvYnNlcnZlciwgb2JzZXJ2YWJsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdWJqZWN0O1xuICB9KE9ic2VydmFibGUpKTtcblxuICAvKipcbiAgICogIFJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuICAgKiAgVGhlIGxhc3QgdmFsdWUgYmVmb3JlIHRoZSBPbkNvbXBsZXRlZCBub3RpZmljYXRpb24sIG9yIHRoZSBlcnJvciByZWNlaXZlZCB0aHJvdWdoIE9uRXJyb3IsIGlzIHNlbnQgdG8gYWxsIHN1YnNjcmliZWQgb2JzZXJ2ZXJzLlxuICAgKi9cbiAgdmFyIEFzeW5jU3ViamVjdCA9IFJ4LkFzeW5jU3ViamVjdCA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoQXN5bmNTdWJqZWN0LCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN1YmplY3QgdGhhdCBjYW4gb25seSByZWNlaXZlIG9uZSB2YWx1ZSBhbmQgdGhhdCB2YWx1ZSBpcyBjYWNoZWQgZm9yIGFsbCBmdXR1cmUgb2JzZXJ2YXRpb25zLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jU3ViamVjdCgpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKEFzeW5jU3ViamVjdC5wcm90b3R5cGUsIE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgICAgX3N1YnNjcmliZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvKTtcbiAgICAgICAgICByZXR1cm4gbmV3IElubmVyU3Vic2NyaXB0aW9uKHRoaXMsIG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICBvLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgIG8ub25OZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZUVtcHR5O1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIG9ic2VydmVycyBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBvYnNlcnZlcnMgc3Vic2NyaWJlZCB0byBpdC5cbiAgICAgICAqL1xuICAgICAgaGFzT2JzZXJ2ZXJzOiBmdW5jdGlvbiAoKSB7IGNoZWNrRGlzcG9zZWQodGhpcyk7IHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGggPiAwOyB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIGFsc28gY2F1c2luZyB0aGUgbGFzdCByZWNlaXZlZCB2YWx1ZSB0byBiZSBzZW50IG91dCAoaWYgYW55KS5cbiAgICAgICAqL1xuICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGksIGxlbjtcbiAgICAgICAgY2hlY2tEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgb3MgPSBjbG9uZUFycmF5KHRoaXMub2JzZXJ2ZXJzKSwgbGVuID0gb3MubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgbyA9IG9zW2ldO1xuICAgICAgICAgICAgICBvLm9uTmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgb3NbaV0ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBvYnNlcnZlcnMgYWJvdXQgdGhlIGVycm9yLlxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZXJyb3IgVGhlIEVycm9yIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9zID0gY2xvbmVBcnJheSh0aGlzLm9ic2VydmVycyksIGxlbiA9IG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvc1tpXS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBTZW5kcyBhIHZhbHVlIHRvIHRoZSBzdWJqZWN0LiBUaGUgbGFzdCB2YWx1ZSByZWNlaXZlZCBiZWZvcmUgc3VjY2Vzc2Z1bCB0ZXJtaW5hdGlvbiB3aWxsIGJlIHNlbnQgdG8gYWxsIHN1YnNjcmliZWQgYW5kIGZ1dHVyZSBvYnNlcnZlcnMuXG4gICAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmUgaW4gdGhlIHN1YmplY3QuXG4gICAgICAgKi9cbiAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFVuc3Vic2NyaWJlIGFsbCBvYnNlcnZlcnMgYW5kIHJlbGVhc2UgcmVzb3VyY2VzLlxuICAgICAgICovXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFzeW5jU3ViamVjdDtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgdmFyIEFub255bW91c1N1YmplY3QgPSBSeC5Bbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhBbm9ueW1vdXNTdWJqZWN0LCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3Qob2JzZXJ2ZXIsIG9ic2VydmFibGUpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBhZGRQcm9wZXJ0aWVzKEFub255bW91c1N1YmplY3QucHJvdG90eXBlLCBPYnNlcnZlci5wcm90b3R5cGUsIHtcbiAgICAgIF9zdWJzY3JpYmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUuc3Vic2NyaWJlKG8pO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub25Db21wbGV0ZWQoKTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICAgIH0sXG4gICAgICBvbk5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9uTmV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbiAgfShPYnNlcnZhYmxlKSk7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgcm9vdC5SeCA9IFJ4O1xuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFJ4O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IFJ4KS5SeCA9IFJ4O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5SeCA9IFJ4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290LlJ4ID0gUng7XG4gIH1cblxuICAvLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxuICB2YXIgckVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG59LmNhbGwodGhpcykpO1xuIl0sIm5hbWVzIjpbInVuZGVmaW5lZCIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJSeCIsImludGVybmFscyIsImNvbmZpZyIsIlByb21pc2UiLCJoZWxwZXJzIiwibm9vcCIsImlkZW50aXR5IiwieCIsImRlZmF1bHROb3ciLCJEYXRlIiwibm93IiwiZGVmYXVsdENvbXBhcmVyIiwieSIsImlzRXF1YWwiLCJkZWZhdWx0U3ViQ29tcGFyZXIiLCJkZWZhdWx0S2V5U2VyaWFsaXplciIsInRvU3RyaW5nIiwiZGVmYXVsdEVycm9yIiwiZXJyIiwiaXNQcm9taXNlIiwicCIsInN1YnNjcmliZSIsInRoZW4iLCJpc0Z1bmN0aW9uIiwiaXNGbiIsImNhbGwiLCJjbG9uZUFycmF5IiwiYXJyIiwiYSIsImkiLCJsZW4iLCJsZW5ndGgiLCJwdXNoIiwiZXJyb3JPYmoiLCJlIiwidHJ5Q2F0Y2hlckdlbiIsInRyeUNhdGNoVGFyZ2V0IiwidHJ5Q2F0Y2hlciIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJ5Q2F0Y2giLCJmbiIsIlR5cGVFcnJvciIsInRocm93ZXIiLCJsb25nU3RhY2tTdXBwb3J0IiwiaGFzU3RhY2tzIiwic3RhY2tzIiwiRXJyb3IiLCJzdGFjayIsInJTdGFydGluZ0xpbmUiLCJjYXB0dXJlTGluZSIsInJGaWxlTmFtZSIsIlNUQUNLX0pVTVBfU0VQQVJBVE9SIiwibWFrZVN0YWNrVHJhY2VMb25nIiwiZXJyb3IiLCJvYnNlcnZhYmxlIiwiaW5kZXhPZiIsIm8iLCJzb3VyY2UiLCJ1bnNoaWZ0IiwiY29uY2F0ZWRTdGFja3MiLCJqb2luIiwiZmlsdGVyU3RhY2tTdHJpbmciLCJzdGFja1N0cmluZyIsImxpbmVzIiwic3BsaXQiLCJkZXNpcmVkTGluZXMiLCJsaW5lIiwiaXNJbnRlcm5hbEZyYW1lIiwiaXNOb2RlRnJhbWUiLCJzdGFja0xpbmUiLCJmaWxlTmFtZUFuZExpbmVOdW1iZXIiLCJnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJyRW5kaW5nTGluZSIsImZpcnN0TGluZSIsImF0dGVtcHQxIiwiZXhlYyIsIk51bWJlciIsImF0dGVtcHQyIiwiYXR0ZW1wdDMiLCJFbXB0eUVycm9yIiwibWVzc2FnZSIsInByb3RvdHlwZSIsImNyZWF0ZSIsIm5hbWUiLCJPYmplY3REaXNwb3NlZEVycm9yIiwiQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJub3RJbXBsZW1lbnRlZCIsIm5vdFN1cHBvcnRlZCIsIiRpdGVyYXRvciQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIlNldCIsImRvbmVFbnVtZXJhdG9yIiwiZG9uZSIsImlzSXRlcmFibGUiLCJpc0FycmF5TGlrZSIsImJpbmRDYWxsYmFjayIsImZ1bmMiLCJ0aGlzQXJnIiwiYXJnQ291bnQiLCJhcmciLCJpbmRleCIsImNvbGxlY3Rpb24iLCJkb250RW51bXMiLCJkb250RW51bXNMZW5ndGgiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsIm9ialRvU3RyaW5nIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1hdGgiLCJwb3ciLCJrZXlzIiwiaGFzRG9udEVudW1CdWciLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm9iaiIsInJlc3VsdCIsInByb3AiLCJlcXVhbE9iamVjdHMiLCJvYmplY3QiLCJvdGhlciIsImVxdWFsRnVuYyIsImlzTG9vc2UiLCJzdGFja0EiLCJzdGFja0IiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib3RoTGVuZ3RoIiwia2V5Iiwic2tpcEN0b3IiLCJvYmpWYWx1ZSIsIm90aFZhbHVlIiwib2JqQ3RvciIsImNvbnN0cnVjdG9yIiwib3RoQ3RvciIsImVxdWFsQnlUYWciLCJ0YWciLCJpc09iamVjdCIsInR5cGUiLCJpc09iamVjdExpa2UiLCJpc0xlbmd0aCIsImlzSG9zdE9iamVjdCIsImlzVHlwZWRBcnJheSIsImlzQXJyYXkiLCJBcnJheSIsImFycmF5U29tZSIsImFycmF5IiwicHJlZGljYXRlIiwiZXF1YWxBcnJheXMiLCJhcnJMZW5ndGgiLCJhcnJWYWx1ZSIsImJhc2VJc0VxdWFsRGVlcCIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwicG9wIiwiYmFzZUlzRXF1YWwiLCJoYXNQcm9wIiwic2xpY2UiLCJpbmhlcml0cyIsImNoaWxkIiwicGFyZW50IiwiX18iLCJhZGRQcm9wZXJ0aWVzIiwic291cmNlcyIsImlkeCIsImxuIiwiYWRkUmVmIiwieHMiLCJyIiwiQW5vbnltb3VzT2JzZXJ2YWJsZSIsIm9ic2VydmVyIiwiQmluYXJ5RGlzcG9zYWJsZSIsImdldERpc3Bvc2FibGUiLCJhcnJheUluaXRpYWxpemUiLCJjb3VudCIsImZhY3RvcnkiLCJDb21wb3NpdGVEaXNwb3NhYmxlIiwiYXJncyIsImRpc3Bvc2FibGVzIiwiaXNEaXNwb3NlZCIsIkNvbXBvc2l0ZURpc3Bvc2FibGVQcm90b3R5cGUiLCJhZGQiLCJpdGVtIiwiZGlzcG9zZSIsInJlbW92ZSIsInNob3VsZERpc3Bvc2UiLCJzcGxpY2UiLCJjdXJyZW50RGlzcG9zYWJsZXMiLCJEaXNwb3NhYmxlIiwiYWN0aW9uIiwiZGlzcG9zYWJsZUNyZWF0ZSIsImRpc3Bvc2FibGVFbXB0eSIsImVtcHR5IiwiaXNEaXNwb3NhYmxlIiwiZCIsImNoZWNrRGlzcG9zZWQiLCJkaXNwb3NhYmxlIiwiZGlzcG9zYWJsZUZpeHVwIiwiX2ZpeHVwIiwiU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUiLCJjdXJyZW50Iiwic2V0RGlzcG9zYWJsZSIsIm9sZCIsIlNlcmlhbERpc3Bvc2FibGUiLCJmaXJzdCIsInNlY29uZCIsIl9maXJzdCIsIl9zZWNvbmQiLCJvbGQxIiwib2xkMiIsIk5BcnlEaXNwb3NhYmxlIiwiX2Rpc3Bvc2FibGVzIiwiUmVmQ291bnREaXNwb3NhYmxlIiwiSW5uZXJEaXNwb3NhYmxlIiwiaXNJbm5lckRpc3Bvc2VkIiwiaXNQcmltYXJ5RGlzcG9zZWQiLCJ1bmRlcmx5aW5nRGlzcG9zYWJsZSIsIlNjaGVkdWxlZERpc3Bvc2FibGUiLCJzY2hlZHVsZXIiLCJzY2hlZHVsZUl0ZW0iLCJzIiwic2NoZWR1bGUiLCJTY2hlZHVsZWRJdGVtIiwic3RhdGUiLCJkdWVUaW1lIiwiY29tcGFyZXIiLCJpbnZva2UiLCJpbnZva2VDb3JlIiwiY29tcGFyZVRvIiwiaXNDYW5jZWxsZWQiLCJTY2hlZHVsZXIiLCJpc1NjaGVkdWxlciIsInNjaGVkdWxlclByb3RvIiwic2NoZWR1bGVGdXR1cmUiLCJkdCIsIm5vcm1hbGl6ZSIsIl9zY2hlZHVsZUZ1dHVyZSIsInRpbWVTcGFuIiwibm9ybWFsaXplVGltZSIsImludm9rZVJlY0ltbWVkaWF0ZSIsInBhaXIiLCJncm91cCIsImlubmVyQWN0aW9uIiwic3RhdGUyIiwiaXNBZGRlZCIsImlzRG9uZSIsInNjaGVkdWxlV29yayIsIl8iLCJzdGF0ZTMiLCJpbnZva2VSZWNEYXRlIiwiZHVlVGltZTEiLCJzY2hlZHVsZVJlY3Vyc2l2ZSIsInNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlIiwic2NoZWR1bGVQZXJpb2RpYyIsInBlcmlvZCIsInNldEludGVydmFsIiwiaWQiLCJjbGVhckludGVydmFsIiwiY2F0Y2hFcnJvciIsImhhbmRsZXIiLCJDYXRjaFNjaGVkdWxlciIsIlNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUiLCJjcmVhdGVUaWNrIiwidGljayIsImNvbW1hbmQiLCJyZWN1cnNlIiwiX3BlcmlvZCIsIl9hY3Rpb24iLCJfc3RhdGUiLCJfY2FuY2VsIiwiX3NjaGVkdWxlciIsInN0YXJ0IiwiSW1tZWRpYXRlU2NoZWR1bGVyIiwiX19zdXBlcl9fIiwiaW1tZWRpYXRlU2NoZWR1bGVyIiwiaW1tZWRpYXRlIiwiQ3VycmVudFRocmVhZFNjaGVkdWxlciIsInF1ZXVlIiwicnVuVHJhbXBvbGluZSIsImRlcXVldWUiLCJzaSIsIlByaW9yaXR5UXVldWUiLCJlbnF1ZXVlIiwic2NoZWR1bGVSZXF1aXJlZCIsImN1cnJlbnRUaHJlYWRTY2hlZHVsZXIiLCJjdXJyZW50VGhyZWFkIiwic2NoZWR1bGVNZXRob2QiLCJjbGVhck1ldGhvZCIsImxvY2FsVGltZXIiLCJsb2NhbFNldFRpbWVvdXQiLCJsb2NhbENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJXU2NyaXB0IiwidGltZSIsIlNsZWVwIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nIiwiaGFuZGxlIiwicnVuVGFzayIsInRhc2siLCJyZU5hdGl2ZSIsIlJlZ0V4cCIsIlN0cmluZyIsInJlcGxhY2UiLCJzZXRJbW1lZGlhdGUiLCJ0ZXN0IiwicG9zdE1lc3NhZ2VTdXBwb3J0ZWQiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJpc0FzeW5jIiwib2xkSGFuZGxlciIsIm9ubWVzc2FnZSIsInByb2Nlc3MiLCJuZXh0VGljayIsIk1TR19QUkVGSVgiLCJyYW5kb20iLCJvbkdsb2JhbFBvc3RNZXNzYWdlIiwiZXZlbnQiLCJkYXRhIiwic3Vic3RyaW5nIiwiYWRkRXZlbnRMaXN0ZW5lciIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzY3JpcHRFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJEZWZhdWx0U2NoZWR1bGVyIiwic2NoZWR1bGVBY3Rpb24iLCJDbGVhckRpc3Bvc2FibGUiLCJfaWQiLCJMb2NhbENsZWFyRGlzcG9zYWJsZSIsInNjaGVkdWxlTG9uZ1J1bm5pbmciLCJkZWZhdWx0U2NoZWR1bGVyIiwiYXN5bmMiLCJfaGFuZGxlciIsIl9yZWN1cnNpdmVPcmlnaW5hbCIsIl9yZWN1cnNpdmVXcmFwcGVyIiwiX3dyYXAiLCJfY2xvbmUiLCJyZXMiLCJfZ2V0UmVjdXJzaXZlV3JhcHBlciIsIndyYXBwZXIiLCJmYWlsZWQiLCJzdGF0ZTEiLCJJbmRleGVkSXRlbSIsImMiLCJjYXBhY2l0eSIsIml0ZW1zIiwicHJpb3JpdHlQcm90byIsImlzSGlnaGVyUHJpb3JpdHkiLCJsZWZ0IiwicmlnaHQiLCJwZXJjb2xhdGUiLCJ0ZW1wIiwiaGVhcGlmeSIsInBlZWsiLCJyZW1vdmVBdCIsIk5vdGlmaWNhdGlvbiIsIl9hY2NlcHQiLCJvbk5leHQiLCJvbkVycm9yIiwib25Db21wbGV0ZWQiLCJfYWNjZXB0T2JzZXJ2ZXIiLCJhY2NlcHQiLCJvYnNlcnZlck9yT25OZXh0IiwidG9PYnNlcnZhYmxlIiwibm90aWZpY2F0aW9uIiwia2luZCIsIk9uTmV4dE5vdGlmaWNhdGlvbiIsIk9uRXJyb3JOb3RpZmljYXRpb24iLCJPbkNvbXBsZXRlZE5vdGlmaWNhdGlvbiIsIm5vdGlmaWNhdGlvbkNyZWF0ZU9uTmV4dCIsImNyZWF0ZU9uTmV4dCIsIm5vdGlmaWNhdGlvbkNyZWF0ZU9uRXJyb3IiLCJjcmVhdGVPbkVycm9yIiwibm90aWZpY2F0aW9uQ3JlYXRlT25Db21wbGV0ZWQiLCJjcmVhdGVPbkNvbXBsZXRlZCIsIk9ic2VydmVyIiwidG9Ob3RpZmllciIsIm4iLCJhc09ic2VydmVyIiwiQW5vbnltb3VzT2JzZXJ2ZXIiLCJjaGVja2VkIiwiQ2hlY2tlZE9ic2VydmVyIiwib2JzZXJ2ZXJDcmVhdGUiLCJmcm9tTm90aWZpZXIiLCJjYiIsIm5vdGlmeU9uIiwiT2JzZXJ2ZU9uT2JzZXJ2ZXIiLCJtYWtlU2FmZSIsIkFub255bW91c1NhZmVPYnNlcnZlciIsIl9vbk5leHQiLCJfb25FcnJvciIsIl9vbkNvbXBsZXRlZCIsIkFic3RyYWN0T2JzZXJ2ZXIiLCJpc1N0b3BwZWQiLCJuZXh0IiwiY29tcGxldGVkIiwiZmFpbCIsIl9vYnNlcnZlciIsIkNoZWNrZWRPYnNlcnZlclByb3RvdHlwZSIsImNoZWNrQWNjZXNzIiwiU2NoZWR1bGVkT2JzZXJ2ZXIiLCJpc0FjcXVpcmVkIiwiaGFzRmF1bHRlZCIsImVucXVldWVOZXh0IiwiZW5xdWV1ZUVycm9yIiwiZW5xdWV1ZUNvbXBsZXRlZCIsIndvcmsiLCJzaGlmdCIsImVuc3VyZUFjdGl2ZSIsImlzT3duZXIiLCJjYW5jZWwiLCJvYnNlcnZhYmxlUHJvdG8iLCJPYnNlcnZhYmxlIiwibWFrZVN1YnNjcmliZSIsIm9sZE9uRXJyb3IiLCJvbGRTdWJzY3JpYmUiLCJfc3Vic2NyaWJlIiwiaXNPYnNlcnZhYmxlIiwiZm9yRWFjaCIsIm9Pck9uTmV4dCIsInN1YnNjcmliZU9uTmV4dCIsInN1YnNjcmliZU9uRXJyb3IiLCJzdWJzY3JpYmVPbkNvbXBsZXRlZCIsIk9ic2VydmFibGVCYXNlIiwiZml4U3Vic2NyaWJlciIsInN1YnNjcmliZXIiLCJhZG8iLCJzdWIiLCJzdWJzY3JpYmVDb3JlIiwiQXV0b0RldGFjaE9ic2VydmVyIiwiRmxhdE1hcE9ic2VydmFibGUiLCJzZWxlY3RvciIsInJlc3VsdFNlbGVjdG9yIiwiSW5uZXJPYnNlcnZlciIsIl93cmFwUmVzdWx0IiwibWFwIiwiaTIiLCJvYnNlcnZhYmxlRnJvbVByb21pc2UiLCJmcm9tIiwiRW51bWVyYWJsZSIsIklzRGlzcG9zZWREaXNwb3NhYmxlIiwiX3MiLCJDb25jYXRFbnVtZXJhYmxlT2JzZXJ2YWJsZSIsImN1cnJlbnRJdGVtIiwiY3VycmVudFZhbHVlIiwic3Vic2NyaXB0aW9uIiwiY2FuY2VsYWJsZSIsIl9yZWN1cnNlIiwiY29uY2F0IiwiQ2F0Y2hFcnJvck9ic2VydmFibGUiLCJsYXN0RXJyb3IiLCJSZXBlYXRFbnVtZXJhYmxlIiwidiIsIlJlcGVhdEVudW1lcmF0b3IiLCJsIiwiZW51bWVyYWJsZVJlcGVhdCIsInJlcGVhdCIsInJlcGVhdENvdW50IiwiT2ZFbnVtZXJhYmxlIiwiT2ZFbnVtZXJhdG9yIiwiZW51bWVyYWJsZU9mIiwib2YiLCJPYnNlcnZlT25PYnNlcnZhYmxlIiwib2JzZXJ2ZU9uIiwiU3Vic2NyaWJlT25PYnNlcnZhYmxlIiwibSIsInN1YnNjcmliZU9uIiwiRnJvbVByb21pc2VPYnNlcnZhYmxlIiwiX3AiLCJzY2hlZHVsZU5leHQiLCJzY2hlZHVsZUVycm9yIiwic2FkIiwiZnJvbVByb21pc2UiLCJwcm9taXNlIiwidG9Qcm9taXNlIiwicHJvbWlzZUN0b3IiLCJyZXNvbHZlIiwicmVqZWN0IiwiVG9BcnJheU9ic2VydmFibGUiLCJ0b0FycmF5IiwiRGVmZXIiLCJfZiIsIm9ic2VydmFibGVUaHJvdyIsIm9ic2VydmFibGVEZWZlciIsImRlZmVyIiwib2JzZXJ2YWJsZUZhY3RvcnkiLCJFbXB0eU9ic2VydmFibGUiLCJzaW5rIiwiRW1wdHlTaW5rIiwicnVuIiwiRU1QVFlfT0JTRVJWQUJMRSIsIm9ic2VydmFibGVFbXB0eSIsIkZyb21PYnNlcnZhYmxlIiwiaXRlcmFibGUiLCJfaXRlcmFibGUiLCJfZm4iLCJjcmVhdGVTY2hlZHVsZU1ldGhvZCIsIml0IiwibG9vcFJlY3Vyc2l2ZSIsImxpc3QiLCJnZXRJdGVyYWJsZSIsIm1heFNhZmVJbnRlZ2VyIiwiU3RyaW5nSXRlcmFibGUiLCJTdHJpbmdJdGVyYXRvciIsIl9sIiwiX2kiLCJjaGFyQXQiLCJBcnJheUl0ZXJhYmxlIiwiX2EiLCJBcnJheUl0ZXJhdG9yIiwidG9MZW5ndGgiLCJudW1iZXJJc0Zpbml0ZSIsImlzRmluaXRlIiwiaXNOYW4iLCJzaWduIiwibnVtYmVyIiwiaXNOYU4iLCJmbG9vciIsImFicyIsIm9ic2VydmFibGVGcm9tIiwibWFwRm4iLCJtYXBwZXIiLCJGcm9tQXJyYXlPYnNlcnZhYmxlIiwiX2FyZ3MiLCJvYnNlcnZhYmxlRnJvbUFycmF5IiwiZnJvbUFycmF5IiwiR2VuZXJhdGVPYnNlcnZhYmxlIiwiY25kRm4iLCJpdHJGbiIsInJlc0ZuIiwiX2luaXRpYWxTdGF0ZSIsIl9jbmRGbiIsIl9pdHJGbiIsIl9yZXNGbiIsIm5ld1N0YXRlIiwiaGFzUmVzdWx0IiwiZ2VuZXJhdGUiLCJpbml0aWFsU3RhdGUiLCJjb25kaXRpb24iLCJpdGVyYXRlIiwiTmV2ZXJPYnNlcnZhYmxlIiwiTkVWRVJfT0JTRVJWQUJMRSIsIm9ic2VydmFibGVOZXZlciIsIm5ldmVyIiwib2JzZXJ2YWJsZU9mIiwib2ZXaXRoU2NoZWR1bGVyIiwiUGFpcnNPYnNlcnZhYmxlIiwiX28iLCJfa2V5cyIsInBhaXJzIiwiUmFuZ2VPYnNlcnZhYmxlIiwicmFuZ2VDb3VudCIsImxvb3AiLCJyYW5nZSIsIlJlcGVhdE9ic2VydmFibGUiLCJSZXBlYXRTaW5rIiwiSnVzdE9ic2VydmFibGUiLCJfdmFsdWUiLCJvYnNlcnZhYmxlUmV0dXJuIiwianVzdCIsIlRocm93T2JzZXJ2YWJsZSIsIl9lcnJvciIsIlVzaW5nT2JzZXJ2YWJsZSIsIm9ic0ZuIiwiX29ic0ZuIiwicmVzb3VyY2UiLCJ1c2luZyIsInJlc291cmNlRmFjdG9yeSIsImFtYiIsInJpZ2h0U291cmNlIiwibGVmdFNvdXJjZSIsImNob2ljZSIsImxlZnRDaG9pY2UiLCJyaWdodENob2ljZSIsImxlZnRTdWJzY3JpcHRpb24iLCJyaWdodFN1YnNjcmlwdGlvbiIsImNob2ljZUwiLCJjaG9pY2VSIiwibGVmdFN1YnNjcmliZSIsInJpZ2h0U3Vic2NyaWJlIiwiYWNjIiwiQ2F0Y2hPYnNlcnZhYmxlIiwiZDEiLCJDYXRjaE9ic2VydmVyIiwiaGFuZGxlck9yU2Vjb25kIiwib2JzZXJ2YWJsZUNhdGNoIiwiY29tYmluZUxhdGVzdCIsImZhbHNlRmFjdG9yeSIsImFyZ3VtZW50c1RvQXJyYXkiLCJDb21iaW5lTGF0ZXN0T2JzZXJ2YWJsZSIsInBhcmFtcyIsIl9wYXJhbXMiLCJfY2IiLCJzdWJzY3JpcHRpb25zIiwiaGFzVmFsdWUiLCJoYXNWYWx1ZUFsbCIsInZhbHVlcyIsIkNvbWJpbmVMYXRlc3RPYnNlcnZlciIsIm5vdFRoZVNhbWUiLCJqIiwiZXZlcnkiLCJmaWx0ZXIiLCJvYnNlcnZhYmxlQ29uY2F0IiwiQ29uY2F0T2JzZXJ2ZXIiLCJDb25jYXRPYnNlcnZhYmxlIiwiX3NvdXJjZXMiLCJjb25jYXRBbGwiLCJtZXJnZSIsIk1lcmdlT2JzZXJ2YWJsZSIsIm1heENvbmN1cnJlbnQiLCJnIiwiTWVyZ2VPYnNlcnZlciIsIm1heCIsInEiLCJhY3RpdmVDb3VudCIsImhhbmRsZVN1YnNjcmliZSIsImlubmVyU291cmNlIiwibWF4Q29uY3VycmVudE9yT3RoZXIiLCJvYnNlcnZhYmxlTWVyZ2UiLCJtZXJnZUFsbCIsIkNvbXBvc2l0ZUVycm9yIiwiZXJyb3JzIiwiaW5uZXJFcnJvcnMiLCJNZXJnZURlbGF5RXJyb3JPYnNlcnZhYmxlIiwiTWVyZ2VEZWxheUVycm9yT2JzZXJ2ZXIiLCJfZ3JvdXAiLCJzZXRDb21wbGV0aW9uIiwiaW5uZXIiLCJfaW5uZXIiLCJtZXJnZURlbGF5RXJyb3IiLCJNZXJnZUFsbE9ic2VydmFibGUiLCJNZXJnZUFsbE9ic2VydmVyIiwib25FcnJvclJlc3VtZU5leHQiLCJPbkVycm9yUmVzdW1lTmV4dE9ic2VydmFibGUiLCJwb3MiLCJPbkVycm9yUmVzdW1lTmV4dE9ic2VydmVyIiwiY2FuY2VsbGFibGUiLCJTa2lwVW50aWxPYnNlcnZhYmxlIiwiX29wZW4iLCJTa2lwVW50aWxTb3VyY2VPYnNlcnZlciIsIlNraXBVbnRpbE90aGVyT2JzZXJ2ZXIiLCJfciIsInNraXBVbnRpbCIsIlN3aXRjaE9ic2VydmFibGUiLCJTd2l0Y2hPYnNlcnZlciIsInN0b3BwZWQiLCJsYXRlc3QiLCJoYXNMYXRlc3QiLCJzd2l0Y2hMYXRlc3QiLCJUYWtlVW50aWxPYnNlcnZhYmxlIiwiVGFrZVVudGlsT2JzZXJ2ZXIiLCJ0YWtlVW50aWwiLCJXaXRoTGF0ZXN0RnJvbU9ic2VydmFibGUiLCJfc3MiLCJXaXRoTGF0ZXN0RnJvbU90aGVyT2JzZXJ2ZXIiLCJvdXRlclNhZCIsIldpdGhMYXRlc3RGcm9tU291cmNlT2JzZXJ2ZXIiLCJhbGxWYWx1ZXMiLCJ3aXRoTGF0ZXN0RnJvbSIsImVtcHR5QXJyYXlGYWN0b3J5IiwiWmlwT2JzZXJ2YWJsZSIsIlppcE9ic2VydmVyIiwiX3EiLCJfZCIsIm5vdEVtcHR5Iiwic2hpZnRFYWNoIiwicXVldWVkVmFsdWVzIiwiemlwIiwiWmlwSXRlcmFibGVPYnNlcnZhYmxlIiwiWmlwSXRlcmFibGVPYnNlcnZlciIsInppcEl0ZXJhYmxlIiwiYXNPYnNlcnZhYmxlIiwiYnVmZmVyV2l0aENvdW50IiwiYnVmZmVyQ291bnQiLCJza2lwIiwid2luZG93V2l0aENvdW50IiwiZmxhdE1hcCIsIkRlbWF0ZXJpYWxpemVPYnNlcnZhYmxlIiwiRGVtYXRlcmlhbGl6ZU9ic2VydmVyIiwiZGVtYXRlcmlhbGl6ZSIsIkRpc3RpbmN0VW50aWxDaGFuZ2VkT2JzZXJ2YWJsZSIsImtleUZuIiwiRGlzdGluY3RVbnRpbENoYW5nZWRPYnNlcnZlciIsImhhc0N1cnJlbnRLZXkiLCJjdXJyZW50S2V5IiwiY29tcGFyZXJFcXVhbHMiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIlRhcE9ic2VydmFibGUiLCJfb04iLCJfb0UiLCJfb0MiLCJ0IiwidGFwIiwiZG9BY3Rpb24iLCJkb09uTmV4dCIsInRhcE9uTmV4dCIsImRvT25FcnJvciIsInRhcE9uRXJyb3IiLCJkb09uQ29tcGxldGVkIiwidGFwT25Db21wbGV0ZWQiLCJGaW5hbGx5T2JzZXJ2YWJsZSIsIkZpbmFsbHlEaXNwb3NhYmxlIiwiSWdub3JlRWxlbWVudHNPYnNlcnZhYmxlIiwiaWdub3JlRWxlbWVudHMiLCJNYXRlcmlhbGl6ZU9ic2VydmFibGUiLCJNYXRlcmlhbGl6ZU9ic2VydmVyIiwibWF0ZXJpYWxpemUiLCJyZXRyeSIsInJldHJ5Q291bnQiLCJSZXRyeVdoZW5PYnNlcnZhYmxlIiwiY3JlYXRlRGlzcG9zYWJsZSIsIm5vdGlmaWVyIiwiX25vdGlmaWVyIiwiZXhjZXB0aW9ucyIsIlN1YmplY3QiLCJoYW5kbGVkIiwibm90aWZpY2F0aW9uRGlzcG9zYWJsZSIsIm91dGVyIiwiZXhuIiwiZXgiLCJyZXRyeVdoZW4iLCJSZXBlYXRXaGVuT2JzZXJ2YWJsZSIsImNvbXBsZXRpb25zIiwicmVwZWF0V2hlbiIsIlNjYW5PYnNlcnZhYmxlIiwiYWNjdW11bGF0b3IiLCJoYXNTZWVkIiwic2VlZCIsIlNjYW5PYnNlcnZlciIsIl9ocyIsIl9oYSIsIl9odiIsInNjYW4iLCJTa2lwTGFzdE9ic2VydmFibGUiLCJfYyIsIlNraXBMYXN0T2JzZXJ2ZXIiLCJza2lwTGFzdCIsInN0YXJ0V2l0aCIsIlRha2VMYXN0T2JzZXJ2ZXIiLCJ0YWtlTGFzdCIsIlRha2VMYXN0QnVmZmVyT2JzZXJ2ZXIiLCJ0YWtlTGFzdEJ1ZmZlciIsIndpbmRvd0NvdW50IiwiSW5maW5pdHkiLCJyZWZDb3VudERpc3Bvc2FibGUiLCJjcmVhdGVXaW5kb3ciLCJmbGF0TWFwQ29uY2F0IiwiY29uY2F0TWFwIiwiY29uY2F0TWFwT2JzZXJ2ZXIiLCJzZWxlY3RDb25jYXRPYnNlcnZlciIsIm9uTmV4dEZ1bmMiLCJvbkVycm9yRnVuYyIsIm9uQ29tcGxldGVkRnVuYyIsIkRlZmF1bHRJZkVtcHR5T2JzZXJ2ZXIiLCJkZWZhdWx0SWZFbXB0eSIsImRlZmF1bHRWYWx1ZSIsImFycmF5SW5kZXhPZkNvbXBhcmVyIiwiSGFzaFNldCIsInNldCIsInJldFZhbHVlIiwiRGlzdGluY3RPYnNlcnZhYmxlIiwiY21wRm4iLCJfa2V5Rm4iLCJfY21wRm4iLCJEaXN0aW5jdE9ic2VydmVyIiwiX2giLCJkaXN0aW5jdCIsImtleVNlbGVjdG9yIiwiTWFwT2JzZXJ2YWJsZSIsImlubmVyTWFwIiwiaW50ZXJuYWxNYXAiLCJzZWxlY3QiLCJzZWxlY3RvckZuIiwicGx1Y2tlciIsImN1cnJlbnRQcm9wIiwicGx1Y2siLCJmbGF0TWFwT2JzZXJ2ZXIiLCJzZWxlY3RNYW55T2JzZXJ2ZXIiLCJzZWxlY3RNYW55IiwibWVyZ2VNYXAiLCJmbGF0TWFwTGF0ZXN0Iiwic3dpdGNoTWFwIiwiU2tpcE9ic2VydmFibGUiLCJfY291bnQiLCJTa2lwT2JzZXJ2ZXIiLCJTa2lwV2hpbGVPYnNlcnZhYmxlIiwiU2tpcFdoaWxlT2JzZXJ2ZXIiLCJza2lwV2hpbGUiLCJUYWtlT2JzZXJ2YWJsZSIsIlRha2VPYnNlcnZlciIsInRha2UiLCJUYWtlV2hpbGVPYnNlcnZhYmxlIiwiVGFrZVdoaWxlT2JzZXJ2ZXIiLCJ0YWtlV2hpbGUiLCJGaWx0ZXJPYnNlcnZhYmxlIiwiaW5uZXJQcmVkaWNhdGUiLCJpbnRlcm5hbEZpbHRlciIsInNob3VsZFlpZWxkIiwid2hlcmUiLCJUcmFuc2R1Y2VPYnNlcnZlciIsInhmb3JtIiwiX3hmb3JtIiwidHJhbnNmb3JtRm9yT2JzZXJ2ZXIiLCJvYnMiLCJpbnB1dCIsInRyYW5zZHVjZSIsInRyYW5zZHVjZXIiLCJfX3N1YnNjcmliZSIsIkF1dG9EZXRhY2hPYnNlcnZlclByb3RvdHlwZSIsIklubmVyU3Vic2NyaXB0aW9uIiwib2JzZXJ2ZXJzIiwiaGFzRXJyb3IiLCJoYXNPYnNlcnZlcnMiLCJvcyIsIkFub255bW91c1N1YmplY3QiLCJBc3luY1N1YmplY3QiLCJkZWZpbmUiLCJhbWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.sorting.js":
/*!********************************************!*\
  !*** ./node_modules/rx/dist/rx.sorting.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    var Observable = Rx.Observable, observableProto = Observable.prototype, AnonymousObservable = Rx.AnonymousObservable, observableNever = Observable.never, isEqual = Rx.internals.isEqual, defaultSubComparer = Rx.helpers.defaultSubComparer;\n    /**\n   * jortSort checks if your inputs are sorted.  Note that this is only for a sequence with an end.\n   * See http://jort.technology/ for full details.\n   * @returns {Observable} An observable which has a single value of true if sorted, else false.\n   */ observableProto.jortSort = function() {\n        return this.jortSortUntil(observableNever());\n    };\n    /**\n   * jortSort checks if your inputs are sorted until another Observable sequence fires.\n   * See http://jort.technology/ for full details.\n   * @returns {Observable} An observable which has a single value of true if sorted, else false.\n   */ observableProto.jortSortUntil = function(other) {\n        var source = this;\n        return new AnonymousObservable(function(observer) {\n            var arr = [];\n            return source.takeUntil(other).subscribe(arr.push.bind(arr), observer.onError.bind(observer), function() {\n                var sorted = arr.slice(0).sort(defaultSubComparer);\n                observer.onNext(isEqual(arr, sorted));\n                observer.onCompleted();\n            });\n        }, source);\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC5zb3J0aW5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw2S0FBNkc7O0FBRTNHLFVBQVVBLE9BQU87SUFDakIsSUFBSUMsY0FBYztRQUNoQixZQUFZO1FBQ1osVUFBVTtJQUNaO0lBRUEsU0FBU0MsWUFBWUMsS0FBSztRQUN4QixPQUFPLFNBQVVBLE1BQU1DLE1BQU0sS0FBS0EsU0FBVUQsUUFBUTtJQUN0RDtJQUVBLElBQUlFLGNBQWMsV0FBWSxDQUFDLE9BQU9DLFFBQVEsSUFBSUEsV0FBVyxDQUFDQSxRQUFRQyxRQUFRLEdBQUlELFVBQVU7SUFDNUYsSUFBSUUsYUFBYSxXQUFZLENBQUMsUUFBYUMsQ0FBQyxJQUFJQSxVQUFVLENBQUNBLE9BQU9GLFFBQVEsR0FBSUUsU0FBUztJQUN2RixJQUFJQyxhQUFhUixZQUFZRyxlQUFlRyxjQUFjLE9BQU9HLFdBQVcsWUFBWUE7SUFDeEYsSUFBSUMsV0FBV1YsWUFBWUQsV0FBVyxDQUFDLE9BQU9ZLEtBQUssSUFBSUE7SUFDdkQsSUFBSUMsYUFBYVosWUFBWUQsV0FBVyxDQUFDLFlBQWMsSUFBSWM7SUFDM0QsSUFBSUMsZ0JBQWdCLGNBQWVSLFdBQVdGLE9BQU8sS0FBS0QsY0FBZUEsY0FBYztJQUN2RixJQUFJWSxhQUFhZixZQUFZRCxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJO0lBQzdELElBQUlpQixPQUFPUixjQUFlLGVBQWlCTyxDQUFBQSxjQUFjQSxXQUFXRixNQUFNLEtBQU1ELGNBQWVGLFlBQVlLLGNBQWNFLFNBQVM7SUFFbEksOEJBQThCO0lBQzlCLElBQUksSUFBMEMsRUFBRTtRQUM5Q0MsaUNBQU87WUFBQztTQUFPLG1DQUFFLFNBQVVFLEVBQUUsRUFBRWhCLFFBQU87WUFDcEMsT0FBT04sUUFBUWtCLE1BQU1aLFVBQVNnQjtRQUNoQyxDQUFDO0FBQUEsa0dBQUM7SUFDSixPQUFPLEVBSU47QUFDSCxHQUFFRSxJQUFJLENBQUMsUUFBTSxTQUFVTixJQUFJLEVBQUVPLEdBQUcsRUFBRUgsRUFBRSxFQUFFSSxTQUFTO0lBRTdDLElBQUlDLGFBQWFMLEdBQUdLLFVBQVUsRUFDNUJDLGtCQUFrQkQsV0FBV0UsU0FBUyxFQUN0Q0Msc0JBQXNCUixHQUFHUSxtQkFBbUIsRUFDNUNDLGtCQUFrQkosV0FBV0ssS0FBSyxFQUNsQ0MsVUFBVVgsR0FBR1ksU0FBUyxDQUFDRCxPQUFPLEVBQzlCRSxxQkFBcUJiLEdBQUdjLE9BQU8sQ0FBQ0Qsa0JBQWtCO0lBRXBEOzs7O0dBSUMsR0FDRFAsZ0JBQWdCUyxRQUFRLEdBQUc7UUFDekIsT0FBTyxJQUFJLENBQUNDLGFBQWEsQ0FBQ1A7SUFDNUI7SUFFQTs7OztHQUlDLEdBQ0RILGdCQUFnQlUsYUFBYSxHQUFHLFNBQVVDLEtBQUs7UUFDN0MsSUFBSUMsU0FBUyxJQUFJO1FBQ2pCLE9BQU8sSUFBSVYsb0JBQW9CLFNBQVVXLFFBQVE7WUFDL0MsSUFBSUMsTUFBTSxFQUFFO1lBQ1osT0FBT0YsT0FBT0csU0FBUyxDQUFDSixPQUFPSyxTQUFTLENBQ3RDRixJQUFJRyxJQUFJLENBQUNDLElBQUksQ0FBQ0osTUFDZEQsU0FBU00sT0FBTyxDQUFDRCxJQUFJLENBQUNMLFdBQ3RCO2dCQUNFLElBQUlPLFNBQVNOLElBQUlPLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUNmO2dCQUMvQk0sU0FBU1UsTUFBTSxDQUFDbEIsUUFBUVMsS0FBS007Z0JBQzdCUCxTQUFTVyxXQUFXO1lBQ3RCO1FBQ0osR0FBR1o7SUFDTDtJQUVBLE9BQU9sQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9kaXN0L3J4LnNvcnRpbmcuanM/MmU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCwgQWxsIHJpZ2h0cyByZXNlcnZlZC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0dsb2JhbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgdmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKSA/IGV4cG9ydHMgOiBudWxsO1xuICB2YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSkgPyBtb2R1bGUgOiBudWxsO1xuICB2YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcbiAgdmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuICB2YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG4gIHZhciBtb2R1bGVFeHBvcnRzID0gKGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykgPyBmcmVlRXhwb3J0cyA6IG51bGw7XG4gIHZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvLyBCZWNhdXNlIG9mIGJ1aWxkIG9wdGltaXplcnNcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJy4vcngnXSwgZnVuY3Rpb24gKFJ4LCBleHBvcnRzKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShyb290LCBleHBvcnRzLCBSeCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyb290LCBtb2R1bGUuZXhwb3J0cywgcmVxdWlyZSgnLi9yeCcpKTtcbiAgfSBlbHNlIHtcbiAgICByb290LlJ4ID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5SeCk7XG4gIH1cbn0uY2FsbCh0aGlzLCBmdW5jdGlvbiAocm9vdCwgZXhwLCBSeCwgdW5kZWZpbmVkKSB7XG5cbiAgdmFyIE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLFxuICAgIG9ic2VydmFibGVQcm90byA9IE9ic2VydmFibGUucHJvdG90eXBlLFxuICAgIEFub255bW91c09ic2VydmFibGUgPSBSeC5Bbm9ueW1vdXNPYnNlcnZhYmxlLFxuICAgIG9ic2VydmFibGVOZXZlciA9IE9ic2VydmFibGUubmV2ZXIsXG4gICAgaXNFcXVhbCA9IFJ4LmludGVybmFscy5pc0VxdWFsLFxuICAgIGRlZmF1bHRTdWJDb21wYXJlciA9IFJ4LmhlbHBlcnMuZGVmYXVsdFN1YkNvbXBhcmVyO1xuXG4gIC8qKlxuICAgKiBqb3J0U29ydCBjaGVja3MgaWYgeW91ciBpbnB1dHMgYXJlIHNvcnRlZC4gIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgZm9yIGEgc2VxdWVuY2Ugd2l0aCBhbiBlbmQuXG4gICAqIFNlZSBodHRwOi8vam9ydC50ZWNobm9sb2d5LyBmb3IgZnVsbCBkZXRhaWxzLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSB3aGljaCBoYXMgYSBzaW5nbGUgdmFsdWUgb2YgdHJ1ZSBpZiBzb3J0ZWQsIGVsc2UgZmFsc2UuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uam9ydFNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuam9ydFNvcnRVbnRpbChvYnNlcnZhYmxlTmV2ZXIoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGpvcnRTb3J0IGNoZWNrcyBpZiB5b3VyIGlucHV0cyBhcmUgc29ydGVkIHVudGlsIGFub3RoZXIgT2JzZXJ2YWJsZSBzZXF1ZW5jZSBmaXJlcy5cbiAgICogU2VlIGh0dHA6Ly9qb3J0LnRlY2hub2xvZ3kvIGZvciBmdWxsIGRldGFpbHMuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHdoaWNoIGhhcyBhIHNpbmdsZSB2YWx1ZSBvZiB0cnVlIGlmIHNvcnRlZCwgZWxzZSBmYWxzZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5qb3J0U29ydFVudGlsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgcmV0dXJuIHNvdXJjZS50YWtlVW50aWwob3RoZXIpLnN1YnNjcmliZShcbiAgICAgICAgYXJyLnB1c2guYmluZChhcnIpLFxuICAgICAgICBvYnNlcnZlci5vbkVycm9yLmJpbmQob2JzZXJ2ZXIpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvcnRlZCA9IGFyci5zbGljZSgwKS5zb3J0KGRlZmF1bHRTdWJDb21wYXJlcik7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGlzRXF1YWwoYXJyLCBzb3J0ZWQpKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIHJldHVybiBSeDtcbn0pKTtcbiJdLCJuYW1lcyI6WyJmYWN0b3J5Iiwib2JqZWN0VHlwZXMiLCJjaGVja0dsb2JhbCIsInZhbHVlIiwiT2JqZWN0IiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsImZyZWVTZWxmIiwic2VsZiIsImZyZWVXaW5kb3ciLCJ3aW5kb3ciLCJtb2R1bGVFeHBvcnRzIiwidGhpc0dsb2JhbCIsInJvb3QiLCJGdW5jdGlvbiIsImRlZmluZSIsImFtZCIsIlJ4IiwicmVxdWlyZSIsImNhbGwiLCJleHAiLCJ1bmRlZmluZWQiLCJPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZVByb3RvIiwicHJvdG90eXBlIiwiQW5vbnltb3VzT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVOZXZlciIsIm5ldmVyIiwiaXNFcXVhbCIsImludGVybmFscyIsImRlZmF1bHRTdWJDb21wYXJlciIsImhlbHBlcnMiLCJqb3J0U29ydCIsImpvcnRTb3J0VW50aWwiLCJvdGhlciIsInNvdXJjZSIsIm9ic2VydmVyIiwiYXJyIiwidGFrZVVudGlsIiwic3Vic2NyaWJlIiwicHVzaCIsImJpbmQiLCJvbkVycm9yIiwic29ydGVkIiwic2xpY2UiLCJzb3J0Iiwib25OZXh0Iiwib25Db21wbGV0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.sorting.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.testing.js":
/*!********************************************!*\
  !*** ./node_modules/rx/dist/rx.testing.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx.virtualtime */ \"(ssr)/./node_modules/rx/dist/rx.virtualtime.js\"),\n            exports\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            root.Rx = factory(root, exports1, Rx);\n            return root.Rx;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // Defaults\n    var Observer = Rx.Observer, Observable = Rx.Observable, Notification = Rx.Notification, VirtualTimeScheduler = Rx.VirtualTimeScheduler, Disposable = Rx.Disposable, disposableEmpty = Disposable.empty, disposableCreate = Disposable.create, CompositeDisposable = Rx.CompositeDisposable, inherits = Rx.internals.inherits, defaultComparer = Rx.internals.isEqual;\n    function OnNextPredicate(predicate) {\n        this.predicate = predicate;\n    }\n    OnNextPredicate.prototype.equals = function(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (other.kind !== \"N\") {\n            return false;\n        }\n        return this.predicate(other.value);\n    };\n    function OnErrorPredicate(predicate) {\n        this.predicate = predicate;\n    }\n    OnErrorPredicate.prototype.equals = function(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (other.kind !== \"E\") {\n            return false;\n        }\n        return this.predicate(other.error);\n    };\n    var ReactiveTest = Rx.ReactiveTest = {\n        /** Default virtual time used for creation of observable sequences in unit tests. */ created: 100,\n        /** Default virtual time used to subscribe to observable sequences in unit tests. */ subscribed: 200,\n        /** Default virtual time used to dispose subscriptions in unit tests. */ disposed: 1000,\n        /**\n   * Factory method for an OnNext notification record at a given time with a given value or a predicate function.\n   *\n   * 1 - ReactiveTest.onNext(200, 42);\n   * 2 - ReactiveTest.onNext(200, function (x) { return x.length == 2; });\n   *\n   * @param ticks Recorded virtual time the OnNext notification occurs.\n   * @param value Recorded value stored in the OnNext notification or a predicate.\n   * @return Recorded OnNext notification.\n   */ onNext: function(ticks, value) {\n            return typeof value === \"function\" ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));\n        },\n        /**\n   * Factory method for an OnError notification record at a given time with a given error.\n   *\n   * 1 - ReactiveTest.onNext(200, new Error('error'));\n   * 2 - ReactiveTest.onNext(200, function (e) { return e.message === 'error'; });\n   *\n   * @param ticks Recorded virtual time the OnError notification occurs.\n   * @param exception Recorded exception stored in the OnError notification.\n   * @return Recorded OnError notification.\n   */ onError: function(ticks, error) {\n            return typeof error === \"function\" ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));\n        },\n        /**\n   * Factory method for an OnCompleted notification record at a given time.\n   *\n   * @param ticks Recorded virtual time the OnCompleted notification occurs.\n   * @return Recorded OnCompleted notification.\n   */ onCompleted: function(ticks) {\n            return new Recorded(ticks, Notification.createOnCompleted());\n        },\n        /**\n   * Factory method for a subscription record based on a given subscription and disposal time.\n   *\n   * @param start Virtual time indicating when the subscription was created.\n   * @param end Virtual time indicating when the subscription was disposed.\n   * @return Subscription object.\n   */ subscribe: function(start, end) {\n            return new Subscription(start, end);\n        }\n    };\n    /**\n   * Creates a new object recording the production of the specified value at the given virtual time.\n   *\n   * @constructor\n   * @param {Number} time Virtual time the value was produced on.\n   * @param {Mixed} value Value that was produced.\n   * @param {Function} comparer An optional comparer.\n   */ var Recorded = Rx.Recorded = function(time, value, comparer) {\n        this.time = time;\n        this.value = value;\n        this.comparer = comparer || defaultComparer;\n    };\n    /**\n   * Checks whether the given recorded object is equal to the current instance.\n   *\n   * @param {Recorded} other Recorded object to check for equality.\n   * @returns {Boolean} true if both objects are equal; false otherwise.\n   */ Recorded.prototype.equals = function(other) {\n        return this.time === other.time && this.comparer(this.value, other.value);\n    };\n    /**\n   * Returns a string representation of the current Recorded value.\n   *\n   * @returns {String} String representation of the current Recorded value.\n   */ Recorded.prototype.toString = function() {\n        return this.value.toString() + \"@\" + this.time;\n    };\n    /**\n   * Creates a new subscription object with the given virtual subscription and unsubscription time.\n   *\n   * @constructor\n   * @param {Number} subscribe Virtual time at which the subscription occurred.\n   * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.\n   */ var Subscription = Rx.Subscription = function(start, end) {\n        this.subscribe = start;\n        this.unsubscribe = end || Number.MAX_VALUE;\n    };\n    /**\n   * Checks whether the given subscription is equal to the current instance.\n   * @param other Subscription object to check for equality.\n   * @returns {Boolean} true if both objects are equal; false otherwise.\n   */ Subscription.prototype.equals = function(other) {\n        return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;\n    };\n    /**\n   * Returns a string representation of the current Subscription value.\n   * @returns {String} String representation of the current Subscription value.\n   */ Subscription.prototype.toString = function() {\n        return \"(\" + this.subscribe + \", \" + (this.unsubscribe === Number.MAX_VALUE ? \"Infinite\" : this.unsubscribe) + \")\";\n    };\n    var MockDisposable = Rx.MockDisposable = function(scheduler) {\n        this.scheduler = scheduler;\n        this.disposes = [];\n        this.disposes.push(this.scheduler.clock);\n    };\n    MockDisposable.prototype.dispose = function() {\n        this.disposes.push(this.scheduler.clock);\n    };\n    var MockObserver = function(__super__) {\n        inherits(MockObserver, __super__);\n        function MockObserver(scheduler) {\n            __super__.call(this);\n            this.scheduler = scheduler;\n            this.messages = [];\n        }\n        var MockObserverPrototype = MockObserver.prototype;\n        MockObserverPrototype.onNext = function(value) {\n            this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));\n        };\n        MockObserverPrototype.onError = function(e) {\n            this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(e)));\n        };\n        MockObserverPrototype.onCompleted = function() {\n            this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));\n        };\n        return MockObserver;\n    }(Observer);\n    function MockPromise(scheduler, messages) {\n        var self1 = this;\n        this.scheduler = scheduler;\n        this.messages = messages;\n        this.subscriptions = [];\n        this.observers = [];\n        for(var i = 0, len = this.messages.length; i < len; i++){\n            var message = this.messages[i], notification = message.value;\n            (function(innerNotification) {\n                scheduler.scheduleAbsolute(null, message.time, function() {\n                    var obs = self1.observers.slice(0);\n                    for(var j = 0, jLen = obs.length; j < jLen; j++){\n                        innerNotification.accept(obs[j]);\n                    }\n                    return disposableEmpty;\n                });\n            })(notification);\n        }\n    }\n    MockPromise.prototype.then = function(onResolved, onRejected) {\n        var self1 = this;\n        this.subscriptions.push(new Subscription(this.scheduler.clock));\n        var index = this.subscriptions.length - 1;\n        var newPromise;\n        var observer = Rx.Observer.create(function(x) {\n            var retValue = onResolved(x);\n            if (retValue && typeof retValue.then === \"function\") {\n                newPromise = retValue;\n            } else {\n                var ticks = self1.scheduler.clock;\n                newPromise = new MockPromise(self1.scheduler, [\n                    Rx.ReactiveTest.onNext(ticks, undefined),\n                    Rx.ReactiveTest.onCompleted(ticks)\n                ]);\n            }\n            var idx = self1.observers.indexOf(observer);\n            self1.observers.splice(idx, 1);\n            self1.subscriptions[index] = new Subscription(self1.subscriptions[index].subscribe, self1.scheduler.clock);\n        }, function(err) {\n            onRejected(err);\n            var idx = self1.observers.indexOf(observer);\n            self1.observers.splice(idx, 1);\n            self1.subscriptions[index] = new Subscription(self1.subscriptions[index].subscribe, self1.scheduler.clock);\n        });\n        this.observers.push(observer);\n        return newPromise || new MockPromise(this.scheduler, this.messages);\n    };\n    var HotObservable = function(__super__) {\n        inherits(HotObservable, __super__);\n        function HotObservable(scheduler, messages) {\n            __super__.call(this);\n            var message, notification, observable = this;\n            this.scheduler = scheduler;\n            this.messages = messages;\n            this.subscriptions = [];\n            this.observers = [];\n            for(var i = 0, len = this.messages.length; i < len; i++){\n                message = this.messages[i];\n                notification = message.value;\n                (function(innerNotification) {\n                    scheduler.scheduleAbsolute(null, message.time, function() {\n                        var obs = observable.observers.slice(0);\n                        for(var j = 0, jLen = obs.length; j < jLen; j++){\n                            innerNotification.accept(obs[j]);\n                        }\n                        return disposableEmpty;\n                    });\n                })(notification);\n            }\n        }\n        HotObservable.prototype._subscribe = function(o) {\n            var observable = this;\n            this.observers.push(o);\n            this.subscriptions.push(new Subscription(this.scheduler.clock));\n            var index = this.subscriptions.length - 1;\n            return disposableCreate(function() {\n                var idx = observable.observers.indexOf(o);\n                observable.observers.splice(idx, 1);\n                observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);\n            });\n        };\n        return HotObservable;\n    }(Observable);\n    var ColdObservable = function(__super__) {\n        inherits(ColdObservable, __super__);\n        function ColdObservable(scheduler, messages) {\n            __super__.call(this);\n            this.scheduler = scheduler;\n            this.messages = messages;\n            this.subscriptions = [];\n        }\n        ColdObservable.prototype._subscribe = function(o) {\n            var message, notification, observable = this;\n            this.subscriptions.push(new Subscription(this.scheduler.clock));\n            var index = this.subscriptions.length - 1;\n            var d = new CompositeDisposable();\n            for(var i = 0, len = this.messages.length; i < len; i++){\n                message = this.messages[i];\n                notification = message.value;\n                (function(innerNotification) {\n                    d.add(observable.scheduler.scheduleRelative(null, message.time, function() {\n                        innerNotification.accept(o);\n                        return disposableEmpty;\n                    }));\n                })(notification);\n            }\n            return disposableCreate(function() {\n                observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);\n                d.dispose();\n            });\n        };\n        return ColdObservable;\n    }(Observable);\n    /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */ Rx.TestScheduler = function(__super__) {\n        inherits(TestScheduler, __super__);\n        function baseComparer(x, y) {\n            return x > y ? 1 : x < y ? -1 : 0;\n        }\n        function TestScheduler() {\n            __super__.call(this, 0, baseComparer);\n        }\n        /**\n     * Schedules an action to be executed at the specified virtual time.\n     *\n     * @param state State passed to the action to be executed.\n     * @param dueTime Absolute virtual time at which to execute the action.\n     * @param action Action to be executed.\n     * @return Disposable object used to cancel the scheduled action (best effort).\n     */ TestScheduler.prototype.scheduleAbsolute = function(state, dueTime, action) {\n            dueTime <= this.clock && (dueTime = this.clock + 1);\n            return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);\n        };\n        /**\n     * Adds a relative virtual time to an absolute virtual time value.\n     *\n     * @param absolute Absolute virtual time value.\n     * @param relative Relative virtual time value to add.\n     * @return Resulting absolute virtual time sum value.\n     */ TestScheduler.prototype.add = function(absolute, relative) {\n            return absolute + relative;\n        };\n        /**\n     * Converts the absolute virtual time value to a DateTimeOffset value.\n     *\n     * @param absolute Absolute virtual time value to convert.\n     * @return Corresponding DateTimeOffset value.\n     */ TestScheduler.prototype.toAbsoluteTime = function(absolute) {\n            return new Date(absolute).getTime();\n        };\n        /**\n     * Converts the TimeSpan value to a relative virtual time value.\n     *\n     * @param timeSpan TimeSpan value to convert.\n     * @return Corresponding relative virtual time value.\n     */ TestScheduler.prototype.toRelativeTime = function(timeSpan) {\n            return timeSpan;\n        };\n        /**\n     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.\n     *\n     * @param create Factory method to create an observable sequence.\n     * @param created Virtual time at which to invoke the factory to create an observable sequence.\n     * @param subscribed Virtual time at which to subscribe to the created observable sequence.\n     * @param disposed Virtual time at which to dispose the subscription.\n     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.\n     */ TestScheduler.prototype.startScheduler = function(createFn, settings) {\n            settings || (settings = {});\n            settings.created == null && (settings.created = ReactiveTest.created);\n            settings.subscribed == null && (settings.subscribed = ReactiveTest.subscribed);\n            settings.disposed == null && (settings.disposed = ReactiveTest.disposed);\n            var observer = this.createObserver(), source, subscription;\n            this.scheduleAbsolute(null, settings.created, function() {\n                source = createFn();\n                return disposableEmpty;\n            });\n            this.scheduleAbsolute(null, settings.subscribed, function() {\n                subscription = source.subscribe(observer);\n                return disposableEmpty;\n            });\n            this.scheduleAbsolute(null, settings.disposed, function() {\n                subscription.dispose();\n                return disposableEmpty;\n            });\n            this.start();\n            return observer;\n        };\n        /**\n     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.\n     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.\n     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.\n     */ TestScheduler.prototype.createHotObservable = function() {\n            var len = arguments.length, args;\n            if (Array.isArray(arguments[0])) {\n                args = arguments[0];\n            } else {\n                args = new Array(len);\n                for(var i = 0; i < len; i++){\n                    args[i] = arguments[i];\n                }\n            }\n            return new HotObservable(this, args);\n        };\n        /**\n     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.\n     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.\n     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.\n     */ TestScheduler.prototype.createColdObservable = function() {\n            var len = arguments.length, args;\n            if (Array.isArray(arguments[0])) {\n                args = arguments[0];\n            } else {\n                args = new Array(len);\n                for(var i = 0; i < len; i++){\n                    args[i] = arguments[i];\n                }\n            }\n            return new ColdObservable(this, args);\n        };\n        /**\n     * Creates a resolved promise with the given value and ticks\n     * @param {Number} ticks The absolute time of the resolution.\n     * @param {Any} value The value to yield at the given tick.\n     * @returns {MockPromise} A mock Promise which fulfills with the given value.\n     */ TestScheduler.prototype.createResolvedPromise = function(ticks, value) {\n            return new MockPromise(this, [\n                Rx.ReactiveTest.onNext(ticks, value),\n                Rx.ReactiveTest.onCompleted(ticks)\n            ]);\n        };\n        /**\n     * Creates a rejected promise with the given reason and ticks\n     * @param {Number} ticks The absolute time of the resolution.\n     * @param {Any} reason The reason for rejection to yield at the given tick.\n     * @returns {MockPromise} A mock Promise which rejects with the given reason.\n     */ TestScheduler.prototype.createRejectedPromise = function(ticks, reason) {\n            return new MockPromise(this, [\n                Rx.ReactiveTest.onError(ticks, reason)\n            ]);\n        };\n        /**\n     * Creates an observer that records received notification messages and timestamps those.\n     * @return Observer that can be used to assert the timing of received notifications.\n     */ TestScheduler.prototype.createObserver = function() {\n            return new MockObserver(this);\n        };\n        return TestScheduler;\n    }(VirtualTimeScheduler);\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC50ZXN0aW5nLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw2S0FBNkc7O0FBRTNHLFVBQVVBLE9BQU87SUFDakIsSUFBSUMsY0FBYztRQUNoQixZQUFZO1FBQ1osVUFBVTtJQUNaO0lBRUEsU0FBU0MsWUFBWUMsS0FBSztRQUN4QixPQUFPLFNBQVVBLE1BQU1DLE1BQU0sS0FBS0EsU0FBVUQsUUFBUTtJQUN0RDtJQUVBLElBQUlFLGNBQWMsV0FBWSxDQUFDLE9BQU9DLFFBQVEsSUFBSUEsV0FBVyxDQUFDQSxRQUFRQyxRQUFRLEdBQUlELFVBQVU7SUFDNUYsSUFBSUUsYUFBYSxXQUFZLENBQUMsUUFBYUMsQ0FBQyxJQUFJQSxVQUFVLENBQUNBLE9BQU9GLFFBQVEsR0FBSUUsU0FBUztJQUN2RixJQUFJQyxhQUFhUixZQUFZRyxlQUFlRyxjQUFjLE9BQU9HLFdBQVcsWUFBWUE7SUFDeEYsSUFBSUMsV0FBV1YsWUFBWUQsV0FBVyxDQUFDLE9BQU9ZLEtBQUssSUFBSUE7SUFDdkQsSUFBSUMsYUFBYVosWUFBWUQsV0FBVyxDQUFDLFlBQWMsSUFBSWM7SUFDM0QsSUFBSUMsZ0JBQWdCLGNBQWVSLFdBQVdGLE9BQU8sS0FBS0QsY0FBZUEsY0FBYztJQUN2RixJQUFJWSxhQUFhZixZQUFZRCxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJO0lBQzdELElBQUlpQixPQUFPUixjQUFlLGVBQWlCTyxDQUFBQSxjQUFjQSxXQUFXRixNQUFNLEtBQU1ELGNBQWVGLFlBQVlLLGNBQWNFLFNBQVM7SUFFbEksOEJBQThCO0lBQzlCLElBQUksSUFBMEMsRUFBRTtRQUM5Q0MsaUNBQU87WUFBQztZQUFvQjtTQUFVLG1DQUFFLFNBQVVFLEVBQUUsRUFBRWhCLFFBQU87WUFDM0RZLEtBQUtJLEVBQUUsR0FBR3RCLFFBQVFrQixNQUFNWixVQUFTZ0I7WUFDakMsT0FBT0osS0FBS0ksRUFBRTtRQUNoQixDQUFDO0FBQUEsa0dB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LEVBQUd2RjtJQUVILE9BQU9SO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXJ2ZXItYWN0aW9uLy4vbm9kZV9tb2R1bGVzL3J4L2Rpc3QvcngudGVzdGluZy5qcz8xMGE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LCBBbGwgcmlnaHRzIHJlc2VydmVkLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG4gIH1cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpID8gZXhwb3J0cyA6IG51bGw7XG4gIHZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKSA/IG1vZHVsZSA6IG51bGw7XG4gIHZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuICB2YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG4gIHZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSAoZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzKSA/IGZyZWVFeHBvcnRzIDogbnVsbDtcbiAgdmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8vIEJlY2F1c2Ugb2YgYnVpbGQgb3B0aW1pemVyc1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnLi9yeC52aXJ0dWFsdGltZScsICdleHBvcnRzJ10sIGZ1bmN0aW9uIChSeCwgZXhwb3J0cykge1xuICAgICAgcm9vdC5SeCA9IGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgUngpO1xuICAgICAgcmV0dXJuIHJvb3QuUng7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyb290LCBtb2R1bGUuZXhwb3J0cywgcmVxdWlyZSgnLi9yeCcpKTtcbiAgfSBlbHNlIHtcbiAgICByb290LlJ4ID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5SeCk7XG4gIH1cbn0uY2FsbCh0aGlzLCBmdW5jdGlvbiAocm9vdCwgZXhwLCBSeCwgdW5kZWZpbmVkKSB7XG5cbiAgLy8gRGVmYXVsdHNcbiAgdmFyIE9ic2VydmVyID0gUnguT2JzZXJ2ZXIsXG4gICAgT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUsXG4gICAgTm90aWZpY2F0aW9uID0gUnguTm90aWZpY2F0aW9uLFxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyID0gUnguVmlydHVhbFRpbWVTY2hlZHVsZXIsXG4gICAgRGlzcG9zYWJsZSA9IFJ4LkRpc3Bvc2FibGUsXG4gICAgZGlzcG9zYWJsZUVtcHR5ID0gRGlzcG9zYWJsZS5lbXB0eSxcbiAgICBkaXNwb3NhYmxlQ3JlYXRlID0gRGlzcG9zYWJsZS5jcmVhdGUsXG4gICAgQ29tcG9zaXRlRGlzcG9zYWJsZSA9IFJ4LkNvbXBvc2l0ZURpc3Bvc2FibGUsXG4gICAgaW5oZXJpdHMgPSBSeC5pbnRlcm5hbHMuaW5oZXJpdHMsXG4gICAgZGVmYXVsdENvbXBhcmVyID0gUnguaW50ZXJuYWxzLmlzRXF1YWw7XG5cbmZ1bmN0aW9uIE9uTmV4dFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbn1cblxuT25OZXh0UHJlZGljYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmIChvdGhlciA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAob3RoZXIua2luZCAhPT0gJ04nKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdGhpcy5wcmVkaWNhdGUob3RoZXIudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gT25FcnJvclByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG59XG5cbk9uRXJyb3JQcmVkaWNhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAob3RoZXIgPT09IHRoaXMpIHsgcmV0dXJuIHRydWU7IH1cbiAgaWYgKG90aGVyID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChvdGhlci5raW5kICE9PSAnRScpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0aGlzLnByZWRpY2F0ZShvdGhlci5lcnJvcik7XG59O1xuXG52YXIgUmVhY3RpdmVUZXN0ID0gUnguUmVhY3RpdmVUZXN0ID0ge1xuICAvKiogRGVmYXVsdCB2aXJ0dWFsIHRpbWUgdXNlZCBmb3IgY3JlYXRpb24gb2Ygb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdW5pdCB0ZXN0cy4gKi9cbiAgY3JlYXRlZDogMTAwLFxuICAvKiogRGVmYXVsdCB2aXJ0dWFsIHRpbWUgdXNlZCB0byBzdWJzY3JpYmUgdG8gb2JzZXJ2YWJsZSBzZXF1ZW5jZXMgaW4gdW5pdCB0ZXN0cy4gKi9cbiAgc3Vic2NyaWJlZDogMjAwLFxuICAvKiogRGVmYXVsdCB2aXJ0dWFsIHRpbWUgdXNlZCB0byBkaXNwb3NlIHN1YnNjcmlwdGlvbnMgaW4gdW5pdCB0ZXN0cy4gKi9cbiAgZGlzcG9zZWQ6IDEwMDAsXG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBhbiBPbk5leHQgbm90aWZpY2F0aW9uIHJlY29yZCBhdCBhIGdpdmVuIHRpbWUgd2l0aCBhIGdpdmVuIHZhbHVlIG9yIGEgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAxIC0gUmVhY3RpdmVUZXN0Lm9uTmV4dCgyMDAsIDQyKTtcbiAgICogMiAtIFJlYWN0aXZlVGVzdC5vbk5leHQoMjAwLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPT0gMjsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBSZWNvcmRlZCB2aXJ0dWFsIHRpbWUgdGhlIE9uTmV4dCBub3RpZmljYXRpb24gb2NjdXJzLlxuICAgKiBAcGFyYW0gdmFsdWUgUmVjb3JkZWQgdmFsdWUgc3RvcmVkIGluIHRoZSBPbk5leHQgbm90aWZpY2F0aW9uIG9yIGEgcHJlZGljYXRlLlxuICAgKiBAcmV0dXJuIFJlY29yZGVkIE9uTmV4dCBub3RpZmljYXRpb24uXG4gICAqL1xuICBvbk5leHQ6IGZ1bmN0aW9uICh0aWNrcywgdmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID9cbiAgICAgIG5ldyBSZWNvcmRlZCh0aWNrcywgbmV3IE9uTmV4dFByZWRpY2F0ZSh2YWx1ZSkpIDpcbiAgICAgIG5ldyBSZWNvcmRlZCh0aWNrcywgTm90aWZpY2F0aW9uLmNyZWF0ZU9uTmV4dCh2YWx1ZSkpO1xuICB9LFxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgZm9yIGFuIE9uRXJyb3Igbm90aWZpY2F0aW9uIHJlY29yZCBhdCBhIGdpdmVuIHRpbWUgd2l0aCBhIGdpdmVuIGVycm9yLlxuICAgKlxuICAgKiAxIC0gUmVhY3RpdmVUZXN0Lm9uTmV4dCgyMDAsIG5ldyBFcnJvcignZXJyb3InKSk7XG4gICAqIDIgLSBSZWFjdGl2ZVRlc3Qub25OZXh0KDIwMCwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubWVzc2FnZSA9PT0gJ2Vycm9yJzsgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBSZWNvcmRlZCB2aXJ0dWFsIHRpbWUgdGhlIE9uRXJyb3Igbm90aWZpY2F0aW9uIG9jY3Vycy5cbiAgICogQHBhcmFtIGV4Y2VwdGlvbiBSZWNvcmRlZCBleGNlcHRpb24gc3RvcmVkIGluIHRoZSBPbkVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICogQHJldHVybiBSZWNvcmRlZCBPbkVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIG9uRXJyb3I6IGZ1bmN0aW9uICh0aWNrcywgZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgICAgIG5ldyBSZWNvcmRlZCh0aWNrcywgbmV3IE9uRXJyb3JQcmVkaWNhdGUoZXJyb3IpKSA6XG4gICAgICBuZXcgUmVjb3JkZWQodGlja3MsIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkVycm9yKGVycm9yKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYW4gT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uIHJlY29yZCBhdCBhIGdpdmVuIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB0aWNrcyBSZWNvcmRlZCB2aXJ0dWFsIHRpbWUgdGhlIE9uQ29tcGxldGVkIG5vdGlmaWNhdGlvbiBvY2N1cnMuXG4gICAqIEByZXR1cm4gUmVjb3JkZWQgT25Db21wbGV0ZWQgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICh0aWNrcykge1xuICAgIHJldHVybiBuZXcgUmVjb3JkZWQodGlja3MsIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkNvbXBsZXRlZCgpKTtcbiAgfSxcbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIGZvciBhIHN1YnNjcmlwdGlvbiByZWNvcmQgYmFzZWQgb24gYSBnaXZlbiBzdWJzY3JpcHRpb24gYW5kIGRpc3Bvc2FsIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydCBWaXJ0dWFsIHRpbWUgaW5kaWNhdGluZyB3aGVuIHRoZSBzdWJzY3JpcHRpb24gd2FzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBlbmQgVmlydHVhbCB0aW1lIGluZGljYXRpbmcgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHdhcyBkaXNwb3NlZC5cbiAgICogQHJldHVybiBTdWJzY3JpcHRpb24gb2JqZWN0LlxuICAgKi9cbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKHN0YXJ0LCBlbmQpO1xuICB9XG59O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCByZWNvcmRpbmcgdGhlIHByb2R1Y3Rpb24gb2YgdGhlIHNwZWNpZmllZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdmlydHVhbCB0aW1lLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVmlydHVhbCB0aW1lIHRoZSB2YWx1ZSB3YXMgcHJvZHVjZWQgb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFZhbHVlIHRoYXQgd2FzIHByb2R1Y2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBBbiBvcHRpb25hbCBjb21wYXJlci5cbiAgICovXG4gIHZhciBSZWNvcmRlZCA9IFJ4LlJlY29yZGVkID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlLCBjb21wYXJlcikge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlciB8fCBkZWZhdWx0Q29tcGFyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiByZWNvcmRlZCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkZWR9IG90aGVyIFJlY29yZGVkIG9iamVjdCB0byBjaGVjayBmb3IgZXF1YWxpdHkuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGJvdGggb2JqZWN0cyBhcmUgZXF1YWw7IGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIFJlY29yZGVkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lID09PSBvdGhlci50aW1lICYmIHRoaXMuY29tcGFyZXIodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFJlY29yZGVkIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgUmVjb3JkZWQgdmFsdWUuXG4gICAqL1xuICBSZWNvcmRlZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKSArICdAJyArIHRoaXMudGltZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdWJzY3JpcHRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZpcnR1YWwgc3Vic2NyaXB0aW9uIGFuZCB1bnN1YnNjcmlwdGlvbiB0aW1lLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN1YnNjcmliZSBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiBvY2N1cnJlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHVuc3Vic2NyaWJlIFZpcnR1YWwgdGltZSBhdCB3aGljaCB0aGUgdW5zdWJzY3JpcHRpb24gb2NjdXJyZWQuXG4gICAqL1xuICB2YXIgU3Vic2NyaXB0aW9uID0gUnguU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHN0YXJ0O1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBlbmQgfHwgTnVtYmVyLk1BWF9WQUxVRTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHN1YnNjcmlwdGlvbiBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG90aGVyIFN1YnNjcmlwdGlvbiBvYmplY3QgdG8gY2hlY2sgZm9yIGVxdWFsaXR5LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBib3RoIG9iamVjdHMgYXJlIGVxdWFsOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSA9PT0gb3RoZXIuc3Vic2NyaWJlICYmIHRoaXMudW5zdWJzY3JpYmUgPT09IG90aGVyLnVuc3Vic2NyaWJlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbiB2YWx1ZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbiB2YWx1ZS5cbiAgICovXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcoJyArIHRoaXMuc3Vic2NyaWJlICsgJywgJyArICh0aGlzLnVuc3Vic2NyaWJlID09PSBOdW1iZXIuTUFYX1ZBTFVFID8gJ0luZmluaXRlJyA6IHRoaXMudW5zdWJzY3JpYmUpICsgJyknO1xuICB9O1xuXG4gIHZhciBNb2NrRGlzcG9zYWJsZSA9IFJ4Lk1vY2tEaXNwb3NhYmxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMuZGlzcG9zZXMgPSBbXTtcbiAgICB0aGlzLmRpc3Bvc2VzLnB1c2godGhpcy5zY2hlZHVsZXIuY2xvY2spO1xuICB9O1xuXG4gIE1vY2tEaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcG9zZXMucHVzaCh0aGlzLnNjaGVkdWxlci5jbG9jayk7XG4gIH07XG5cbiAgdmFyIE1vY2tPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoTW9ja09ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gTW9ja09ic2VydmVyKHNjaGVkdWxlcikge1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgTW9ja09ic2VydmVyUHJvdG90eXBlID0gTW9ja09ic2VydmVyLnByb3RvdHlwZTtcblxuICAgIE1vY2tPYnNlcnZlclByb3RvdHlwZS5vbk5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChuZXcgUmVjb3JkZWQodGhpcy5zY2hlZHVsZXIuY2xvY2ssIE5vdGlmaWNhdGlvbi5jcmVhdGVPbk5leHQodmFsdWUpKSk7XG4gICAgfTtcblxuICAgIE1vY2tPYnNlcnZlclByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChuZXcgUmVjb3JkZWQodGhpcy5zY2hlZHVsZXIuY2xvY2ssIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkVycm9yKGUpKSk7XG4gICAgfTtcblxuICAgIE1vY2tPYnNlcnZlclByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChuZXcgUmVjb3JkZWQodGhpcy5zY2hlZHVsZXIuY2xvY2ssIE5vdGlmaWNhdGlvbi5jcmVhdGVPbkNvbXBsZXRlZCgpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2NrT2JzZXJ2ZXI7XG4gIH0pKE9ic2VydmVyKTtcblxuICBmdW5jdGlvbiBNb2NrUHJvbWlzZShzY2hlZHVsZXIsIG1lc3NhZ2VzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV0sXG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgIChmdW5jdGlvbiAoaW5uZXJOb3RpZmljYXRpb24pIHtcbiAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgbWVzc2FnZS50aW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9icyA9IHNlbGYub2JzZXJ2ZXJzLnNsaWNlKDApO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBvYnMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICBpbm5lck5vdGlmaWNhdGlvbi5hY2NlcHQob2JzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgfSk7XG4gICAgICB9KShub3RpZmljYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIE1vY2tQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc2NoZWR1bGVyLmNsb2NrKSk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgbmV3UHJvbWlzZTtcblxuICAgIHZhciBvYnNlcnZlciA9IFJ4Lk9ic2VydmVyLmNyZWF0ZShcbiAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXRWYWx1ZSA9IG9uUmVzb2x2ZWQoeCk7XG4gICAgICAgIGlmIChyZXRWYWx1ZSAmJiB0eXBlb2YgcmV0VmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG5ld1Byb21pc2UgPSByZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGlja3MgPSBzZWxmLnNjaGVkdWxlci5jbG9jaztcbiAgICAgICAgICBuZXdQcm9taXNlID0gbmV3IE1vY2tQcm9taXNlKHNlbGYuc2NoZWR1bGVyLCBbUnguUmVhY3RpdmVUZXN0Lm9uTmV4dCh0aWNrcywgdW5kZWZpbmVkKSwgUnguUmVhY3RpdmVUZXN0Lm9uQ29tcGxldGVkKHRpY2tzKV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHggPSBzZWxmLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcbiAgICAgICAgc2VsZi5vYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBzZWxmLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBvblJlamVjdGVkKGVycik7XG4gICAgICAgIHZhciBpZHggPSBzZWxmLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcbiAgICAgICAgc2VsZi5vYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKHNlbGYuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBzZWxmLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcblxuICAgIHJldHVybiBuZXdQcm9taXNlIHx8IG5ldyBNb2NrUHJvbWlzZSh0aGlzLnNjaGVkdWxlciwgdGhpcy5tZXNzYWdlcyk7XG4gIH07XG5cbiAgdmFyIEhvdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEhvdE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBIb3RPYnNlcnZhYmxlKHNjaGVkdWxlciwgbWVzc2FnZXMpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdmFyIG1lc3NhZ2UsIG5vdGlmaWNhdGlvbiwgb2JzZXJ2YWJsZSA9IHRoaXM7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgICBub3RpZmljYXRpb24gPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAoZnVuY3Rpb24gKGlubmVyTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgbWVzc2FnZS50aW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JzID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gb2JzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgICBpbm5lck5vdGlmaWNhdGlvbi5hY2NlcHQob2JzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlRW1wdHk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKG5vdGlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSG90T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXM7XG4gICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG8pO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2gobmV3IFN1YnNjcmlwdGlvbih0aGlzLnNjaGVkdWxlci5jbG9jaykpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSBvYnNlcnZhYmxlLm9ic2VydmVycy5pbmRleE9mKG8pO1xuICAgICAgICBvYnNlcnZhYmxlLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zdWJzY3JpcHRpb25zW2luZGV4XSA9IG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2YWJsZS5zdWJzY3JpcHRpb25zW2luZGV4XS5zdWJzY3JpYmUsIG9ic2VydmFibGUuc2NoZWR1bGVyLmNsb2NrKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gSG90T2JzZXJ2YWJsZTtcbiAgfSkoT2JzZXJ2YWJsZSk7XG5cbiAgdmFyIENvbGRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhDb2xkT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIENvbGRPYnNlcnZhYmxlKHNjaGVkdWxlciwgbWVzc2FnZXMpIHtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICBDb2xkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbWVzc2FnZSwgbm90aWZpY2F0aW9uLCBvYnNlcnZhYmxlID0gdGhpcztcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb24odGhpcy5zY2hlZHVsZXIuY2xvY2spKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGQgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubWVzc2FnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICAgIG5vdGlmaWNhdGlvbiA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgIChmdW5jdGlvbiAoaW5uZXJOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICBkLmFkZChvYnNlcnZhYmxlLnNjaGVkdWxlci5zY2hlZHVsZVJlbGF0aXZlKG51bGwsIG1lc3NhZ2UudGltZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5uZXJOb3RpZmljYXRpb24uYWNjZXB0KG8pO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKG5vdGlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlzcG9zYWJsZUNyZWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0gPSBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmFibGUuc3Vic2NyaXB0aW9uc1tpbmRleF0uc3Vic2NyaWJlLCBvYnNlcnZhYmxlLnNjaGVkdWxlci5jbG9jayk7XG4gICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb2xkT2JzZXJ2YWJsZTtcbiAgfSkoT2JzZXJ2YWJsZSk7XG5cbiAgLyoqIFZpcnR1YWwgdGltZSBzY2hlZHVsZXIgdXNlZCBmb3IgdGVzdGluZyBhcHBsaWNhdGlvbnMgYW5kIGxpYnJhcmllcyBidWlsdCB1c2luZyBSZWFjdGl2ZSBFeHRlbnNpb25zLiAqL1xuICBSeC5UZXN0U2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUZXN0U2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gYmFzZUNvbXBhcmVyKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID4geSA/IDEgOiAoeCA8IHkgPyAtMSA6IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRlc3RTY2hlZHVsZXIoKSB7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzLCAwLCBiYXNlQ29tcGFyZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgdGhlIHNwZWNpZmllZCB2aXJ0dWFsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIGR1ZVRpbWUgQWJzb2x1dGUgdmlydHVhbCB0aW1lIGF0IHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJuIERpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVBYnNvbHV0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICBkdWVUaW1lIDw9IHRoaXMuY2xvY2sgJiYgKGR1ZVRpbWUgPSB0aGlzLmNsb2NrICsgMSk7XG4gICAgICByZXR1cm4gX19zdXBlcl9fLnByb3RvdHlwZS5zY2hlZHVsZUFic29sdXRlLmNhbGwodGhpcywgc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHRvIGFuIGFic29sdXRlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHJlbGF0aXZlIFJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZSB0byBhZGQuXG4gICAgICogQHJldHVybiBSZXN1bHRpbmcgYWJzb2x1dGUgdmlydHVhbCB0aW1lIHN1bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWJzb2x1dGUsIHJlbGF0aXZlKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGUgKyByZWxhdGl2ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gYSBEYXRlVGltZU9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIENvcnJlc3BvbmRpbmcgRGF0ZVRpbWVPZmZzZXQgdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUudG9BYnNvbHV0ZVRpbWUgPSBmdW5jdGlvbiAoYWJzb2x1dGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShhYnNvbHV0ZSkuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIFRpbWVTcGFuIHZhbHVlIHRvIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiBDb3JyZXNwb25kaW5nIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS50b1JlbGF0aXZlVGltZSA9IGZ1bmN0aW9uICh0aW1lU3Bhbikge1xuICAgICAgcmV0dXJuIHRpbWVTcGFuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSB0ZXN0IHNjaGVkdWxlciBhbmQgdXNlcyB0aGUgc3BlY2lmaWVkIHZpcnR1YWwgdGltZXMgdG8gaW52b2tlIHRoZSBmYWN0b3J5IGZ1bmN0aW9uLCBzdWJzY3JpYmUgdG8gdGhlIHJlc3VsdGluZyBzZXF1ZW5jZSwgYW5kIGRpc3Bvc2UgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjcmVhdGUgRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIGNyZWF0ZWQgVmlydHVhbCB0aW1lIGF0IHdoaWNoIHRvIGludm9rZSB0aGUgZmFjdG9yeSB0byBjcmVhdGUgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlZCBWaXJ0dWFsIHRpbWUgYXQgd2hpY2ggdG8gc3Vic2NyaWJlIHRvIHRoZSBjcmVhdGVkIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIGRpc3Bvc2VkIFZpcnR1YWwgdGltZSBhdCB3aGljaCB0byBkaXNwb3NlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICogQHJldHVybiBPYnNlcnZlciB3aXRoIHRpbWVzdGFtcGVkIHJlY29yZGluZ3Mgb2Ygbm90aWZpY2F0aW9uIG1lc3NhZ2VzIHRoYXQgd2VyZSByZWNlaXZlZCBkdXJpbmcgdGhlIHZpcnR1YWwgdGltZSB3aW5kb3cgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2Ugd2FzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5zdGFydFNjaGVkdWxlciA9IGZ1bmN0aW9uIChjcmVhdGVGbiwgc2V0dGluZ3MpIHtcbiAgICAgIHNldHRpbmdzIHx8IChzZXR0aW5ncyA9IHt9KTtcbiAgICAgIHNldHRpbmdzLmNyZWF0ZWQgPT0gbnVsbCAmJiAoc2V0dGluZ3MuY3JlYXRlZCA9IFJlYWN0aXZlVGVzdC5jcmVhdGVkKTtcbiAgICAgIHNldHRpbmdzLnN1YnNjcmliZWQgPT0gbnVsbCAmJiAoc2V0dGluZ3Muc3Vic2NyaWJlZCA9IFJlYWN0aXZlVGVzdC5zdWJzY3JpYmVkKTtcbiAgICAgIHNldHRpbmdzLmRpc3Bvc2VkID09IG51bGwgJiYgKHNldHRpbmdzLmRpc3Bvc2VkID0gUmVhY3RpdmVUZXN0LmRpc3Bvc2VkKTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5jcmVhdGVPYnNlcnZlcigpLCBzb3VyY2UsIHN1YnNjcmlwdGlvbjtcblxuICAgICAgdGhpcy5zY2hlZHVsZUFic29sdXRlKG51bGwsIHNldHRpbmdzLmNyZWF0ZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc291cmNlID0gY3JlYXRlRm4oKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgc2V0dGluZ3Muc3Vic2NyaWJlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNjaGVkdWxlQWJzb2x1dGUobnVsbCwgc2V0dGluZ3MuZGlzcG9zZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVFbXB0eTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhvdCBvYnNlcnZhYmxlIHVzaW5nIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wZWQgbm90aWZpY2F0aW9uIG1lc3NhZ2VzIGVpdGhlciBhcyBhbiBhcnJheSBvciBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIE5vdGlmaWNhdGlvbnMgdG8gc3VyZmFjZSB0aHJvdWdoIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGF0IHRoZWlyIHNwZWNpZmllZCBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWVzLlxuICAgICAqIEByZXR1cm4gSG90IG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHRpbWluZyBvZiBzdWJzY3JpcHRpb25zIGFuZCBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZUhvdE9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgeyBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEhvdE9ic2VydmFibGUodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb2xkIG9ic2VydmFibGUgdXNpbmcgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBlZCBub3RpZmljYXRpb24gbWVzc2FnZXMgZWl0aGVyIGFzIGFuIGFycmF5IG9yIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgTm90aWZpY2F0aW9ucyB0byBzdXJmYWNlIHRocm91Z2ggdGhlIGNyZWF0ZWQgc2VxdWVuY2UgYXQgdGhlaXIgc3BlY2lmaWVkIHZpcnR1YWwgdGltZSBvZmZzZXRzIGZyb20gdGhlIHNlcXVlbmNlIHN1YnNjcmlwdGlvbiB0aW1lLlxuICAgICAqIEByZXR1cm4gQ29sZCBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSB0aW1pbmcgb2Ygc3Vic2NyaXB0aW9ucyBhbmQgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVDb2xkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7IGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29sZE9ic2VydmFibGUodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXNvbHZlZCBwcm9taXNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIGFuZCB0aWNrc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aWNrcyBUaGUgYWJzb2x1dGUgdGltZSBvZiB0aGUgcmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHlpZWxkIGF0IHRoZSBnaXZlbiB0aWNrLlxuICAgICAqIEByZXR1cm5zIHtNb2NrUHJvbWlzZX0gQSBtb2NrIFByb21pc2Ugd2hpY2ggZnVsZmlsbHMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICovXG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlUmVzb2x2ZWRQcm9taXNlID0gZnVuY3Rpb24gKHRpY2tzLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBNb2NrUHJvbWlzZSh0aGlzLCBbUnguUmVhY3RpdmVUZXN0Lm9uTmV4dCh0aWNrcywgdmFsdWUpLCBSeC5SZWFjdGl2ZVRlc3Qub25Db21wbGV0ZWQodGlja3MpXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWplY3RlZCBwcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlYXNvbiBhbmQgdGlja3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGlja3MgVGhlIGFic29sdXRlIHRpbWUgb2YgdGhlIHJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtBbnl9IHJlYXNvbiBUaGUgcmVhc29uIGZvciByZWplY3Rpb24gdG8geWllbGQgYXQgdGhlIGdpdmVuIHRpY2suXG4gICAgICogQHJldHVybnMge01vY2tQcm9taXNlfSBBIG1vY2sgUHJvbWlzZSB3aGljaCByZWplY3RzIHdpdGggdGhlIGdpdmVuIHJlYXNvbi5cbiAgICAgKi9cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVSZWplY3RlZFByb21pc2UgPSBmdW5jdGlvbiAodGlja3MsIHJlYXNvbikge1xuICAgICAgcmV0dXJuIG5ldyBNb2NrUHJvbWlzZSh0aGlzLCBbUnguUmVhY3RpdmVUZXN0Lm9uRXJyb3IodGlja3MsIHJlYXNvbildKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZlciB0aGF0IHJlY29yZHMgcmVjZWl2ZWQgbm90aWZpY2F0aW9uIG1lc3NhZ2VzIGFuZCB0aW1lc3RhbXBzIHRob3NlLlxuICAgICAqIEByZXR1cm4gT2JzZXJ2ZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHRpbWluZyBvZiByZWNlaXZlZCBub3RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNb2NrT2JzZXJ2ZXIodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUZXN0U2NoZWR1bGVyO1xuICB9KShWaXJ0dWFsVGltZVNjaGVkdWxlcik7XG5cbiAgcmV0dXJuIFJ4O1xufSkpO1xuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJvYmplY3RUeXBlcyIsImNoZWNrR2xvYmFsIiwidmFsdWUiLCJPYmplY3QiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwiZnJlZVdpbmRvdyIsIndpbmRvdyIsIm1vZHVsZUV4cG9ydHMiLCJ0aGlzR2xvYmFsIiwicm9vdCIsIkZ1bmN0aW9uIiwiZGVmaW5lIiwiYW1kIiwiUngiLCJyZXF1aXJlIiwiY2FsbCIsImV4cCIsInVuZGVmaW5lZCIsIk9ic2VydmVyIiwiT2JzZXJ2YWJsZSIsIk5vdGlmaWNhdGlvbiIsIlZpcnR1YWxUaW1lU2NoZWR1bGVyIiwiRGlzcG9zYWJsZSIsImRpc3Bvc2FibGVFbXB0eSIsImVtcHR5IiwiZGlzcG9zYWJsZUNyZWF0ZSIsImNyZWF0ZSIsIkNvbXBvc2l0ZURpc3Bvc2FibGUiLCJpbmhlcml0cyIsImludGVybmFscyIsImRlZmF1bHRDb21wYXJlciIsImlzRXF1YWwiLCJPbk5leHRQcmVkaWNhdGUiLCJwcmVkaWNhdGUiLCJwcm90b3R5cGUiLCJlcXVhbHMiLCJvdGhlciIsImtpbmQiLCJPbkVycm9yUHJlZGljYXRlIiwiZXJyb3IiLCJSZWFjdGl2ZVRlc3QiLCJjcmVhdGVkIiwic3Vic2NyaWJlZCIsImRpc3Bvc2VkIiwib25OZXh0IiwidGlja3MiLCJSZWNvcmRlZCIsImNyZWF0ZU9uTmV4dCIsIm9uRXJyb3IiLCJjcmVhdGVPbkVycm9yIiwib25Db21wbGV0ZWQiLCJjcmVhdGVPbkNvbXBsZXRlZCIsInN1YnNjcmliZSIsInN0YXJ0IiwiZW5kIiwiU3Vic2NyaXB0aW9uIiwidGltZSIsImNvbXBhcmVyIiwidG9TdHJpbmciLCJ1bnN1YnNjcmliZSIsIk51bWJlciIsIk1BWF9WQUxVRSIsIk1vY2tEaXNwb3NhYmxlIiwic2NoZWR1bGVyIiwiZGlzcG9zZXMiLCJwdXNoIiwiY2xvY2siLCJkaXNwb3NlIiwiTW9ja09ic2VydmVyIiwiX19zdXBlcl9fIiwibWVzc2FnZXMiLCJNb2NrT2JzZXJ2ZXJQcm90b3R5cGUiLCJlIiwiTW9ja1Byb21pc2UiLCJzdWJzY3JpcHRpb25zIiwib2JzZXJ2ZXJzIiwiaSIsImxlbiIsImxlbmd0aCIsIm1lc3NhZ2UiLCJub3RpZmljYXRpb24iLCJpbm5lck5vdGlmaWNhdGlvbiIsInNjaGVkdWxlQWJzb2x1dGUiLCJvYnMiLCJzbGljZSIsImoiLCJqTGVuIiwiYWNjZXB0IiwidGhlbiIsIm9uUmVzb2x2ZWQiLCJvblJlamVjdGVkIiwiaW5kZXgiLCJuZXdQcm9taXNlIiwib2JzZXJ2ZXIiLCJ4IiwicmV0VmFsdWUiLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwiZXJyIiwiSG90T2JzZXJ2YWJsZSIsIm9ic2VydmFibGUiLCJfc3Vic2NyaWJlIiwibyIsIkNvbGRPYnNlcnZhYmxlIiwiZCIsImFkZCIsInNjaGVkdWxlUmVsYXRpdmUiLCJUZXN0U2NoZWR1bGVyIiwiYmFzZUNvbXBhcmVyIiwieSIsInN0YXRlIiwiZHVlVGltZSIsImFjdGlvbiIsImFic29sdXRlIiwicmVsYXRpdmUiLCJ0b0Fic29sdXRlVGltZSIsIkRhdGUiLCJnZXRUaW1lIiwidG9SZWxhdGl2ZVRpbWUiLCJ0aW1lU3BhbiIsInN0YXJ0U2NoZWR1bGVyIiwiY3JlYXRlRm4iLCJzZXR0aW5ncyIsImNyZWF0ZU9ic2VydmVyIiwic291cmNlIiwic3Vic2NyaXB0aW9uIiwiY3JlYXRlSG90T2JzZXJ2YWJsZSIsImFyZ3VtZW50cyIsImFyZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJjcmVhdGVDb2xkT2JzZXJ2YWJsZSIsImNyZWF0ZVJlc29sdmVkUHJvbWlzZSIsImNyZWF0ZVJlamVjdGVkUHJvbWlzZSIsInJlYXNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.testing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.time.js":
/*!*****************************************!*\
  !*** ./node_modules/rx/dist/rx.time.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // Refernces\n    var inherits = Rx.internals.inherits, AbstractObserver = Rx.internals.AbstractObserver, Observable = Rx.Observable, observableProto = Observable.prototype, AnonymousObservable = Rx.AnonymousObservable, ObservableBase = Rx.ObservableBase, observableDefer = Observable.defer, observableEmpty = Observable.empty, observableNever = Observable.never, observableThrow = Observable[\"throw\"], observableFromArray = Observable.fromArray, defaultScheduler = Rx.Scheduler[\"default\"], SingleAssignmentDisposable = Rx.SingleAssignmentDisposable, SerialDisposable = Rx.SerialDisposable, CompositeDisposable = Rx.CompositeDisposable, BinaryDisposable = Rx.BinaryDisposable, RefCountDisposable = Rx.RefCountDisposable, Subject = Rx.Subject, addRef = Rx.internals.addRef, normalizeTime = Rx.Scheduler.normalize, helpers = Rx.helpers, isPromise = helpers.isPromise, isFunction = helpers.isFunction, isScheduler = Rx.Scheduler.isScheduler, observableFromPromise = Observable.fromPromise;\n    var errorObj = {\n        e: {}\n    };\n    function tryCatcherGen(tryCatchTarget) {\n        return function tryCatcher() {\n            try {\n                return tryCatchTarget.apply(this, arguments);\n            } catch (e) {\n                errorObj.e = e;\n                return errorObj;\n            }\n        };\n    }\n    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n        if (!isFunction(fn)) {\n            throw new TypeError(\"fn must be a function\");\n        }\n        return tryCatcherGen(fn);\n    };\n    function thrower(e) {\n        throw e;\n    }\n    var TimerObservable = function(__super__) {\n        inherits(TimerObservable, __super__);\n        function TimerObservable(dt, s) {\n            this._dt = dt;\n            this._s = s;\n            __super__.call(this);\n        }\n        TimerObservable.prototype.subscribeCore = function(o) {\n            return this._s.scheduleFuture(o, this._dt, scheduleMethod);\n        };\n        function scheduleMethod(s, o) {\n            o.onNext(0);\n            o.onCompleted();\n        }\n        return TimerObservable;\n    }(ObservableBase);\n    function _observableTimer(dueTime, scheduler) {\n        return new TimerObservable(dueTime, scheduler);\n    }\n    function observableTimerDateAndPeriod(dueTime, period, scheduler) {\n        return new AnonymousObservable(function(observer) {\n            var d = dueTime, p = normalizeTime(period);\n            return scheduler.scheduleRecursiveFuture(0, d, function(count, self1) {\n                if (p > 0) {\n                    var now = scheduler.now();\n                    d = new Date(d.getTime() + p);\n                    d.getTime() <= now && (d = new Date(now + p));\n                }\n                observer.onNext(count);\n                self1(count + 1, new Date(d));\n            });\n        });\n    }\n    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {\n        return dueTime === period ? new AnonymousObservable(function(observer) {\n            return scheduler.schedulePeriodic(0, period, function(count) {\n                observer.onNext(count);\n                return count + 1;\n            });\n        }) : observableDefer(function() {\n            return observableTimerDateAndPeriod(new Date(scheduler.now() + dueTime), period, scheduler);\n        });\n    }\n    /**\n   *  Returns an observable sequence that produces a value after each period.\n   *\n   * @example\n   *  1 - res = Rx.Observable.interval(1000);\n   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);\n   *\n   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.\n   * @returns {Observable} An observable sequence that produces a value after each period.\n   */ var observableinterval = Observable.interval = function(period, scheduler) {\n        return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);\n    };\n    /**\n   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.\n   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.\n   */ var observableTimer = Observable.timer = function(dueTime, periodOrScheduler, scheduler) {\n        var period;\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        if (periodOrScheduler != null && typeof periodOrScheduler === \"number\") {\n            period = periodOrScheduler;\n        } else if (isScheduler(periodOrScheduler)) {\n            scheduler = periodOrScheduler;\n        }\n        if ((dueTime instanceof Date || typeof dueTime === \"number\") && period === undefined) {\n            return _observableTimer(dueTime, scheduler);\n        }\n        if (dueTime instanceof Date && period !== undefined) {\n            return observableTimerDateAndPeriod(dueTime, periodOrScheduler, scheduler);\n        }\n        return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);\n    };\n    function observableDelayRelative(source, dueTime, scheduler) {\n        return new AnonymousObservable(function(o) {\n            var active = false, cancelable = new SerialDisposable(), exception = null, q = [], running = false, subscription;\n            subscription = source.materialize().timestamp(scheduler).subscribe(function(notification) {\n                var d, shouldRun;\n                if (notification.value.kind === \"E\") {\n                    q = [];\n                    q.push(notification);\n                    exception = notification.value.error;\n                    shouldRun = !running;\n                } else {\n                    q.push({\n                        value: notification.value,\n                        timestamp: notification.timestamp + dueTime\n                    });\n                    shouldRun = !active;\n                    active = true;\n                }\n                if (shouldRun) {\n                    if (exception !== null) {\n                        o.onError(exception);\n                    } else {\n                        d = new SingleAssignmentDisposable();\n                        cancelable.setDisposable(d);\n                        d.setDisposable(scheduler.scheduleRecursiveFuture(null, dueTime, function(_, self1) {\n                            var e, recurseDueTime, result, shouldRecurse;\n                            if (exception !== null) {\n                                return;\n                            }\n                            running = true;\n                            do {\n                                result = null;\n                                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {\n                                    result = q.shift().value;\n                                }\n                                if (result !== null) {\n                                    result.accept(o);\n                                }\n                            }while (result !== null);\n                            shouldRecurse = false;\n                            recurseDueTime = 0;\n                            if (q.length > 0) {\n                                shouldRecurse = true;\n                                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());\n                            } else {\n                                active = false;\n                            }\n                            e = exception;\n                            running = false;\n                            if (e !== null) {\n                                o.onError(e);\n                            } else if (shouldRecurse) {\n                                self1(null, recurseDueTime);\n                            }\n                        }));\n                    }\n                }\n            });\n            return new BinaryDisposable(subscription, cancelable);\n        }, source);\n    }\n    function observableDelayAbsolute(source, dueTime, scheduler) {\n        return observableDefer(function() {\n            return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);\n        });\n    }\n    function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {\n        var subDelay, selector;\n        if (isFunction(subscriptionDelay)) {\n            selector = subscriptionDelay;\n        } else {\n            subDelay = subscriptionDelay;\n            selector = delayDurationSelector;\n        }\n        return new AnonymousObservable(function(o) {\n            var delays = new CompositeDisposable(), atEnd = false, subscription = new SerialDisposable();\n            function start() {\n                subscription.setDisposable(source.subscribe(function(x) {\n                    var delay = tryCatch(selector)(x);\n                    if (delay === errorObj) {\n                        return o.onError(delay.e);\n                    }\n                    var d = new SingleAssignmentDisposable();\n                    delays.add(d);\n                    d.setDisposable(delay.subscribe(function() {\n                        o.onNext(x);\n                        delays.remove(d);\n                        done();\n                    }, function(e) {\n                        o.onError(e);\n                    }, function() {\n                        o.onNext(x);\n                        delays.remove(d);\n                        done();\n                    }));\n                }, function(e) {\n                    o.onError(e);\n                }, function() {\n                    atEnd = true;\n                    subscription.dispose();\n                    done();\n                }));\n            }\n            function done() {\n                atEnd && delays.length === 0 && o.onCompleted();\n            }\n            if (!subDelay) {\n                start();\n            } else {\n                subscription.setDisposable(subDelay.subscribe(start, function(e) {\n                    o.onError(e);\n                }, start));\n            }\n            return new BinaryDisposable(subscription, delays);\n        }, source);\n    }\n    /**\n   *  Time shifts the observable sequence by dueTime.\n   *  The relative time intervals between the values are preserved.\n   *\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.\n   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Time-shifted sequence.\n   */ observableProto.delay = function() {\n        var firstArg = arguments[0];\n        if (typeof firstArg === \"number\" || firstArg instanceof Date) {\n            var dueTime = firstArg, scheduler = arguments[1];\n            isScheduler(scheduler) || (scheduler = defaultScheduler);\n            return dueTime instanceof Date ? observableDelayAbsolute(this, dueTime, scheduler) : observableDelayRelative(this, dueTime, scheduler);\n        } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {\n            return delayWithSelector(this, firstArg, arguments[1]);\n        } else {\n            throw new Error(\"Invalid arguments\");\n        }\n    };\n    var DebounceObservable = function(__super__) {\n        inherits(DebounceObservable, __super__);\n        function DebounceObservable(source, dt, s) {\n            isScheduler(s) || (s = defaultScheduler);\n            this.source = source;\n            this._dt = dt;\n            this._s = s;\n            __super__.call(this);\n        }\n        DebounceObservable.prototype.subscribeCore = function(o) {\n            var cancelable = new SerialDisposable();\n            return new BinaryDisposable(this.source.subscribe(new DebounceObserver(o, this._dt, this._s, cancelable)), cancelable);\n        };\n        return DebounceObservable;\n    }(ObservableBase);\n    var DebounceObserver = function(__super__) {\n        inherits(DebounceObserver, __super__);\n        function DebounceObserver(observer, dueTime, scheduler, cancelable) {\n            this._o = observer;\n            this._d = dueTime;\n            this._scheduler = scheduler;\n            this._c = cancelable;\n            this._v = null;\n            this._hv = false;\n            this._id = 0;\n            __super__.call(this);\n        }\n        function scheduleFuture(s, state) {\n            state.self._hv && state.self._id === state.currentId && state.self._o.onNext(state.x);\n            state.self._hv = false;\n        }\n        DebounceObserver.prototype.next = function(x) {\n            this._hv = true;\n            this._v = x;\n            var currentId = ++this._id, d = new SingleAssignmentDisposable();\n            this._c.setDisposable(d);\n            d.setDisposable(this._scheduler.scheduleFuture(this, this._d, function(_, self1) {\n                self1._hv && self1._id === currentId && self1._o.onNext(x);\n                self1._hv = false;\n            }));\n        };\n        DebounceObserver.prototype.error = function(e) {\n            this._c.dispose();\n            this._o.onError(e);\n            this._hv = false;\n            this._id++;\n        };\n        DebounceObserver.prototype.completed = function() {\n            this._c.dispose();\n            this._hv && this._o.onNext(this._v);\n            this._o.onCompleted();\n            this._hv = false;\n            this._id++;\n        };\n        return DebounceObserver;\n    }(AbstractObserver);\n    function debounceWithSelector(source, durationSelector) {\n        return new AnonymousObservable(function(o) {\n            var value, hasValue = false, cancelable = new SerialDisposable(), id = 0;\n            var subscription = source.subscribe(function(x) {\n                var throttle = tryCatch(durationSelector)(x);\n                if (throttle === errorObj) {\n                    return o.onError(throttle.e);\n                }\n                isPromise(throttle) && (throttle = observableFromPromise(throttle));\n                hasValue = true;\n                value = x;\n                id++;\n                var currentid = id, d = new SingleAssignmentDisposable();\n                cancelable.setDisposable(d);\n                d.setDisposable(throttle.subscribe(function() {\n                    hasValue && id === currentid && o.onNext(value);\n                    hasValue = false;\n                    d.dispose();\n                }, function(e) {\n                    o.onError(e);\n                }, function() {\n                    hasValue && id === currentid && o.onNext(value);\n                    hasValue = false;\n                    d.dispose();\n                }));\n            }, function(e) {\n                cancelable.dispose();\n                o.onError(e);\n                hasValue = false;\n                id++;\n            }, function() {\n                cancelable.dispose();\n                hasValue && o.onNext(value);\n                o.onCompleted();\n                hasValue = false;\n                id++;\n            });\n            return new BinaryDisposable(subscription, cancelable);\n        }, source);\n    }\n    observableProto.debounce = function() {\n        if (isFunction(arguments[0])) {\n            return debounceWithSelector(this, arguments[0]);\n        } else if (typeof arguments[0] === \"number\") {\n            return new DebounceObservable(this, arguments[0], arguments[1]);\n        } else {\n            throw new Error(\"Invalid arguments\");\n        }\n    };\n    /**\n   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.\n   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).\n   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.\n   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of windows.\n   */ observableProto.windowWithTime = observableProto.windowTime = function(timeSpan, timeShiftOrScheduler, scheduler) {\n        var source = this, timeShift;\n        timeShiftOrScheduler == null && (timeShift = timeSpan);\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        if (typeof timeShiftOrScheduler === \"number\") {\n            timeShift = timeShiftOrScheduler;\n        } else if (isScheduler(timeShiftOrScheduler)) {\n            timeShift = timeSpan;\n            scheduler = timeShiftOrScheduler;\n        }\n        return new AnonymousObservable(function(observer) {\n            var groupDisposable, nextShift = timeShift, nextSpan = timeSpan, q = [], refCountDisposable, timerD = new SerialDisposable(), totalTime = 0;\n            groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);\n            function createTimer() {\n                var m = new SingleAssignmentDisposable(), isSpan = false, isShift = false;\n                timerD.setDisposable(m);\n                if (nextSpan === nextShift) {\n                    isSpan = true;\n                    isShift = true;\n                } else if (nextSpan < nextShift) {\n                    isSpan = true;\n                } else {\n                    isShift = true;\n                }\n                var newTotalTime = isSpan ? nextSpan : nextShift, ts = newTotalTime - totalTime;\n                totalTime = newTotalTime;\n                if (isSpan) {\n                    nextSpan += timeShift;\n                }\n                if (isShift) {\n                    nextShift += timeShift;\n                }\n                m.setDisposable(scheduler.scheduleFuture(null, ts, function() {\n                    if (isShift) {\n                        var s = new Subject();\n                        q.push(s);\n                        observer.onNext(addRef(s, refCountDisposable));\n                    }\n                    isSpan && q.shift().onCompleted();\n                    createTimer();\n                }));\n            }\n            ;\n            q.push(new Subject());\n            observer.onNext(addRef(q[0], refCountDisposable));\n            createTimer();\n            groupDisposable.add(source.subscribe(function(x) {\n                for(var i = 0, len = q.length; i < len; i++){\n                    q[i].onNext(x);\n                }\n            }, function(e) {\n                for(var i = 0, len = q.length; i < len; i++){\n                    q[i].onError(e);\n                }\n                observer.onError(e);\n            }, function() {\n                for(var i = 0, len = q.length; i < len; i++){\n                    q[i].onCompleted();\n                }\n                observer.onCompleted();\n            }));\n            return refCountDisposable;\n        }, source);\n    };\n    /**\n   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.\n   * @param {Number} timeSpan Maximum time length of a window.\n   * @param {Number} count Maximum element count of a window.\n   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of windows.\n   */ observableProto.windowWithTimeOrCount = observableProto.windowTimeOrCount = function(timeSpan, count, scheduler) {\n        var source = this;\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new AnonymousObservable(function(observer) {\n            var timerD = new SerialDisposable(), groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable), n = 0, windowId = 0, s = new Subject();\n            function createTimer(id) {\n                var m = new SingleAssignmentDisposable();\n                timerD.setDisposable(m);\n                m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function() {\n                    if (id !== windowId) {\n                        return;\n                    }\n                    n = 0;\n                    var newId = ++windowId;\n                    s.onCompleted();\n                    s = new Subject();\n                    observer.onNext(addRef(s, refCountDisposable));\n                    createTimer(newId);\n                }));\n            }\n            observer.onNext(addRef(s, refCountDisposable));\n            createTimer(0);\n            groupDisposable.add(source.subscribe(function(x) {\n                var newId = 0, newWindow = false;\n                s.onNext(x);\n                if (++n === count) {\n                    newWindow = true;\n                    n = 0;\n                    newId = ++windowId;\n                    s.onCompleted();\n                    s = new Subject();\n                    observer.onNext(addRef(s, refCountDisposable));\n                }\n                newWindow && createTimer(newId);\n            }, function(e) {\n                s.onError(e);\n                observer.onError(e);\n            }, function() {\n                s.onCompleted();\n                observer.onCompleted();\n            }));\n            return refCountDisposable;\n        }, source);\n    };\n    function toArray(x) {\n        return x.toArray();\n    }\n    /**\n   *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.\n   * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).\n   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.\n   * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of buffers.\n   */ observableProto.bufferWithTime = observableProto.bufferTime = function(timeSpan, timeShiftOrScheduler, scheduler) {\n        return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);\n    };\n    function toArray(x) {\n        return x.toArray();\n    }\n    /**\n   *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.\n   * @param {Number} timeSpan Maximum time length of a buffer.\n   * @param {Number} count Maximum element count of a buffer.\n   * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of buffers.\n   */ observableProto.bufferWithTimeOrCount = observableProto.bufferTimeOrCount = function(timeSpan, count, scheduler) {\n        return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);\n    };\n    var TimeIntervalObservable = function(__super__) {\n        inherits(TimeIntervalObservable, __super__);\n        function TimeIntervalObservable(source, s) {\n            this.source = source;\n            this._s = s;\n            __super__.call(this);\n        }\n        TimeIntervalObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new TimeIntervalObserver(o, this._s));\n        };\n        return TimeIntervalObservable;\n    }(ObservableBase);\n    var TimeIntervalObserver = function(__super__) {\n        inherits(TimeIntervalObserver, __super__);\n        function TimeIntervalObserver(o, s) {\n            this._o = o;\n            this._s = s;\n            this._l = s.now();\n            __super__.call(this);\n        }\n        TimeIntervalObserver.prototype.next = function(x) {\n            var now = this._s.now(), span = now - this._l;\n            this._l = now;\n            this._o.onNext({\n                value: x,\n                interval: span\n            });\n        };\n        TimeIntervalObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TimeIntervalObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return TimeIntervalObserver;\n    }(AbstractObserver);\n    /**\n   *  Records the time interval between consecutive values in an observable sequence.\n   *\n   * @example\n   *  1 - res = source.timeInterval();\n   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);\n   *\n   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence with time interval information on values.\n   */ observableProto.timeInterval = function(scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new TimeIntervalObservable(this, scheduler);\n    };\n    var TimestampObservable = function(__super__) {\n        inherits(TimestampObservable, __super__);\n        function TimestampObservable(source, s) {\n            this.source = source;\n            this._s = s;\n            __super__.call(this);\n        }\n        TimestampObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new TimestampObserver(o, this._s));\n        };\n        return TimestampObservable;\n    }(ObservableBase);\n    var TimestampObserver = function(__super__) {\n        inherits(TimestampObserver, __super__);\n        function TimestampObserver(o, s) {\n            this._o = o;\n            this._s = s;\n            __super__.call(this);\n        }\n        TimestampObserver.prototype.next = function(x) {\n            this._o.onNext({\n                value: x,\n                timestamp: this._s.now()\n            });\n        };\n        TimestampObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TimestampObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return TimestampObserver;\n    }(AbstractObserver);\n    /**\n   *  Records the timestamp for each value in an observable sequence.\n   *\n   * @example\n   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }\n   *  2 - res = source.timestamp(Rx.Scheduler.default);\n   *\n   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the default scheduler is used.\n   * @returns {Observable} An observable sequence with timestamp information on values.\n   */ observableProto.timestamp = function(scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new TimestampObservable(this, scheduler);\n    };\n    var SampleObservable = function(__super__) {\n        inherits(SampleObservable, __super__);\n        function SampleObservable(source, sampler) {\n            this.source = source;\n            this._sampler = sampler;\n            __super__.call(this);\n        }\n        SampleObservable.prototype.subscribeCore = function(o) {\n            var state = {\n                o: o,\n                atEnd: false,\n                value: null,\n                hasValue: false,\n                sourceSubscription: new SingleAssignmentDisposable()\n            };\n            state.sourceSubscription.setDisposable(this.source.subscribe(new SampleSourceObserver(state)));\n            return new BinaryDisposable(state.sourceSubscription, this._sampler.subscribe(new SamplerObserver(state)));\n        };\n        return SampleObservable;\n    }(ObservableBase);\n    var SamplerObserver = function(__super__) {\n        inherits(SamplerObserver, __super__);\n        function SamplerObserver(s) {\n            this._s = s;\n            __super__.call(this);\n        }\n        SamplerObserver.prototype._handleMessage = function() {\n            if (this._s.hasValue) {\n                this._s.hasValue = false;\n                this._s.o.onNext(this._s.value);\n            }\n            this._s.atEnd && this._s.o.onCompleted();\n        };\n        SamplerObserver.prototype.next = function() {\n            this._handleMessage();\n        };\n        SamplerObserver.prototype.error = function(e) {\n            this._s.onError(e);\n        };\n        SamplerObserver.prototype.completed = function() {\n            this._handleMessage();\n        };\n        return SamplerObserver;\n    }(AbstractObserver);\n    var SampleSourceObserver = function(__super__) {\n        inherits(SampleSourceObserver, __super__);\n        function SampleSourceObserver(s) {\n            this._s = s;\n            __super__.call(this);\n        }\n        SampleSourceObserver.prototype.next = function(x) {\n            this._s.hasValue = true;\n            this._s.value = x;\n        };\n        SampleSourceObserver.prototype.error = function(e) {\n            this._s.o.onError(e);\n        };\n        SampleSourceObserver.prototype.completed = function() {\n            this._s.atEnd = true;\n            this._s.sourceSubscription.dispose();\n        };\n        return SampleSourceObserver;\n    }(AbstractObserver);\n    /**\n   *  Samples the observable sequence at each interval.\n   *\n   * @example\n   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence\n   *  2 - res = source.sample(5000); // 5 seconds\n   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds\n   *\n   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.\n   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Sampled observable sequence.\n   */ observableProto.sample = function(intervalOrSampler, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return typeof intervalOrSampler === \"number\" ? new SampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : new SampleObservable(this, intervalOrSampler);\n    };\n    var TimeoutError = Rx.TimeoutError = function(message) {\n        this.message = message || \"Timeout has occurred\";\n        this.name = \"TimeoutError\";\n        Error.call(this);\n    };\n    TimeoutError.prototype = Object.create(Error.prototype);\n    function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {\n        if (isFunction(firstTimeout)) {\n            other = timeoutDurationSelector;\n            timeoutDurationSelector = firstTimeout;\n            firstTimeout = observableNever();\n        }\n        Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));\n        return new AnonymousObservable(function(o) {\n            var subscription = new SerialDisposable(), timer = new SerialDisposable(), original = new SingleAssignmentDisposable();\n            subscription.setDisposable(original);\n            var id = 0, switched = false;\n            function setTimer(timeout) {\n                var myId = id, d = new SingleAssignmentDisposable();\n                function timerWins() {\n                    switched = myId === id;\n                    return switched;\n                }\n                timer.setDisposable(d);\n                d.setDisposable(timeout.subscribe(function() {\n                    timerWins() && subscription.setDisposable(other.subscribe(o));\n                    d.dispose();\n                }, function(e) {\n                    timerWins() && o.onError(e);\n                }, function() {\n                    timerWins() && subscription.setDisposable(other.subscribe(o));\n                }));\n            }\n            ;\n            setTimer(firstTimeout);\n            function oWins() {\n                var res = !switched;\n                if (res) {\n                    id++;\n                }\n                return res;\n            }\n            original.setDisposable(source.subscribe(function(x) {\n                if (oWins()) {\n                    o.onNext(x);\n                    var timeout = tryCatch(timeoutDurationSelector)(x);\n                    if (timeout === errorObj) {\n                        return o.onError(timeout.e);\n                    }\n                    setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);\n                }\n            }, function(e) {\n                oWins() && o.onError(e);\n            }, function() {\n                oWins() && o.onCompleted();\n            }));\n            return new BinaryDisposable(subscription, timer);\n        }, source);\n    }\n    function timeout(source, dueTime, other, scheduler) {\n        if (isScheduler(other)) {\n            scheduler = other;\n            other = observableThrow(new TimeoutError());\n        }\n        if (other instanceof Error) {\n            other = observableThrow(other);\n        }\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));\n        return new AnonymousObservable(function(o) {\n            var id = 0, original = new SingleAssignmentDisposable(), subscription = new SerialDisposable(), switched = false, timer = new SerialDisposable();\n            subscription.setDisposable(original);\n            function createTimer() {\n                var myId = id;\n                timer.setDisposable(scheduler.scheduleFuture(null, dueTime, function() {\n                    switched = id === myId;\n                    if (switched) {\n                        isPromise(other) && (other = observableFromPromise(other));\n                        subscription.setDisposable(other.subscribe(o));\n                    }\n                }));\n            }\n            createTimer();\n            original.setDisposable(source.subscribe(function(x) {\n                if (!switched) {\n                    id++;\n                    o.onNext(x);\n                    createTimer();\n                }\n            }, function(e) {\n                if (!switched) {\n                    id++;\n                    o.onError(e);\n                }\n            }, function() {\n                if (!switched) {\n                    id++;\n                    o.onCompleted();\n                }\n            }));\n            return new BinaryDisposable(subscription, timer);\n        }, source);\n    }\n    observableProto.timeout = function() {\n        var firstArg = arguments[0];\n        if (firstArg instanceof Date || typeof firstArg === \"number\") {\n            return timeout(this, firstArg, arguments[1], arguments[2]);\n        } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {\n            return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);\n        } else {\n            throw new Error(\"Invalid arguments\");\n        }\n    };\n    var GenerateAbsoluteObservable = function(__super__) {\n        inherits(GenerateAbsoluteObservable, __super__);\n        function GenerateAbsoluteObservable(state, cndFn, itrFn, resFn, timeFn, s) {\n            this._state = state;\n            this._cndFn = cndFn;\n            this._itrFn = itrFn;\n            this._resFn = resFn;\n            this._timeFn = timeFn;\n            this._s = s;\n            __super__.call(this);\n        }\n        function scheduleRecursive(state, recurse) {\n            state.hasResult && state.o.onNext(state.result);\n            if (state.first) {\n                state.first = false;\n            } else {\n                state.newState = tryCatch(state.self._itrFn)(state.newState);\n                if (state.newState === errorObj) {\n                    return state.o.onError(state.newState.e);\n                }\n            }\n            state.hasResult = tryCatch(state.self._cndFn)(state.newState);\n            if (state.hasResult === errorObj) {\n                return state.o.onError(state.hasResult.e);\n            }\n            if (state.hasResult) {\n                state.result = tryCatch(state.self._resFn)(state.newState);\n                if (state.result === errorObj) {\n                    return state.o.onError(state.result.e);\n                }\n                var time = tryCatch(state.self._timeFn)(state.newState);\n                if (time === errorObj) {\n                    return state.o.onError(time.e);\n                }\n                recurse(state, time);\n            } else {\n                state.o.onCompleted();\n            }\n        }\n        GenerateAbsoluteObservable.prototype.subscribeCore = function(o) {\n            var state = {\n                o: o,\n                self: this,\n                newState: this._state,\n                first: true,\n                hasResult: false\n            };\n            return this._s.scheduleRecursiveFuture(state, new Date(this._s.now()), scheduleRecursive);\n        };\n        return GenerateAbsoluteObservable;\n    }(ObservableBase);\n    /**\n   *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.\n   *\n   * @example\n   *  res = source.generateWithAbsoluteTime(0,\n   *      function (x) { return return true; },\n   *      function (x) { return x + 1; },\n   *      function (x) { return x; },\n   *      function (x) { return new Date(); }\n   *  });\n   *\n   * @param {Mixed} initialState Initial state.\n   * @param {Function} condition Condition to terminate generation (upon returning false).\n   * @param {Function} iterate Iteration step function.\n   * @param {Function} resultSelector Selector function for results produced in the sequence.\n   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.\n   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.\n   * @returns {Observable} The generated sequence.\n   */ Observable.generateWithAbsoluteTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);\n    };\n    var GenerateRelativeObservable = function(__super__) {\n        inherits(GenerateRelativeObservable, __super__);\n        function GenerateRelativeObservable(state, cndFn, itrFn, resFn, timeFn, s) {\n            this._state = state;\n            this._cndFn = cndFn;\n            this._itrFn = itrFn;\n            this._resFn = resFn;\n            this._timeFn = timeFn;\n            this._s = s;\n            __super__.call(this);\n        }\n        function scheduleRecursive(state, recurse) {\n            state.hasResult && state.o.onNext(state.result);\n            if (state.first) {\n                state.first = false;\n            } else {\n                state.newState = tryCatch(state.self._itrFn)(state.newState);\n                if (state.newState === errorObj) {\n                    return state.o.onError(state.newState.e);\n                }\n            }\n            state.hasResult = tryCatch(state.self._cndFn)(state.newState);\n            if (state.hasResult === errorObj) {\n                return state.o.onError(state.hasResult.e);\n            }\n            if (state.hasResult) {\n                state.result = tryCatch(state.self._resFn)(state.newState);\n                if (state.result === errorObj) {\n                    return state.o.onError(state.result.e);\n                }\n                var time = tryCatch(state.self._timeFn)(state.newState);\n                if (time === errorObj) {\n                    return state.o.onError(time.e);\n                }\n                recurse(state, time);\n            } else {\n                state.o.onCompleted();\n            }\n        }\n        GenerateRelativeObservable.prototype.subscribeCore = function(o) {\n            var state = {\n                o: o,\n                self: this,\n                newState: this._state,\n                first: true,\n                hasResult: false\n            };\n            return this._s.scheduleRecursiveFuture(state, 0, scheduleRecursive);\n        };\n        return GenerateRelativeObservable;\n    }(ObservableBase);\n    /**\n   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.\n   *\n   * @example\n   *  res = source.generateWithRelativeTime(0,\n   *      function (x) { return return true; },\n   *      function (x) { return x + 1; },\n   *      function (x) { return x; },\n   *      function (x) { return 500; }\n   *  );\n   *\n   * @param {Mixed} initialState Initial state.\n   * @param {Function} condition Condition to terminate generation (upon returning false).\n   * @param {Function} iterate Iteration step function.\n   * @param {Function} resultSelector Selector function for results produced in the sequence.\n   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.\n   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.\n   * @returns {Observable} The generated sequence.\n   */ Observable.generateWithRelativeTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);\n    };\n    var DelaySubscription = function(__super__) {\n        inherits(DelaySubscription, __super__);\n        function DelaySubscription(source, dt, s) {\n            this.source = source;\n            this._dt = dt;\n            this._s = s;\n            __super__.call(this);\n        }\n        DelaySubscription.prototype.subscribeCore = function(o) {\n            var d = new SerialDisposable();\n            d.setDisposable(this._s.scheduleFuture([\n                this.source,\n                o,\n                d\n            ], this._dt, scheduleMethod));\n            return d;\n        };\n        function scheduleMethod(s, state) {\n            var source = state[0], o = state[1], d = state[2];\n            d.setDisposable(source.subscribe(o));\n        }\n        return DelaySubscription;\n    }(ObservableBase);\n    /**\n   *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.\n   *\n   * @example\n   *  1 - res = source.delaySubscription(5000); // 5s\n   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds\n   *\n   * @param {Number} dueTime Relative or absolute time shift of the subscription.\n   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Time-shifted sequence.\n   */ observableProto.delaySubscription = function(dueTime, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new DelaySubscription(this, dueTime, scheduler);\n    };\n    var SkipLastWithTimeObservable = function(__super__) {\n        inherits(SkipLastWithTimeObservable, __super__);\n        function SkipLastWithTimeObservable(source, d, s) {\n            this.source = source;\n            this._d = d;\n            this._s = s;\n            __super__.call(this);\n        }\n        SkipLastWithTimeObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new SkipLastWithTimeObserver(o, this));\n        };\n        return SkipLastWithTimeObservable;\n    }(ObservableBase);\n    var SkipLastWithTimeObserver = function(__super__) {\n        inherits(SkipLastWithTimeObserver, __super__);\n        function SkipLastWithTimeObserver(o, p) {\n            this._o = o;\n            this._s = p._s;\n            this._d = p._d;\n            this._q = [];\n            __super__.call(this);\n        }\n        SkipLastWithTimeObserver.prototype.next = function(x) {\n            var now = this._s.now();\n            this._q.push({\n                interval: now,\n                value: x\n            });\n            while(this._q.length > 0 && now - this._q[0].interval >= this._d){\n                this._o.onNext(this._q.shift().value);\n            }\n        };\n        SkipLastWithTimeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SkipLastWithTimeObserver.prototype.completed = function() {\n            var now = this._s.now();\n            while(this._q.length > 0 && now - this._q[0].interval >= this._d){\n                this._o.onNext(this._q.shift().value);\n            }\n            this._o.onCompleted();\n        };\n        return SkipLastWithTimeObserver;\n    }(AbstractObserver);\n    /**\n   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for skipping elements from the end of the sequence.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout\n   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.\n   */ observableProto.skipLastWithTime = function(duration, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new SkipLastWithTimeObservable(this, duration, scheduler);\n    };\n    var TakeLastWithTimeObservable = function(__super__) {\n        inherits(TakeLastWithTimeObservable, __super__);\n        function TakeLastWithTimeObservable(source, d, s) {\n            this.source = source;\n            this._d = d;\n            this._s = s;\n            __super__.call(this);\n        }\n        TakeLastWithTimeObservable.prototype.subscribeCore = function(o) {\n            return this.source.subscribe(new TakeLastWithTimeObserver(o, this._d, this._s));\n        };\n        return TakeLastWithTimeObservable;\n    }(ObservableBase);\n    var TakeLastWithTimeObserver = function(__super__) {\n        inherits(TakeLastWithTimeObserver, __super__);\n        function TakeLastWithTimeObserver(o, d, s) {\n            this._o = o;\n            this._d = d;\n            this._s = s;\n            this._q = [];\n            __super__.call(this);\n        }\n        TakeLastWithTimeObserver.prototype.next = function(x) {\n            var now = this._s.now();\n            this._q.push({\n                interval: now,\n                value: x\n            });\n            while(this._q.length > 0 && now - this._q[0].interval >= this._d){\n                this._q.shift();\n            }\n        };\n        TakeLastWithTimeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        TakeLastWithTimeObserver.prototype.completed = function() {\n            var now = this._s.now();\n            while(this._q.length > 0){\n                var next = this._q.shift();\n                if (now - next.interval <= this._d) {\n                    this._o.onNext(next.value);\n                }\n            }\n            this._o.onCompleted();\n        };\n        return TakeLastWithTimeObserver;\n    }(AbstractObserver);\n    /**\n   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for taking elements from the end of the sequence.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.\n   */ observableProto.takeLastWithTime = function(duration, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new TakeLastWithTimeObservable(this, duration, scheduler);\n    };\n    /**\n   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for taking elements from the end of the sequence.\n   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.\n   */ observableProto.takeLastBufferWithTime = function(duration, scheduler) {\n        var source = this;\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new AnonymousObservable(function(o) {\n            var q = [];\n            return source.subscribe(function(x) {\n                var now = scheduler.now();\n                q.push({\n                    interval: now,\n                    value: x\n                });\n                while(q.length > 0 && now - q[0].interval >= duration){\n                    q.shift();\n                }\n            }, function(e) {\n                o.onError(e);\n            }, function() {\n                var now = scheduler.now(), res = [];\n                while(q.length > 0){\n                    var next = q.shift();\n                    now - next.interval <= duration && res.push(next.value);\n                }\n                o.onNext(res);\n                o.onCompleted();\n            });\n        }, source);\n    };\n    var TakeWithTimeObservable = function(__super__) {\n        inherits(TakeWithTimeObservable, __super__);\n        function TakeWithTimeObservable(source, d, s) {\n            this.source = source;\n            this._d = d;\n            this._s = s;\n            __super__.call(this);\n        }\n        function scheduleMethod(s, o) {\n            o.onCompleted();\n        }\n        TakeWithTimeObservable.prototype.subscribeCore = function(o) {\n            return new BinaryDisposable(this._s.scheduleFuture(o, this._d, scheduleMethod), this.source.subscribe(o));\n        };\n        return TakeWithTimeObservable;\n    }(ObservableBase);\n    /**\n   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.\n   *\n   * @example\n   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for taking elements from the start of the sequence.\n   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.\n   */ observableProto.takeWithTime = function(duration, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new TakeWithTimeObservable(this, duration, scheduler);\n    };\n    var SkipWithTimeObservable = function(__super__) {\n        inherits(SkipWithTimeObservable, __super__);\n        function SkipWithTimeObservable(source, d, s) {\n            this.source = source;\n            this._d = d;\n            this._s = s;\n            this._open = false;\n            __super__.call(this);\n        }\n        function scheduleMethod(s, self1) {\n            self1._open = true;\n        }\n        SkipWithTimeObservable.prototype.subscribeCore = function(o) {\n            return new BinaryDisposable(this._s.scheduleFuture(this, this._d, scheduleMethod), this.source.subscribe(new SkipWithTimeObserver(o, this)));\n        };\n        return SkipWithTimeObservable;\n    }(ObservableBase);\n    var SkipWithTimeObserver = function(__super__) {\n        inherits(SkipWithTimeObserver, __super__);\n        function SkipWithTimeObserver(o, p) {\n            this._o = o;\n            this._p = p;\n            __super__.call(this);\n        }\n        SkipWithTimeObserver.prototype.next = function(x) {\n            this._p._open && this._o.onNext(x);\n        };\n        SkipWithTimeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SkipWithTimeObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return SkipWithTimeObserver;\n    }(AbstractObserver);\n    /**\n   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.\n   * @description\n   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.\n   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded\n   *  may not execute immediately, despite the zero due time.\n   *\n   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.\n   * @param {Number} duration Duration for skipping elements from the start of the sequence.\n   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.\n   */ observableProto.skipWithTime = function(duration, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new SkipWithTimeObservable(this, duration, scheduler);\n    };\n    var SkipUntilWithTimeObservable = function(__super__) {\n        inherits(SkipUntilWithTimeObservable, __super__);\n        function SkipUntilWithTimeObservable(source, startTime, scheduler) {\n            this.source = source;\n            this._st = startTime;\n            this._s = scheduler;\n            __super__.call(this);\n        }\n        function scheduleMethod(s, state) {\n            state._open = true;\n        }\n        SkipUntilWithTimeObservable.prototype.subscribeCore = function(o) {\n            this._open = false;\n            return new BinaryDisposable(this._s.scheduleFuture(this, this._st, scheduleMethod), this.source.subscribe(new SkipUntilWithTimeObserver(o, this)));\n        };\n        return SkipUntilWithTimeObservable;\n    }(ObservableBase);\n    var SkipUntilWithTimeObserver = function(__super__) {\n        inherits(SkipUntilWithTimeObserver, __super__);\n        function SkipUntilWithTimeObserver(o, p) {\n            this._o = o;\n            this._p = p;\n            __super__.call(this);\n        }\n        SkipUntilWithTimeObserver.prototype.next = function(x) {\n            this._p._open && this._o.onNext(x);\n        };\n        SkipUntilWithTimeObserver.prototype.error = function(e) {\n            this._o.onError(e);\n        };\n        SkipUntilWithTimeObserver.prototype.completed = function() {\n            this._o.onCompleted();\n        };\n        return SkipUntilWithTimeObserver;\n    }(AbstractObserver);\n    /**\n   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.\n   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.\n   *\n   * @examples\n   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);\n   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);\n   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.\n   */ observableProto.skipUntilWithTime = function(startTime, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        return new SkipUntilWithTimeObservable(this, startTime, scheduler);\n    };\n    /**\n   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.\n   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on.\n   * @returns {Observable} An observable sequence with the elements taken until the specified end time.\n   */ observableProto.takeUntilWithTime = function(endTime, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        var source = this;\n        return new AnonymousObservable(function(o) {\n            return new BinaryDisposable(scheduler.scheduleFuture(o, endTime, function(_, o) {\n                o.onCompleted();\n            }), source.subscribe(o));\n        }, source);\n    };\n    /**\n   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.\n   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item\n   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.\n   * @returns {Observable} An Observable that performs the throttle operation.\n   */ observableProto.throttle = function(windowDuration, scheduler) {\n        isScheduler(scheduler) || (scheduler = defaultScheduler);\n        var duration = +windowDuration || 0;\n        if (duration <= 0) {\n            throw new RangeError(\"windowDuration cannot be less or equal zero.\");\n        }\n        var source = this;\n        return new AnonymousObservable(function(o) {\n            var lastOnNext = 0;\n            return source.subscribe(function(x) {\n                var now = scheduler.now();\n                if (lastOnNext === 0 || now - lastOnNext >= duration) {\n                    lastOnNext = now;\n                    o.onNext(x);\n                }\n            }, function(e) {\n                o.onError(e);\n            }, function() {\n                o.onCompleted();\n            });\n        }, source);\n    };\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC50aW1lLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw2S0FBNkc7O0FBRTNHLFVBQVVBLE9BQU87SUFDakIsSUFBSUMsY0FBYztRQUNoQixZQUFZO1FBQ1osVUFBVTtJQUNaO0lBRUEsU0FBU0MsWUFBWUMsS0FBSztRQUN4QixPQUFPLFNBQVVBLE1BQU1DLE1BQU0sS0FBS0EsU0FBVUQsUUFBUTtJQUN0RDtJQUVBLElBQUlFLGNBQWMsV0FBWSxDQUFDLE9BQU9DLFFBQVEsSUFBSUEsV0FBVyxDQUFDQSxRQUFRQyxRQUFRLEdBQUlELFVBQVU7SUFDNUYsSUFBSUUsYUFBYSxXQUFZLENBQUMsUUFBYUMsQ0FBQyxJQUFJQSxVQUFVLENBQUNBLE9BQU9GLFFBQVEsR0FBSUUsU0FBUztJQUN2RixJQUFJQyxhQUFhUixZQUFZRyxlQUFlRyxjQUFjLE9BQU9HLFdBQVcsWUFBWUE7SUFDeEYsSUFBSUMsV0FBV1YsWUFBWUQsV0FBVyxDQUFDLE9BQU9ZLEtBQUssSUFBSUE7SUFDdkQsSUFBSUMsYUFBYVosWUFBWUQsV0FBVyxDQUFDLFlBQWMsSUFBSWM7SUFDM0QsSUFBSUMsZ0JBQWdCLGNBQWVSLFdBQVdGLE9BQU8sS0FBS0QsY0FBZUEsY0FBYztJQUN2RixJQUFJWSxhQUFhZixZQUFZRCxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJO0lBQzdELElBQUlpQixPQUFPUixjQUFlLGVBQWlCTyxDQUFBQSxjQUFjQSxXQUFXRixNQUFNLEtBQU1ELGNBQWVGLFlBQVlLLGNBQWNFLFNBQVM7SUFFbEksOEJBQThCO0lBQzlCLElBQUksSUFBMEMsRUFBRTtRQUM5Q0MsaUNBQU87WUFBQztTQUFPLG1DQUFFLFNBQVVFLEVBQUUsRUFBRWhCLFFBQU87WUFDcEMsT0FBT04sUUFBUWtCLE1BQU1aLFVBQVNnQjtRQUNoQyxDQUFDO0FBQUEsa0dBQUM7SUFDSixPQUFPLEVBSU47QUFDSCxHQUFFRSxJQUFJLENBQUMsUUFBTSxTQUFVTixJQUFJLEVBQUVPLEdBQUcsRUFBRUgsRUFBRSxFQUFFSSxTQUFTO0lBRTdDLFlBQVk7SUFDWixJQUFJQyxXQUFXTCxHQUFHTSxTQUFTLENBQUNELFFBQVEsRUFDbENFLG1CQUFtQlAsR0FBR00sU0FBUyxDQUFDQyxnQkFBZ0IsRUFDaERDLGFBQWFSLEdBQUdRLFVBQVUsRUFDMUJDLGtCQUFrQkQsV0FBV0UsU0FBUyxFQUN0Q0Msc0JBQXNCWCxHQUFHVyxtQkFBbUIsRUFDNUNDLGlCQUFpQlosR0FBR1ksY0FBYyxFQUNsQ0Msa0JBQWtCTCxXQUFXTSxLQUFLLEVBQ2xDQyxrQkFBa0JQLFdBQVdRLEtBQUssRUFDbENDLGtCQUFrQlQsV0FBV1UsS0FBSyxFQUNsQ0Msa0JBQWtCWCxVQUFVLENBQUMsUUFBUSxFQUNyQ1ksc0JBQXNCWixXQUFXYSxTQUFTLEVBQzFDQyxtQkFBbUJ0QixHQUFHdUIsU0FBUyxDQUFDLFVBQVUsRUFDMUNDLDZCQUE2QnhCLEdBQUd3QiwwQkFBMEIsRUFDMURDLG1CQUFtQnpCLEdBQUd5QixnQkFBZ0IsRUFDdENDLHNCQUFzQjFCLEdBQUcwQixtQkFBbUIsRUFDNUNDLG1CQUFtQjNCLEdBQUcyQixnQkFBZ0IsRUFDdENDLHFCQUFxQjVCLEdBQUc0QixrQkFBa0IsRUFDMUNDLFVBQVU3QixHQUFHNkIsT0FBTyxFQUNwQkMsU0FBUzlCLEdBQUdNLFNBQVMsQ0FBQ3dCLE1BQU0sRUFDNUJDLGdCQUFnQi9CLEdBQUd1QixTQUFTLENBQUNTLFNBQVMsRUFDdENDLFVBQVVqQyxHQUFHaUMsT0FBTyxFQUNwQkMsWUFBWUQsUUFBUUMsU0FBUyxFQUM3QkMsYUFBYUYsUUFBUUUsVUFBVSxFQUMvQkMsY0FBY3BDLEdBQUd1QixTQUFTLENBQUNhLFdBQVcsRUFDdENDLHdCQUF3QjdCLFdBQVc4QixXQUFXO0lBRWhELElBQUlDLFdBQVc7UUFBQ0MsR0FBRyxDQUFDO0lBQUM7SUFFckIsU0FBU0MsY0FBY0MsY0FBYztRQUNuQyxPQUFPLFNBQVNDO1lBQ2QsSUFBSTtnQkFDRixPQUFPRCxlQUFlRSxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUNwQyxFQUFFLE9BQU9MLEdBQUc7Z0JBQ1ZELFNBQVNDLENBQUMsR0FBR0E7Z0JBQ2IsT0FBT0Q7WUFDVDtRQUNGO0lBQ0Y7SUFFQSxJQUFJTyxXQUFXOUMsR0FBR00sU0FBUyxDQUFDd0MsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLEVBQUU7UUFDekQsSUFBSSxDQUFDWixXQUFXWSxLQUFLO1lBQUUsTUFBTSxJQUFJQyxVQUFVO1FBQTBCO1FBQ3JFLE9BQU9QLGNBQWNNO0lBQ3ZCO0lBRUEsU0FBU0UsUUFBUVQsQ0FBQztRQUNoQixNQUFNQTtJQUNSO0lBRUEsSUFBSVUsa0JBQW1CLFNBQVNDLFNBQVM7UUFDdkM5QyxTQUFTNkMsaUJBQWlCQztRQUMxQixTQUFTRCxnQkFBZ0JFLEVBQUUsRUFBRUMsQ0FBQztZQUM1QixJQUFJLENBQUNDLEdBQUcsR0FBR0Y7WUFDWCxJQUFJLENBQUNHLEVBQUUsR0FBR0Y7WUFDVkYsVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUFnRCxnQkFBZ0J4QyxTQUFTLENBQUM4QyxhQUFhLEdBQUcsU0FBVUMsQ0FBQztZQUNuRCxPQUFPLElBQUksQ0FBQ0YsRUFBRSxDQUFDRyxjQUFjLENBQUNELEdBQUcsSUFBSSxDQUFDSCxHQUFHLEVBQUVLO1FBQzdDO1FBRUEsU0FBU0EsZUFBZU4sQ0FBQyxFQUFFSSxDQUFDO1lBQzFCQSxFQUFFRyxNQUFNLENBQUM7WUFDVEgsRUFBRUksV0FBVztRQUNmO1FBRUEsT0FBT1g7SUFDVCxFQUFFdEM7SUFFRixTQUFTa0QsaUJBQWlCQyxPQUFPLEVBQUVDLFNBQVM7UUFDMUMsT0FBTyxJQUFJZCxnQkFBZ0JhLFNBQVNDO0lBQ3RDO0lBRUEsU0FBU0MsNkJBQTZCRixPQUFPLEVBQUVHLE1BQU0sRUFBRUYsU0FBUztRQUM5RCxPQUFPLElBQUlyRCxvQkFBb0IsU0FBVXdELFFBQVE7WUFDL0MsSUFBSUMsSUFBSUwsU0FBU00sSUFBSXRDLGNBQWNtQztZQUNuQyxPQUFPRixVQUFVTSx1QkFBdUIsQ0FBQyxHQUFHRixHQUFHLFNBQVVHLEtBQUssRUFBRWhGLEtBQUk7Z0JBQ2xFLElBQUk4RSxJQUFJLEdBQUc7b0JBQ1QsSUFBSUcsTUFBTVIsVUFBVVEsR0FBRztvQkFDdkJKLElBQUksSUFBSUssS0FBS0wsRUFBRU0sT0FBTyxLQUFLTDtvQkFDM0JELEVBQUVNLE9BQU8sTUFBTUYsT0FBUUosQ0FBQUEsSUFBSSxJQUFJSyxLQUFLRCxNQUFNSCxFQUFDO2dCQUM3QztnQkFDQUYsU0FBU1AsTUFBTSxDQUFDVztnQkFDaEJoRixNQUFLZ0YsUUFBUSxHQUFHLElBQUlFLEtBQUtMO1lBQzNCO1FBQ0Y7SUFDRjtJQUVBLFNBQVNPLGlDQUFpQ1osT0FBTyxFQUFFRyxNQUFNLEVBQUVGLFNBQVM7UUFDbEUsT0FBT0QsWUFBWUcsU0FDakIsSUFBSXZELG9CQUFvQixTQUFVd0QsUUFBUTtZQUN4QyxPQUFPSCxVQUFVWSxnQkFBZ0IsQ0FBQyxHQUFHVixRQUFRLFNBQVVLLEtBQUs7Z0JBQzFESixTQUFTUCxNQUFNLENBQUNXO2dCQUNoQixPQUFPQSxRQUFRO1lBQ2pCO1FBQ0YsS0FDQTFELGdCQUFnQjtZQUNkLE9BQU9vRCw2QkFBNkIsSUFBSVEsS0FBS1QsVUFBVVEsR0FBRyxLQUFLVCxVQUFVRyxRQUFRRjtRQUNuRjtJQUNKO0lBRUE7Ozs7Ozs7Ozs7R0FVQyxHQUNELElBQUlhLHFCQUFxQnJFLFdBQVdzRSxRQUFRLEdBQUcsU0FBVVosTUFBTSxFQUFFRixTQUFTO1FBQ3hFLE9BQU9XLGlDQUFpQ1QsUUFBUUEsUUFBUTlCLFlBQVk0QixhQUFhQSxZQUFZMUM7SUFDL0Y7SUFFQTs7Ozs7O0dBTUMsR0FDRCxJQUFJeUQsa0JBQWtCdkUsV0FBV3dFLEtBQUssR0FBRyxTQUFVakIsT0FBTyxFQUFFa0IsaUJBQWlCLEVBQUVqQixTQUFTO1FBQ3RGLElBQUlFO1FBQ0o5QixZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELElBQUkyRCxxQkFBcUIsUUFBUSxPQUFPQSxzQkFBc0IsVUFBVTtZQUN0RWYsU0FBU2U7UUFDWCxPQUFPLElBQUk3QyxZQUFZNkMsb0JBQW9CO1lBQ3pDakIsWUFBWWlCO1FBQ2Q7UUFDQSxJQUFJLENBQUNsQixtQkFBbUJVLFFBQVEsT0FBT1YsWUFBWSxRQUFPLEtBQU1HLFdBQVc5RCxXQUFXO1lBQ3BGLE9BQU8wRCxpQkFBaUJDLFNBQVNDO1FBQ25DO1FBQ0EsSUFBSUQsbUJBQW1CVSxRQUFRUCxXQUFXOUQsV0FBVztZQUNuRCxPQUFPNkQsNkJBQTZCRixTQUFTa0IsbUJBQW1CakI7UUFDbEU7UUFDQSxPQUFPVyxpQ0FBaUNaLFNBQVNHLFFBQVFGO0lBQzNEO0lBRUEsU0FBU2tCLHdCQUF3QkMsTUFBTSxFQUFFcEIsT0FBTyxFQUFFQyxTQUFTO1FBQ3pELE9BQU8sSUFBSXJELG9CQUFvQixTQUFVOEMsQ0FBQztZQUN4QyxJQUFJMkIsU0FBUyxPQUNYQyxhQUFhLElBQUk1RCxvQkFDakI2RCxZQUFZLE1BQ1pDLElBQUksRUFBRSxFQUNOQyxVQUFVLE9BQ1ZDO1lBQ0ZBLGVBQWVOLE9BQU9PLFdBQVcsR0FBR0MsU0FBUyxDQUFDM0IsV0FBVzRCLFNBQVMsQ0FBQyxTQUFVQyxZQUFZO2dCQUN2RixJQUFJekIsR0FBRzBCO2dCQUNQLElBQUlELGFBQWFoSCxLQUFLLENBQUNrSCxJQUFJLEtBQUssS0FBSztvQkFDbkNSLElBQUksRUFBRTtvQkFDTkEsRUFBRVMsSUFBSSxDQUFDSDtvQkFDUFAsWUFBWU8sYUFBYWhILEtBQUssQ0FBQ29ILEtBQUs7b0JBQ3BDSCxZQUFZLENBQUNOO2dCQUNmLE9BQU87b0JBQ0xELEVBQUVTLElBQUksQ0FBQzt3QkFBRW5ILE9BQU9nSCxhQUFhaEgsS0FBSzt3QkFBRThHLFdBQVdFLGFBQWFGLFNBQVMsR0FBRzVCO29CQUFRO29CQUNoRitCLFlBQVksQ0FBQ1Y7b0JBQ2JBLFNBQVM7Z0JBQ1g7Z0JBQ0EsSUFBSVUsV0FBVztvQkFDYixJQUFJUixjQUFjLE1BQU07d0JBQ3RCN0IsRUFBRXlDLE9BQU8sQ0FBQ1o7b0JBQ1osT0FBTzt3QkFDTGxCLElBQUksSUFBSTVDO3dCQUNSNkQsV0FBV2MsYUFBYSxDQUFDL0I7d0JBQ3pCQSxFQUFFK0IsYUFBYSxDQUFDbkMsVUFBVU0sdUJBQXVCLENBQUMsTUFBTVAsU0FBUyxTQUFVcUMsQ0FBQyxFQUFFN0csS0FBSTs0QkFDaEYsSUFBSWlELEdBQUc2RCxnQkFBZ0JDLFFBQVFDOzRCQUMvQixJQUFJakIsY0FBYyxNQUFNO2dDQUN0Qjs0QkFDRjs0QkFDQUUsVUFBVTs0QkFDVixHQUFHO2dDQUNEYyxTQUFTO2dDQUNULElBQUlmLEVBQUVpQixNQUFNLEdBQUcsS0FBS2pCLENBQUMsQ0FBQyxFQUFFLENBQUNJLFNBQVMsR0FBRzNCLFVBQVVRLEdBQUcsTUFBTSxHQUFHO29DQUN6RDhCLFNBQVNmLEVBQUVrQixLQUFLLEdBQUc1SCxLQUFLO2dDQUMxQjtnQ0FDQSxJQUFJeUgsV0FBVyxNQUFNO29DQUNuQkEsT0FBT0ksTUFBTSxDQUFDakQ7Z0NBQ2hCOzRCQUNGLFFBQVM2QyxXQUFXLE1BQU07NEJBQzFCQyxnQkFBZ0I7NEJBQ2hCRixpQkFBaUI7NEJBQ2pCLElBQUlkLEVBQUVpQixNQUFNLEdBQUcsR0FBRztnQ0FDaEJELGdCQUFnQjtnQ0FDaEJGLGlCQUFpQk0sS0FBS0MsR0FBRyxDQUFDLEdBQUdyQixDQUFDLENBQUMsRUFBRSxDQUFDSSxTQUFTLEdBQUczQixVQUFVUSxHQUFHOzRCQUM3RCxPQUFPO2dDQUNMWSxTQUFTOzRCQUNYOzRCQUNBNUMsSUFBSThDOzRCQUNKRSxVQUFVOzRCQUNWLElBQUloRCxNQUFNLE1BQU07Z0NBQ2RpQixFQUFFeUMsT0FBTyxDQUFDMUQ7NEJBQ1osT0FBTyxJQUFJK0QsZUFBZTtnQ0FDeEJoSCxNQUFLLE1BQU04Rzs0QkFDYjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsT0FBTyxJQUFJMUUsaUJBQWlCOEQsY0FBY0o7UUFDNUMsR0FBR0Y7SUFDTDtJQUVBLFNBQVMwQix3QkFBd0IxQixNQUFNLEVBQUVwQixPQUFPLEVBQUVDLFNBQVM7UUFDekQsT0FBT25ELGdCQUFnQjtZQUNyQixPQUFPcUUsd0JBQXdCQyxRQUFRcEIsVUFBVUMsVUFBVVEsR0FBRyxJQUFJUjtRQUNwRTtJQUNGO0lBRUEsU0FBUzhDLGtCQUFrQjNCLE1BQU0sRUFBRTRCLGlCQUFpQixFQUFFQyxxQkFBcUI7UUFDekUsSUFBSUMsVUFBVUM7UUFDZCxJQUFJL0UsV0FBVzRFLG9CQUFvQjtZQUNqQ0csV0FBV0g7UUFDYixPQUFPO1lBQ0xFLFdBQVdGO1lBQ1hHLFdBQVdGO1FBQ2I7UUFDQSxPQUFPLElBQUlyRyxvQkFBb0IsU0FBVThDLENBQUM7WUFDeEMsSUFBSTBELFNBQVMsSUFBSXpGLHVCQUF1QjBGLFFBQVEsT0FBTzNCLGVBQWUsSUFBSWhFO1lBRTFFLFNBQVM0RjtnQkFDUDVCLGFBQWFVLGFBQWEsQ0FBQ2hCLE9BQU9TLFNBQVMsQ0FDekMsU0FBVTBCLENBQUM7b0JBQ1QsSUFBSUMsUUFBUXpFLFNBQVNvRSxVQUFVSTtvQkFDL0IsSUFBSUMsVUFBVWhGLFVBQVU7d0JBQUUsT0FBT2tCLEVBQUV5QyxPQUFPLENBQUNxQixNQUFNL0UsQ0FBQztvQkFBRztvQkFDckQsSUFBSTRCLElBQUksSUFBSTVDO29CQUNaMkYsT0FBT0ssR0FBRyxDQUFDcEQ7b0JBQ1hBLEVBQUUrQixhQUFhLENBQUNvQixNQUFNM0IsU0FBUyxDQUM3Qjt3QkFDRW5DLEVBQUVHLE1BQU0sQ0FBQzBEO3dCQUNUSCxPQUFPTSxNQUFNLENBQUNyRDt3QkFDZHNEO29CQUNGLEdBQ0EsU0FBVWxGLENBQUM7d0JBQUlpQixFQUFFeUMsT0FBTyxDQUFDMUQ7b0JBQUksR0FDN0I7d0JBQ0VpQixFQUFFRyxNQUFNLENBQUMwRDt3QkFDVEgsT0FBT00sTUFBTSxDQUFDckQ7d0JBQ2RzRDtvQkFDRjtnQkFFSixHQUNBLFNBQVVsRixDQUFDO29CQUFJaUIsRUFBRXlDLE9BQU8sQ0FBQzFEO2dCQUFJLEdBQzdCO29CQUNFNEUsUUFBUTtvQkFDUjNCLGFBQWFrQyxPQUFPO29CQUNwQkQ7Z0JBQ0Y7WUFFSjtZQUVBLFNBQVNBO2dCQUNQTixTQUFTRCxPQUFPWCxNQUFNLEtBQUssS0FBSy9DLEVBQUVJLFdBQVc7WUFDL0M7WUFFQSxJQUFJLENBQUNvRCxVQUFVO2dCQUNiSTtZQUNGLE9BQU87Z0JBQ0w1QixhQUFhVSxhQUFhLENBQUNjLFNBQVNyQixTQUFTLENBQUN5QixPQUFPLFNBQVU3RSxDQUFDO29CQUFJaUIsRUFBRXlDLE9BQU8sQ0FBQzFEO2dCQUFJLEdBQUc2RTtZQUN2RjtZQUVBLE9BQU8sSUFBSTFGLGlCQUFpQjhELGNBQWMwQjtRQUM1QyxHQUFHaEM7SUFDTDtJQUVBOzs7Ozs7O0dBT0MsR0FDRDFFLGdCQUFnQjhHLEtBQUssR0FBRztRQUN0QixJQUFJSyxXQUFXL0UsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxPQUFPK0UsYUFBYSxZQUFZQSxvQkFBb0JuRCxNQUFNO1lBQzVELElBQUlWLFVBQVU2RCxVQUFVNUQsWUFBWW5CLFNBQVMsQ0FBQyxFQUFFO1lBQ2hEVCxZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1lBQ3RELE9BQU95QyxtQkFBbUJVLE9BQ3hCb0Msd0JBQXdCLElBQUksRUFBRTlDLFNBQVNDLGFBQ3ZDa0Isd0JBQXdCLElBQUksRUFBRW5CLFNBQVNDO1FBQzNDLE9BQU8sSUFBSXhELFdBQVdxSCxZQUFZLENBQUNELGFBQWF6RixXQUFXeUYsV0FBVztZQUNwRSxPQUFPZCxrQkFBa0IsSUFBSSxFQUFFYyxVQUFVL0UsU0FBUyxDQUFDLEVBQUU7UUFDdkQsT0FBTztZQUNMLE1BQU0sSUFBSWlGLE1BQU07UUFDbEI7SUFDRjtJQUVBLElBQUlDLHFCQUFzQixTQUFVNUUsU0FBUztRQUMzQzlDLFNBQVMwSCxvQkFBb0I1RTtRQUM3QixTQUFTNEUsbUJBQW1CNUMsTUFBTSxFQUFFL0IsRUFBRSxFQUFFQyxDQUFDO1lBQ3ZDakIsWUFBWWlCLE1BQU9BLENBQUFBLElBQUkvQixnQkFBZTtZQUN0QyxJQUFJLENBQUM2RCxNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDN0IsR0FBRyxHQUFHRjtZQUNYLElBQUksQ0FBQ0csRUFBRSxHQUFHRjtZQUNWRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQTZILG1CQUFtQnJILFNBQVMsQ0FBQzhDLGFBQWEsR0FBRyxTQUFVQyxDQUFDO1lBQ3RELElBQUk0QixhQUFhLElBQUk1RDtZQUNyQixPQUFPLElBQUlFLGlCQUNULElBQUksQ0FBQ3dELE1BQU0sQ0FBQ1MsU0FBUyxDQUFDLElBQUlvQyxpQkFBaUJ2RSxHQUFHLElBQUksQ0FBQ0gsR0FBRyxFQUFFLElBQUksQ0FBQ0MsRUFBRSxFQUFFOEIsY0FDakVBO1FBQ0o7UUFFQSxPQUFPMEM7SUFDVCxFQUFFbkg7SUFFRixJQUFJb0gsbUJBQW9CLFNBQVU3RSxTQUFTO1FBQ3pDOUMsU0FBUzJILGtCQUFrQjdFO1FBQzNCLFNBQVM2RSxpQkFBaUI3RCxRQUFRLEVBQUVKLE9BQU8sRUFBRUMsU0FBUyxFQUFFcUIsVUFBVTtZQUNoRSxJQUFJLENBQUM0QyxFQUFFLEdBQUc5RDtZQUNWLElBQUksQ0FBQytELEVBQUUsR0FBR25FO1lBQ1YsSUFBSSxDQUFDb0UsVUFBVSxHQUFHbkU7WUFDbEIsSUFBSSxDQUFDb0UsRUFBRSxHQUFHL0M7WUFDVixJQUFJLENBQUNnRCxFQUFFLEdBQUc7WUFDVixJQUFJLENBQUNDLEdBQUcsR0FBRztZQUNYLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1lBQ1hwRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQSxTQUFTd0QsZUFBZUwsQ0FBQyxFQUFFbUYsS0FBSztZQUM5QkEsTUFBTWpKLElBQUksQ0FBQytJLEdBQUcsSUFBSUUsTUFBTWpKLElBQUksQ0FBQ2dKLEdBQUcsS0FBS0MsTUFBTUMsU0FBUyxJQUFJRCxNQUFNakosSUFBSSxDQUFDMEksRUFBRSxDQUFDckUsTUFBTSxDQUFDNEUsTUFBTWxCLENBQUM7WUFDcEZrQixNQUFNakosSUFBSSxDQUFDK0ksR0FBRyxHQUFHO1FBQ25CO1FBRUFOLGlCQUFpQnRILFNBQVMsQ0FBQ2dJLElBQUksR0FBRyxTQUFVcEIsQ0FBQztZQUMzQyxJQUFJLENBQUNnQixHQUFHLEdBQUc7WUFDWCxJQUFJLENBQUNELEVBQUUsR0FBR2Y7WUFDVixJQUFJbUIsWUFBWSxFQUFFLElBQUksQ0FBQ0YsR0FBRyxFQUFFbkUsSUFBSSxJQUFJNUM7WUFDcEMsSUFBSSxDQUFDNEcsRUFBRSxDQUFDakMsYUFBYSxDQUFDL0I7WUFDdEJBLEVBQUUrQixhQUFhLENBQUMsSUFBSSxDQUFDZ0MsVUFBVSxDQUFDekUsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUN3RSxFQUFFLEVBQUUsU0FBVTlCLENBQUMsRUFBRTdHLEtBQUk7Z0JBQzdFQSxNQUFLK0ksR0FBRyxJQUFJL0ksTUFBS2dKLEdBQUcsS0FBS0UsYUFBYWxKLE1BQUswSSxFQUFFLENBQUNyRSxNQUFNLENBQUMwRDtnQkFDckQvSCxNQUFLK0ksR0FBRyxHQUFHO1lBQ2I7UUFDRjtRQUVBTixpQkFBaUJ0SCxTQUFTLENBQUN1RixLQUFLLEdBQUcsU0FBVXpELENBQUM7WUFDNUMsSUFBSSxDQUFDNEYsRUFBRSxDQUFDVCxPQUFPO1lBQ2YsSUFBSSxDQUFDTSxFQUFFLENBQUMvQixPQUFPLENBQUMxRDtZQUNoQixJQUFJLENBQUM4RixHQUFHLEdBQUc7WUFDWCxJQUFJLENBQUNDLEdBQUc7UUFDVjtRQUVBUCxpQkFBaUJ0SCxTQUFTLENBQUNpSSxTQUFTLEdBQUc7WUFDckMsSUFBSSxDQUFDUCxFQUFFLENBQUNULE9BQU87WUFDZixJQUFJLENBQUNXLEdBQUcsSUFBSSxJQUFJLENBQUNMLEVBQUUsQ0FBQ3JFLE1BQU0sQ0FBQyxJQUFJLENBQUN5RSxFQUFFO1lBQ2xDLElBQUksQ0FBQ0osRUFBRSxDQUFDcEUsV0FBVztZQUNuQixJQUFJLENBQUN5RSxHQUFHLEdBQUc7WUFDWCxJQUFJLENBQUNDLEdBQUc7UUFDVjtRQUVBLE9BQU9QO0lBQ1QsRUFBRXpIO0lBRUYsU0FBU3FJLHFCQUFxQnpELE1BQU0sRUFBRTBELGdCQUFnQjtRQUNwRCxPQUFPLElBQUlsSSxvQkFBb0IsU0FBVThDLENBQUM7WUFDeEMsSUFBSTVFLE9BQU9pSyxXQUFXLE9BQU96RCxhQUFhLElBQUk1RCxvQkFBb0JzSCxLQUFLO1lBQ3ZFLElBQUl0RCxlQUFlTixPQUFPUyxTQUFTLENBQ2pDLFNBQVUwQixDQUFDO2dCQUNULElBQUkwQixXQUFXbEcsU0FBUytGLGtCQUFrQnZCO2dCQUMxQyxJQUFJMEIsYUFBYXpHLFVBQVU7b0JBQUUsT0FBT2tCLEVBQUV5QyxPQUFPLENBQUM4QyxTQUFTeEcsQ0FBQztnQkFBRztnQkFFM0ROLFVBQVU4RyxhQUFjQSxDQUFBQSxXQUFXM0csc0JBQXNCMkcsU0FBUTtnQkFFakVGLFdBQVc7Z0JBQ1hqSyxRQUFReUk7Z0JBQ1J5QjtnQkFDQSxJQUFJRSxZQUFZRixJQUFJM0UsSUFBSSxJQUFJNUM7Z0JBQzVCNkQsV0FBV2MsYUFBYSxDQUFDL0I7Z0JBQ3pCQSxFQUFFK0IsYUFBYSxDQUFDNkMsU0FBU3BELFNBQVMsQ0FDaEM7b0JBQ0VrRCxZQUFZQyxPQUFPRSxhQUFheEYsRUFBRUcsTUFBTSxDQUFDL0U7b0JBQ3pDaUssV0FBVztvQkFDWDFFLEVBQUV1RCxPQUFPO2dCQUNYLEdBQ0EsU0FBVW5GLENBQUM7b0JBQUlpQixFQUFFeUMsT0FBTyxDQUFDMUQ7Z0JBQUksR0FDN0I7b0JBQ0VzRyxZQUFZQyxPQUFPRSxhQUFheEYsRUFBRUcsTUFBTSxDQUFDL0U7b0JBQ3pDaUssV0FBVztvQkFDWDFFLEVBQUV1RCxPQUFPO2dCQUNYO1lBRUosR0FDQSxTQUFVbkYsQ0FBQztnQkFDVDZDLFdBQVdzQyxPQUFPO2dCQUNsQmxFLEVBQUV5QyxPQUFPLENBQUMxRDtnQkFDVnNHLFdBQVc7Z0JBQ1hDO1lBQ0YsR0FDQTtnQkFDRTFELFdBQVdzQyxPQUFPO2dCQUNsQm1CLFlBQVlyRixFQUFFRyxNQUFNLENBQUMvRTtnQkFDckI0RSxFQUFFSSxXQUFXO2dCQUNiaUYsV0FBVztnQkFDWEM7WUFDRjtZQUVGLE9BQU8sSUFBSXBILGlCQUFpQjhELGNBQWNKO1FBQzVDLEdBQUdGO0lBQ0w7SUFFQTFFLGdCQUFnQnlJLFFBQVEsR0FBRztRQUN6QixJQUFJL0csV0FBWVUsU0FBUyxDQUFDLEVBQUUsR0FBRztZQUM3QixPQUFPK0YscUJBQXFCLElBQUksRUFBRS9GLFNBQVMsQ0FBQyxFQUFFO1FBQ2hELE9BQU8sSUFBSSxPQUFPQSxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7WUFDM0MsT0FBTyxJQUFJa0YsbUJBQW1CLElBQUksRUFBRWxGLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFO1FBQ2hFLE9BQU87WUFDTCxNQUFNLElBQUlpRixNQUFNO1FBQ2xCO0lBQ0Y7SUFFQTs7Ozs7O0dBTUMsR0FDRHJILGdCQUFnQjBJLGNBQWMsR0FBRzFJLGdCQUFnQjJJLFVBQVUsR0FBRyxTQUFVQyxRQUFRLEVBQUVDLG9CQUFvQixFQUFFdEYsU0FBUztRQUMvRyxJQUFJbUIsU0FBUyxJQUFJLEVBQUVvRTtRQUNuQkQsd0JBQXdCLFFBQVNDLENBQUFBLFlBQVlGLFFBQU87UUFDcERqSCxZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELElBQUksT0FBT2dJLHlCQUF5QixVQUFVO1lBQzVDQyxZQUFZRDtRQUNkLE9BQU8sSUFBSWxILFlBQVlrSCx1QkFBdUI7WUFDNUNDLFlBQVlGO1lBQ1pyRixZQUFZc0Y7UUFDZDtRQUNBLE9BQU8sSUFBSTNJLG9CQUFvQixTQUFVd0QsUUFBUTtZQUMvQyxJQUFJcUYsaUJBQ0ZDLFlBQVlGLFdBQ1pHLFdBQVdMLFVBQ1g5RCxJQUFJLEVBQUUsRUFDTm9FLG9CQUNBQyxTQUFTLElBQUluSSxvQkFDYm9JLFlBQVk7WUFDWkwsa0JBQWtCLElBQUk5SCxvQkFBb0JrSSxTQUMxQ0QscUJBQXFCLElBQUkvSCxtQkFBbUI0SDtZQUU3QyxTQUFTTTtnQkFDUixJQUFJQyxJQUFJLElBQUl2SSw4QkFDVndJLFNBQVMsT0FDVEMsVUFBVTtnQkFDWkwsT0FBT3pELGFBQWEsQ0FBQzREO2dCQUNyQixJQUFJTCxhQUFhRCxXQUFXO29CQUMxQk8sU0FBUztvQkFDVEMsVUFBVTtnQkFDWixPQUFPLElBQUlQLFdBQVdELFdBQVc7b0JBQzdCTyxTQUFTO2dCQUNiLE9BQU87b0JBQ0xDLFVBQVU7Z0JBQ1o7Z0JBQ0EsSUFBSUMsZUFBZUYsU0FBU04sV0FBV0QsV0FDckNVLEtBQUtELGVBQWVMO2dCQUN0QkEsWUFBWUs7Z0JBQ1osSUFBSUYsUUFBUTtvQkFDVk4sWUFBWUg7Z0JBQ2Q7Z0JBQ0EsSUFBSVUsU0FBUztvQkFDWFIsYUFBYUY7Z0JBQ2Y7Z0JBQ0FRLEVBQUU1RCxhQUFhLENBQUNuQyxVQUFVTixjQUFjLENBQUMsTUFBTXlHLElBQUk7b0JBQ2pELElBQUlGLFNBQVM7d0JBQ1gsSUFBSTVHLElBQUksSUFBSXhCO3dCQUNaMEQsRUFBRVMsSUFBSSxDQUFDM0M7d0JBQ1BjLFNBQVNQLE1BQU0sQ0FBQzlCLE9BQU91QixHQUFHc0c7b0JBQzVCO29CQUNBSyxVQUFVekUsRUFBRWtCLEtBQUssR0FBRzVDLFdBQVc7b0JBQy9CaUc7Z0JBQ0Y7WUFDRjs7WUFDQXZFLEVBQUVTLElBQUksQ0FBQyxJQUFJbkU7WUFDWHNDLFNBQVNQLE1BQU0sQ0FBQzlCLE9BQU95RCxDQUFDLENBQUMsRUFBRSxFQUFFb0U7WUFDN0JHO1lBQ0FOLGdCQUFnQmhDLEdBQUcsQ0FBQ3JDLE9BQU9TLFNBQVMsQ0FDbEMsU0FBVTBCLENBQUM7Z0JBQ1QsSUFBSyxJQUFJOEMsSUFBSSxHQUFHQyxNQUFNOUUsRUFBRWlCLE1BQU0sRUFBRTRELElBQUlDLEtBQUtELElBQUs7b0JBQUU3RSxDQUFDLENBQUM2RSxFQUFFLENBQUN4RyxNQUFNLENBQUMwRDtnQkFBSTtZQUNsRSxHQUNBLFNBQVU5RSxDQUFDO2dCQUNULElBQUssSUFBSTRILElBQUksR0FBR0MsTUFBTTlFLEVBQUVpQixNQUFNLEVBQUU0RCxJQUFJQyxLQUFLRCxJQUFLO29CQUFFN0UsQ0FBQyxDQUFDNkUsRUFBRSxDQUFDbEUsT0FBTyxDQUFDMUQ7Z0JBQUk7Z0JBQ2pFMkIsU0FBUytCLE9BQU8sQ0FBQzFEO1lBQ25CLEdBQ0E7Z0JBQ0UsSUFBSyxJQUFJNEgsSUFBSSxHQUFHQyxNQUFNOUUsRUFBRWlCLE1BQU0sRUFBRTRELElBQUlDLEtBQUtELElBQUs7b0JBQUU3RSxDQUFDLENBQUM2RSxFQUFFLENBQUN2RyxXQUFXO2dCQUFJO2dCQUNwRU0sU0FBU04sV0FBVztZQUN0QjtZQUVGLE9BQU84RjtRQUNULEdBQUd4RTtJQUNMO0lBRUE7Ozs7OztHQU1DLEdBQ0QxRSxnQkFBZ0I2SixxQkFBcUIsR0FBRzdKLGdCQUFnQjhKLGlCQUFpQixHQUFHLFNBQVVsQixRQUFRLEVBQUU5RSxLQUFLLEVBQUVQLFNBQVM7UUFDOUcsSUFBSW1CLFNBQVMsSUFBSTtRQUNqQi9DLFlBQVk0QixjQUFlQSxDQUFBQSxZQUFZMUMsZ0JBQWU7UUFDdEQsT0FBTyxJQUFJWCxvQkFBb0IsU0FBVXdELFFBQVE7WUFDL0MsSUFBSXlGLFNBQVMsSUFBSW5JLG9CQUNiK0gsa0JBQWtCLElBQUk5SCxvQkFBb0JrSSxTQUMxQ0QscUJBQXFCLElBQUkvSCxtQkFBbUI0SCxrQkFDNUNnQixJQUFJLEdBQ0pDLFdBQVcsR0FDWHBILElBQUksSUFBSXhCO1lBRVosU0FBU2lJLFlBQVlmLEVBQUU7Z0JBQ3JCLElBQUlnQixJQUFJLElBQUl2STtnQkFDWm9JLE9BQU96RCxhQUFhLENBQUM0RDtnQkFDckJBLEVBQUU1RCxhQUFhLENBQUNuQyxVQUFVTixjQUFjLENBQUMsTUFBTTJGLFVBQVU7b0JBQ3ZELElBQUlOLE9BQU8wQixVQUFVO3dCQUFFO29CQUFRO29CQUMvQkQsSUFBSTtvQkFDSixJQUFJRSxRQUFRLEVBQUVEO29CQUNkcEgsRUFBRVEsV0FBVztvQkFDYlIsSUFBSSxJQUFJeEI7b0JBQ1JzQyxTQUFTUCxNQUFNLENBQUM5QixPQUFPdUIsR0FBR3NHO29CQUMxQkcsWUFBWVk7Z0JBQ2Q7WUFDRjtZQUVBdkcsU0FBU1AsTUFBTSxDQUFDOUIsT0FBT3VCLEdBQUdzRztZQUMxQkcsWUFBWTtZQUVaTixnQkFBZ0JoQyxHQUFHLENBQUNyQyxPQUFPUyxTQUFTLENBQ2xDLFNBQVUwQixDQUFDO2dCQUNULElBQUlvRCxRQUFRLEdBQUdDLFlBQVk7Z0JBQzNCdEgsRUFBRU8sTUFBTSxDQUFDMEQ7Z0JBQ1QsSUFBSSxFQUFFa0QsTUFBTWpHLE9BQU87b0JBQ2pCb0csWUFBWTtvQkFDWkgsSUFBSTtvQkFDSkUsUUFBUSxFQUFFRDtvQkFDVnBILEVBQUVRLFdBQVc7b0JBQ2JSLElBQUksSUFBSXhCO29CQUNSc0MsU0FBU1AsTUFBTSxDQUFDOUIsT0FBT3VCLEdBQUdzRztnQkFDNUI7Z0JBQ0FnQixhQUFhYixZQUFZWTtZQUMzQixHQUNBLFNBQVVsSSxDQUFDO2dCQUNUYSxFQUFFNkMsT0FBTyxDQUFDMUQ7Z0JBQ1YyQixTQUFTK0IsT0FBTyxDQUFDMUQ7WUFDbkIsR0FBRztnQkFDRGEsRUFBRVEsV0FBVztnQkFDYk0sU0FBU04sV0FBVztZQUN0QjtZQUVGLE9BQU84RjtRQUNULEdBQUd4RTtJQUNMO0lBRUEsU0FBU3lGLFFBQVF0RCxDQUFDO1FBQUksT0FBT0EsRUFBRXNELE9BQU87SUFBSTtJQUUxQzs7Ozs7O0dBTUMsR0FDRG5LLGdCQUFnQm9LLGNBQWMsR0FBR3BLLGdCQUFnQnFLLFVBQVUsR0FBRyxTQUFVekIsUUFBUSxFQUFFQyxvQkFBb0IsRUFBRXRGLFNBQVM7UUFDL0csT0FBTyxJQUFJLENBQUNtRixjQUFjLENBQUNFLFVBQVVDLHNCQUFzQnRGLFdBQVcrRyxPQUFPLENBQUNIO0lBQ2hGO0lBRUEsU0FBU0EsUUFBUXRELENBQUM7UUFBSSxPQUFPQSxFQUFFc0QsT0FBTztJQUFJO0lBRTFDOzs7Ozs7R0FNQyxHQUNEbkssZ0JBQWdCdUsscUJBQXFCLEdBQUd2SyxnQkFBZ0J3SyxpQkFBaUIsR0FBRyxTQUFVNUIsUUFBUSxFQUFFOUUsS0FBSyxFQUFFUCxTQUFTO1FBQzlHLE9BQU8sSUFBSSxDQUFDc0cscUJBQXFCLENBQUNqQixVQUFVOUUsT0FBT1AsV0FBVytHLE9BQU8sQ0FBQ0g7SUFDeEU7SUFFQSxJQUFJTSx5QkFBMEIsU0FBVS9ILFNBQVM7UUFDL0M5QyxTQUFTNkssd0JBQXdCL0g7UUFDakMsU0FBUytILHVCQUF1Qi9GLE1BQU0sRUFBRTlCLENBQUM7WUFDdkMsSUFBSSxDQUFDOEIsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQzVCLEVBQUUsR0FBR0Y7WUFDVkYsVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUFnTCx1QkFBdUJ4SyxTQUFTLENBQUM4QyxhQUFhLEdBQUcsU0FBVUMsQ0FBQztZQUMxRCxPQUFPLElBQUksQ0FBQzBCLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDLElBQUl1RixxQkFBcUIxSCxHQUFHLElBQUksQ0FBQ0YsRUFBRTtRQUNsRTtRQUVBLE9BQU8ySDtJQUNULEVBQUV0SztJQUVGLElBQUl1Syx1QkFBd0IsU0FBVWhJLFNBQVM7UUFDN0M5QyxTQUFTOEssc0JBQXNCaEk7UUFFL0IsU0FBU2dJLHFCQUFxQjFILENBQUMsRUFBRUosQ0FBQztZQUNoQyxJQUFJLENBQUM0RSxFQUFFLEdBQUd4RTtZQUNWLElBQUksQ0FBQ0YsRUFBRSxHQUFHRjtZQUNWLElBQUksQ0FBQytILEVBQUUsR0FBRy9ILEVBQUVtQixHQUFHO1lBQ2ZyQixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQWlMLHFCQUFxQnpLLFNBQVMsQ0FBQ2dJLElBQUksR0FBRyxTQUFVcEIsQ0FBQztZQUMvQyxJQUFJOUMsTUFBTSxJQUFJLENBQUNqQixFQUFFLENBQUNpQixHQUFHLElBQUk2RyxPQUFPN0csTUFBTSxJQUFJLENBQUM0RyxFQUFFO1lBQzdDLElBQUksQ0FBQ0EsRUFBRSxHQUFHNUc7WUFDVixJQUFJLENBQUN5RCxFQUFFLENBQUNyRSxNQUFNLENBQUM7Z0JBQUUvRSxPQUFPeUk7Z0JBQUd4QyxVQUFVdUc7WUFBSztRQUM1QztRQUNBRixxQkFBcUJ6SyxTQUFTLENBQUN1RixLQUFLLEdBQUcsU0FBVXpELENBQUM7WUFBSSxJQUFJLENBQUN5RixFQUFFLENBQUMvQixPQUFPLENBQUMxRDtRQUFJO1FBQzFFMkkscUJBQXFCekssU0FBUyxDQUFDaUksU0FBUyxHQUFHO1lBQWMsSUFBSSxDQUFDVixFQUFFLENBQUNwRSxXQUFXO1FBQUk7UUFFaEYsT0FBT3NIO0lBQ1QsRUFBRTVLO0lBRUY7Ozs7Ozs7OztHQVNDLEdBQ0RFLGdCQUFnQjZLLFlBQVksR0FBRyxTQUFVdEgsU0FBUztRQUNoRDVCLFlBQVk0QixjQUFlQSxDQUFBQSxZQUFZMUMsZ0JBQWU7UUFDdEQsT0FBTyxJQUFJNEosdUJBQXVCLElBQUksRUFBRWxIO0lBQzFDO0lBRUEsSUFBSXVILHNCQUF1QixTQUFVcEksU0FBUztRQUM1QzlDLFNBQVNrTCxxQkFBcUJwSTtRQUM5QixTQUFTb0ksb0JBQW9CcEcsTUFBTSxFQUFFOUIsQ0FBQztZQUNwQyxJQUFJLENBQUM4QixNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDNUIsRUFBRSxHQUFHRjtZQUNWRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQXFMLG9CQUFvQjdLLFNBQVMsQ0FBQzhDLGFBQWEsR0FBRyxTQUFVQyxDQUFDO1lBQ3ZELE9BQU8sSUFBSSxDQUFDMEIsTUFBTSxDQUFDUyxTQUFTLENBQUMsSUFBSTRGLGtCQUFrQi9ILEdBQUcsSUFBSSxDQUFDRixFQUFFO1FBQy9EO1FBRUEsT0FBT2dJO0lBQ1QsRUFBRTNLO0lBRUYsSUFBSTRLLG9CQUFxQixTQUFVckksU0FBUztRQUMxQzlDLFNBQVNtTCxtQkFBbUJySTtRQUM1QixTQUFTcUksa0JBQWtCL0gsQ0FBQyxFQUFFSixDQUFDO1lBQzdCLElBQUksQ0FBQzRFLEVBQUUsR0FBR3hFO1lBQ1YsSUFBSSxDQUFDRixFQUFFLEdBQUdGO1lBQ1ZGLFVBQVVqRCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBc0wsa0JBQWtCOUssU0FBUyxDQUFDZ0ksSUFBSSxHQUFHLFNBQVVwQixDQUFDO1lBQzVDLElBQUksQ0FBQ1csRUFBRSxDQUFDckUsTUFBTSxDQUFDO2dCQUFFL0UsT0FBT3lJO2dCQUFHM0IsV0FBVyxJQUFJLENBQUNwQyxFQUFFLENBQUNpQixHQUFHO1lBQUc7UUFDdEQ7UUFFQWdILGtCQUFrQjlLLFNBQVMsQ0FBQ3VGLEtBQUssR0FBRyxTQUFVekQsQ0FBQztZQUM3QyxJQUFJLENBQUN5RixFQUFFLENBQUMvQixPQUFPLENBQUMxRDtRQUNsQjtRQUVBZ0osa0JBQWtCOUssU0FBUyxDQUFDaUksU0FBUyxHQUFHO1lBQ3RDLElBQUksQ0FBQ1YsRUFBRSxDQUFDcEUsV0FBVztRQUNyQjtRQUVBLE9BQU8ySDtJQUNULEVBQUVqTDtJQUVGOzs7Ozs7Ozs7R0FTQyxHQUNERSxnQkFBZ0JrRixTQUFTLEdBQUcsU0FBVTNCLFNBQVM7UUFDN0M1QixZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELE9BQU8sSUFBSWlLLG9CQUFvQixJQUFJLEVBQUV2SDtJQUN2QztJQUVBLElBQUl5SCxtQkFBb0IsU0FBU3RJLFNBQVM7UUFDeEM5QyxTQUFTb0wsa0JBQWtCdEk7UUFDM0IsU0FBU3NJLGlCQUFpQnRHLE1BQU0sRUFBRXVHLE9BQU87WUFDdkMsSUFBSSxDQUFDdkcsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQ3dHLFFBQVEsR0FBR0Q7WUFDaEJ2SSxVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQXVMLGlCQUFpQi9LLFNBQVMsQ0FBQzhDLGFBQWEsR0FBRyxTQUFVQyxDQUFDO1lBQ3BELElBQUkrRSxRQUFRO2dCQUNWL0UsR0FBR0E7Z0JBQ0gyRCxPQUFPO2dCQUNQdkksT0FBTztnQkFDUGlLLFVBQVU7Z0JBQ1Y4QyxvQkFBb0IsSUFBSXBLO1lBQzFCO1lBRUFnSCxNQUFNb0Qsa0JBQWtCLENBQUN6RixhQUFhLENBQUMsSUFBSSxDQUFDaEIsTUFBTSxDQUFDUyxTQUFTLENBQUMsSUFBSWlHLHFCQUFxQnJEO1lBQ3RGLE9BQU8sSUFBSTdHLGlCQUNUNkcsTUFBTW9ELGtCQUFrQixFQUN4QixJQUFJLENBQUNELFFBQVEsQ0FBQy9GLFNBQVMsQ0FBQyxJQUFJa0csZ0JBQWdCdEQ7UUFFaEQ7UUFFQSxPQUFPaUQ7SUFDVCxFQUFFN0s7SUFFRixJQUFJa0wsa0JBQW1CLFNBQVMzSSxTQUFTO1FBQ3ZDOUMsU0FBU3lMLGlCQUFpQjNJO1FBQzFCLFNBQVMySSxnQkFBZ0J6SSxDQUFDO1lBQ3hCLElBQUksQ0FBQ0UsRUFBRSxHQUFHRjtZQUNWRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQTRMLGdCQUFnQnBMLFNBQVMsQ0FBQ3FMLGNBQWMsR0FBRztZQUN6QyxJQUFJLElBQUksQ0FBQ3hJLEVBQUUsQ0FBQ3VGLFFBQVEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDdkYsRUFBRSxDQUFDdUYsUUFBUSxHQUFHO2dCQUNuQixJQUFJLENBQUN2RixFQUFFLENBQUNFLENBQUMsQ0FBQ0csTUFBTSxDQUFDLElBQUksQ0FBQ0wsRUFBRSxDQUFDMUUsS0FBSztZQUNoQztZQUNBLElBQUksQ0FBQzBFLEVBQUUsQ0FBQzZELEtBQUssSUFBSSxJQUFJLENBQUM3RCxFQUFFLENBQUNFLENBQUMsQ0FBQ0ksV0FBVztRQUN4QztRQUVBaUksZ0JBQWdCcEwsU0FBUyxDQUFDZ0ksSUFBSSxHQUFHO1lBQWMsSUFBSSxDQUFDcUQsY0FBYztRQUFJO1FBQ3RFRCxnQkFBZ0JwTCxTQUFTLENBQUN1RixLQUFLLEdBQUcsU0FBVXpELENBQUM7WUFBSSxJQUFJLENBQUNlLEVBQUUsQ0FBQzJDLE9BQU8sQ0FBQzFEO1FBQUk7UUFDckVzSixnQkFBZ0JwTCxTQUFTLENBQUNpSSxTQUFTLEdBQUc7WUFBYyxJQUFJLENBQUNvRCxjQUFjO1FBQUk7UUFFM0UsT0FBT0Q7SUFDVCxFQUFFdkw7SUFFRixJQUFJc0wsdUJBQXdCLFNBQVMxSSxTQUFTO1FBQzVDOUMsU0FBU3dMLHNCQUFzQjFJO1FBQy9CLFNBQVMwSSxxQkFBcUJ4SSxDQUFDO1lBQzdCLElBQUksQ0FBQ0UsRUFBRSxHQUFHRjtZQUNWRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQTJMLHFCQUFxQm5MLFNBQVMsQ0FBQ2dJLElBQUksR0FBRyxTQUFVcEIsQ0FBQztZQUMvQyxJQUFJLENBQUMvRCxFQUFFLENBQUN1RixRQUFRLEdBQUc7WUFDbkIsSUFBSSxDQUFDdkYsRUFBRSxDQUFDMUUsS0FBSyxHQUFHeUk7UUFDbEI7UUFDQXVFLHFCQUFxQm5MLFNBQVMsQ0FBQ3VGLEtBQUssR0FBRyxTQUFVekQsQ0FBQztZQUFJLElBQUksQ0FBQ2UsRUFBRSxDQUFDRSxDQUFDLENBQUN5QyxPQUFPLENBQUMxRDtRQUFJO1FBQzVFcUoscUJBQXFCbkwsU0FBUyxDQUFDaUksU0FBUyxHQUFHO1lBQ3pDLElBQUksQ0FBQ3BGLEVBQUUsQ0FBQzZELEtBQUssR0FBRztZQUNoQixJQUFJLENBQUM3RCxFQUFFLENBQUNxSSxrQkFBa0IsQ0FBQ2pFLE9BQU87UUFDcEM7UUFFQSxPQUFPa0U7SUFDVCxFQUFFdEw7SUFFRjs7Ozs7Ozs7Ozs7R0FXQyxHQUNERSxnQkFBZ0J1TCxNQUFNLEdBQUcsU0FBVUMsaUJBQWlCLEVBQUVqSSxTQUFTO1FBQzdENUIsWUFBWTRCLGNBQWVBLENBQUFBLFlBQVkxQyxnQkFBZTtRQUN0RCxPQUFPLE9BQU8ySyxzQkFBc0IsV0FDbEMsSUFBSVIsaUJBQWlCLElBQUksRUFBRTVHLG1CQUFtQm9ILG1CQUFtQmpJLGNBQ2pFLElBQUl5SCxpQkFBaUIsSUFBSSxFQUFFUTtJQUMvQjtJQUVBLElBQUlDLGVBQWVsTSxHQUFHa00sWUFBWSxHQUFHLFNBQVNDLE9BQU87UUFDbkQsSUFBSSxDQUFDQSxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWnRFLE1BQU01SCxJQUFJLENBQUMsSUFBSTtJQUNqQjtJQUNBZ00sYUFBYXhMLFNBQVMsR0FBRzVCLE9BQU91TixNQUFNLENBQUN2RSxNQUFNcEgsU0FBUztJQUV0RCxTQUFTNEwsb0JBQW9CbkgsTUFBTSxFQUFFb0gsWUFBWSxFQUFFQyx1QkFBdUIsRUFBRUMsS0FBSztRQUMvRSxJQUFJdEssV0FBV29LLGVBQWU7WUFDNUJFLFFBQVFEO1lBQ1JBLDBCQUEwQkQ7WUFDMUJBLGVBQWV0TDtRQUNqQjtRQUNBVCxXQUFXcUgsWUFBWSxDQUFDNEUsVUFBV0EsQ0FBQUEsUUFBUXRMLGdCQUFnQixJQUFJK0ssZUFBYztRQUM3RSxPQUFPLElBQUl2TCxvQkFBb0IsU0FBVThDLENBQUM7WUFDeEMsSUFBSWdDLGVBQWUsSUFBSWhFLG9CQUNyQnVELFFBQVEsSUFBSXZELG9CQUNaaUwsV0FBVyxJQUFJbEw7WUFFakJpRSxhQUFhVSxhQUFhLENBQUN1RztZQUUzQixJQUFJM0QsS0FBSyxHQUFHNEQsV0FBVztZQUV2QixTQUFTQyxTQUFTQyxPQUFPO2dCQUN2QixJQUFJQyxPQUFPL0QsSUFBSTNFLElBQUksSUFBSTVDO2dCQUV2QixTQUFTdUw7b0JBQ1BKLFdBQVlHLFNBQVMvRDtvQkFDckIsT0FBTzREO2dCQUNUO2dCQUVBM0gsTUFBTW1CLGFBQWEsQ0FBQy9CO2dCQUNwQkEsRUFBRStCLGFBQWEsQ0FBQzBHLFFBQVFqSCxTQUFTLENBQUM7b0JBQ2hDbUgsZUFBZXRILGFBQWFVLGFBQWEsQ0FBQ3NHLE1BQU03RyxTQUFTLENBQUNuQztvQkFDMURXLEVBQUV1RCxPQUFPO2dCQUNYLEdBQUcsU0FBVW5GLENBQUM7b0JBQ1p1SyxlQUFldEosRUFBRXlDLE9BQU8sQ0FBQzFEO2dCQUMzQixHQUFHO29CQUNEdUssZUFBZXRILGFBQWFVLGFBQWEsQ0FBQ3NHLE1BQU03RyxTQUFTLENBQUNuQztnQkFDNUQ7WUFDRjs7WUFFQW1KLFNBQVNMO1lBRVQsU0FBU1M7Z0JBQ1AsSUFBSUMsTUFBTSxDQUFDTjtnQkFDWCxJQUFJTSxLQUFLO29CQUFFbEU7Z0JBQU07Z0JBQ2pCLE9BQU9rRTtZQUNUO1lBRUFQLFNBQVN2RyxhQUFhLENBQUNoQixPQUFPUyxTQUFTLENBQUMsU0FBVTBCLENBQUM7Z0JBQ2pELElBQUkwRixTQUFTO29CQUNYdkosRUFBRUcsTUFBTSxDQUFDMEQ7b0JBQ1QsSUFBSXVGLFVBQVUvSixTQUFTMEoseUJBQXlCbEY7b0JBQ2hELElBQUl1RixZQUFZdEssVUFBVTt3QkFBRSxPQUFPa0IsRUFBRXlDLE9BQU8sQ0FBQzJHLFFBQVFySyxDQUFDO29CQUFHO29CQUN6RG9LLFNBQVMxSyxVQUFVMkssV0FBV3hLLHNCQUFzQndLLFdBQVdBO2dCQUNqRTtZQUNGLEdBQUcsU0FBVXJLLENBQUM7Z0JBQ1p3SyxXQUFXdkosRUFBRXlDLE9BQU8sQ0FBQzFEO1lBQ3ZCLEdBQUc7Z0JBQ0R3SyxXQUFXdkosRUFBRUksV0FBVztZQUMxQjtZQUNBLE9BQU8sSUFBSWxDLGlCQUFpQjhELGNBQWNUO1FBQzVDLEdBQUdHO0lBQ0w7SUFFQSxTQUFTMEgsUUFBUTFILE1BQU0sRUFBRXBCLE9BQU8sRUFBRTBJLEtBQUssRUFBRXpJLFNBQVM7UUFDaEQsSUFBSTVCLFlBQVlxSyxRQUFRO1lBQ3RCekksWUFBWXlJO1lBQ1pBLFFBQVF0TCxnQkFBZ0IsSUFBSStLO1FBQzlCO1FBQ0EsSUFBSU8saUJBQWlCM0UsT0FBTztZQUFFMkUsUUFBUXRMLGdCQUFnQnNMO1FBQVE7UUFDOURySyxZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3REZCxXQUFXcUgsWUFBWSxDQUFDNEUsVUFBV0EsQ0FBQUEsUUFBUXRMLGdCQUFnQixJQUFJK0ssZUFBYztRQUM3RSxPQUFPLElBQUl2TCxvQkFBb0IsU0FBVThDLENBQUM7WUFDeEMsSUFBSXNGLEtBQUssR0FDUDJELFdBQVcsSUFBSWxMLDhCQUNmaUUsZUFBZSxJQUFJaEUsb0JBQ25Ca0wsV0FBVyxPQUNYM0gsUUFBUSxJQUFJdkQ7WUFFZGdFLGFBQWFVLGFBQWEsQ0FBQ3VHO1lBRTNCLFNBQVM1QztnQkFDUCxJQUFJZ0QsT0FBTy9EO2dCQUNYL0QsTUFBTW1CLGFBQWEsQ0FBQ25DLFVBQVVOLGNBQWMsQ0FBQyxNQUFNSyxTQUFTO29CQUMxRDRJLFdBQVc1RCxPQUFPK0Q7b0JBQ2xCLElBQUlILFVBQVU7d0JBQ1p6SyxVQUFVdUssVUFBV0EsQ0FBQUEsUUFBUXBLLHNCQUFzQm9LLE1BQUs7d0JBQ3hEaEgsYUFBYVUsYUFBYSxDQUFDc0csTUFBTTdHLFNBQVMsQ0FBQ25DO29CQUM3QztnQkFDRjtZQUNGO1lBRUFxRztZQUVBNEMsU0FBU3ZHLGFBQWEsQ0FBQ2hCLE9BQU9TLFNBQVMsQ0FBQyxTQUFVMEIsQ0FBQztnQkFDakQsSUFBSSxDQUFDcUYsVUFBVTtvQkFDYjVEO29CQUNBdEYsRUFBRUcsTUFBTSxDQUFDMEQ7b0JBQ1R3QztnQkFDRjtZQUNGLEdBQUcsU0FBVXRILENBQUM7Z0JBQ1osSUFBSSxDQUFDbUssVUFBVTtvQkFDYjVEO29CQUNBdEYsRUFBRXlDLE9BQU8sQ0FBQzFEO2dCQUNaO1lBQ0YsR0FBRztnQkFDRCxJQUFJLENBQUNtSyxVQUFVO29CQUNiNUQ7b0JBQ0F0RixFQUFFSSxXQUFXO2dCQUNmO1lBQ0Y7WUFDQSxPQUFPLElBQUlsQyxpQkFBaUI4RCxjQUFjVDtRQUM1QyxHQUFHRztJQUNMO0lBRUExRSxnQkFBZ0JvTSxPQUFPLEdBQUc7UUFDeEIsSUFBSWpGLFdBQVcvRSxTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJK0Usb0JBQW9CbkQsUUFBUSxPQUFPbUQsYUFBYSxVQUFVO1lBQzVELE9BQU9pRixRQUFRLElBQUksRUFBRWpGLFVBQVUvRSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRTtRQUMzRCxPQUFPLElBQUlyQyxXQUFXcUgsWUFBWSxDQUFDRCxhQUFhekYsV0FBV3lGLFdBQVc7WUFDcEUsT0FBTzBFLG9CQUFvQixJQUFJLEVBQUUxRSxVQUFVL0UsU0FBUyxDQUFDLEVBQUUsRUFBRUEsU0FBUyxDQUFDLEVBQUU7UUFDdkUsT0FBTztZQUNMLE1BQU0sSUFBSWlGLE1BQU07UUFDbEI7SUFDRjtJQUVBLElBQUlvRiw2QkFBOEIsU0FBVS9KLFNBQVM7UUFDbkQ5QyxTQUFTNk0sNEJBQTRCL0o7UUFDckMsU0FBUytKLDJCQUEyQjFFLEtBQUssRUFBRTJFLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRWpLLENBQUM7WUFDdkUsSUFBSSxDQUFDa0ssTUFBTSxHQUFHL0U7WUFDZCxJQUFJLENBQUNnRixNQUFNLEdBQUdMO1lBQ2QsSUFBSSxDQUFDTSxNQUFNLEdBQUdMO1lBQ2QsSUFBSSxDQUFDTSxNQUFNLEdBQUdMO1lBQ2QsSUFBSSxDQUFDTSxPQUFPLEdBQUdMO1lBQ2YsSUFBSSxDQUFDL0osRUFBRSxHQUFHRjtZQUNWRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQSxTQUFTME4sa0JBQWtCcEYsS0FBSyxFQUFFcUYsT0FBTztZQUN2Q3JGLE1BQU1zRixTQUFTLElBQUl0RixNQUFNL0UsQ0FBQyxDQUFDRyxNQUFNLENBQUM0RSxNQUFNbEMsTUFBTTtZQUU5QyxJQUFJa0MsTUFBTXVGLEtBQUssRUFBRTtnQkFDZnZGLE1BQU11RixLQUFLLEdBQUc7WUFDaEIsT0FBTztnQkFDTHZGLE1BQU13RixRQUFRLEdBQUdsTCxTQUFTMEYsTUFBTWpKLElBQUksQ0FBQ2tPLE1BQU0sRUFBRWpGLE1BQU13RixRQUFRO2dCQUMzRCxJQUFJeEYsTUFBTXdGLFFBQVEsS0FBS3pMLFVBQVU7b0JBQUUsT0FBT2lHLE1BQU0vRSxDQUFDLENBQUN5QyxPQUFPLENBQUNzQyxNQUFNd0YsUUFBUSxDQUFDeEwsQ0FBQztnQkFBRztZQUMvRTtZQUNBZ0csTUFBTXNGLFNBQVMsR0FBR2hMLFNBQVMwRixNQUFNakosSUFBSSxDQUFDaU8sTUFBTSxFQUFFaEYsTUFBTXdGLFFBQVE7WUFDNUQsSUFBSXhGLE1BQU1zRixTQUFTLEtBQUt2TCxVQUFVO2dCQUFFLE9BQU9pRyxNQUFNL0UsQ0FBQyxDQUFDeUMsT0FBTyxDQUFDc0MsTUFBTXNGLFNBQVMsQ0FBQ3RMLENBQUM7WUFBRztZQUMvRSxJQUFJZ0csTUFBTXNGLFNBQVMsRUFBRTtnQkFDbkJ0RixNQUFNbEMsTUFBTSxHQUFHeEQsU0FBUzBGLE1BQU1qSixJQUFJLENBQUNtTyxNQUFNLEVBQUVsRixNQUFNd0YsUUFBUTtnQkFDekQsSUFBSXhGLE1BQU1sQyxNQUFNLEtBQUsvRCxVQUFVO29CQUFFLE9BQU9pRyxNQUFNL0UsQ0FBQyxDQUFDeUMsT0FBTyxDQUFDc0MsTUFBTWxDLE1BQU0sQ0FBQzlELENBQUM7Z0JBQUc7Z0JBQ3pFLElBQUl5TCxPQUFPbkwsU0FBUzBGLE1BQU1qSixJQUFJLENBQUNvTyxPQUFPLEVBQUVuRixNQUFNd0YsUUFBUTtnQkFDdEQsSUFBSUMsU0FBUzFMLFVBQVU7b0JBQUUsT0FBT2lHLE1BQU0vRSxDQUFDLENBQUN5QyxPQUFPLENBQUMrSCxLQUFLekwsQ0FBQztnQkFBRztnQkFDekRxTCxRQUFRckYsT0FBT3lGO1lBQ2pCLE9BQU87Z0JBQ0x6RixNQUFNL0UsQ0FBQyxDQUFDSSxXQUFXO1lBQ3JCO1FBQ0Y7UUFFQXFKLDJCQUEyQnhNLFNBQVMsQ0FBQzhDLGFBQWEsR0FBRyxTQUFVQyxDQUFDO1lBQzlELElBQUkrRSxRQUFRO2dCQUNWL0UsR0FBR0E7Z0JBQ0hsRSxNQUFNLElBQUk7Z0JBQ1Z5TyxVQUFVLElBQUksQ0FBQ1QsTUFBTTtnQkFDckJRLE9BQU87Z0JBQ1BELFdBQVc7WUFDYjtZQUNBLE9BQU8sSUFBSSxDQUFDdkssRUFBRSxDQUFDZSx1QkFBdUIsQ0FBQ2tFLE9BQU8sSUFBSS9ELEtBQUssSUFBSSxDQUFDbEIsRUFBRSxDQUFDaUIsR0FBRyxLQUFLb0o7UUFDekU7UUFFQSxPQUFPVjtJQUNULEVBQUV0TTtJQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkMsR0FDREosV0FBVzBOLHdCQUF3QixHQUFHLFNBQVVDLFlBQVksRUFBRUMsU0FBUyxFQUFFQyxPQUFPLEVBQUVDLGNBQWMsRUFBRUMsWUFBWSxFQUFFdkssU0FBUztRQUN2SDVCLFlBQVk0QixjQUFlQSxDQUFBQSxZQUFZMUMsZ0JBQWU7UUFDdEQsT0FBTyxJQUFJNEwsMkJBQTJCaUIsY0FBY0MsV0FBV0MsU0FBU0MsZ0JBQWdCQyxjQUFjdks7SUFDeEc7SUFFQSxJQUFJd0ssNkJBQThCLFNBQVVyTCxTQUFTO1FBQ25EOUMsU0FBU21PLDRCQUE0QnJMO1FBQ3JDLFNBQVNxTCwyQkFBMkJoRyxLQUFLLEVBQUUyRSxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVqSyxDQUFDO1lBQ3ZFLElBQUksQ0FBQ2tLLE1BQU0sR0FBRy9FO1lBQ2QsSUFBSSxDQUFDZ0YsTUFBTSxHQUFHTDtZQUNkLElBQUksQ0FBQ00sTUFBTSxHQUFHTDtZQUNkLElBQUksQ0FBQ00sTUFBTSxHQUFHTDtZQUNkLElBQUksQ0FBQ00sT0FBTyxHQUFHTDtZQUNmLElBQUksQ0FBQy9KLEVBQUUsR0FBR0Y7WUFDVkYsVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUEsU0FBUzBOLGtCQUFrQnBGLEtBQUssRUFBRXFGLE9BQU87WUFDdkNyRixNQUFNc0YsU0FBUyxJQUFJdEYsTUFBTS9FLENBQUMsQ0FBQ0csTUFBTSxDQUFDNEUsTUFBTWxDLE1BQU07WUFFOUMsSUFBSWtDLE1BQU11RixLQUFLLEVBQUU7Z0JBQ2Z2RixNQUFNdUYsS0FBSyxHQUFHO1lBQ2hCLE9BQU87Z0JBQ0x2RixNQUFNd0YsUUFBUSxHQUFHbEwsU0FBUzBGLE1BQU1qSixJQUFJLENBQUNrTyxNQUFNLEVBQUVqRixNQUFNd0YsUUFBUTtnQkFDM0QsSUFBSXhGLE1BQU13RixRQUFRLEtBQUt6TCxVQUFVO29CQUFFLE9BQU9pRyxNQUFNL0UsQ0FBQyxDQUFDeUMsT0FBTyxDQUFDc0MsTUFBTXdGLFFBQVEsQ0FBQ3hMLENBQUM7Z0JBQUc7WUFDL0U7WUFFQWdHLE1BQU1zRixTQUFTLEdBQUdoTCxTQUFTMEYsTUFBTWpKLElBQUksQ0FBQ2lPLE1BQU0sRUFBRWhGLE1BQU13RixRQUFRO1lBQzVELElBQUl4RixNQUFNc0YsU0FBUyxLQUFLdkwsVUFBVTtnQkFBRSxPQUFPaUcsTUFBTS9FLENBQUMsQ0FBQ3lDLE9BQU8sQ0FBQ3NDLE1BQU1zRixTQUFTLENBQUN0TCxDQUFDO1lBQUc7WUFDL0UsSUFBSWdHLE1BQU1zRixTQUFTLEVBQUU7Z0JBQ25CdEYsTUFBTWxDLE1BQU0sR0FBR3hELFNBQVMwRixNQUFNakosSUFBSSxDQUFDbU8sTUFBTSxFQUFFbEYsTUFBTXdGLFFBQVE7Z0JBQ3pELElBQUl4RixNQUFNbEMsTUFBTSxLQUFLL0QsVUFBVTtvQkFBRSxPQUFPaUcsTUFBTS9FLENBQUMsQ0FBQ3lDLE9BQU8sQ0FBQ3NDLE1BQU1sQyxNQUFNLENBQUM5RCxDQUFDO2dCQUFHO2dCQUN6RSxJQUFJeUwsT0FBT25MLFNBQVMwRixNQUFNakosSUFBSSxDQUFDb08sT0FBTyxFQUFFbkYsTUFBTXdGLFFBQVE7Z0JBQ3RELElBQUlDLFNBQVMxTCxVQUFVO29CQUFFLE9BQU9pRyxNQUFNL0UsQ0FBQyxDQUFDeUMsT0FBTyxDQUFDK0gsS0FBS3pMLENBQUM7Z0JBQUc7Z0JBQ3pEcUwsUUFBUXJGLE9BQU95RjtZQUNqQixPQUFPO2dCQUNMekYsTUFBTS9FLENBQUMsQ0FBQ0ksV0FBVztZQUNyQjtRQUNGO1FBRUEySywyQkFBMkI5TixTQUFTLENBQUM4QyxhQUFhLEdBQUcsU0FBVUMsQ0FBQztZQUM5RCxJQUFJK0UsUUFBUTtnQkFDVi9FLEdBQUdBO2dCQUNIbEUsTUFBTSxJQUFJO2dCQUNWeU8sVUFBVSxJQUFJLENBQUNULE1BQU07Z0JBQ3JCUSxPQUFPO2dCQUNQRCxXQUFXO1lBQ2I7WUFDQSxPQUFPLElBQUksQ0FBQ3ZLLEVBQUUsQ0FBQ2UsdUJBQXVCLENBQUNrRSxPQUFPLEdBQUdvRjtRQUNuRDtRQUVBLE9BQU9ZO0lBQ1QsRUFBRTVOO0lBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCQyxHQUNESixXQUFXaU8sd0JBQXdCLEdBQUcsU0FBVU4sWUFBWSxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxZQUFZLEVBQUV2SyxTQUFTO1FBQ3ZINUIsWUFBWTRCLGNBQWVBLENBQUFBLFlBQVkxQyxnQkFBZTtRQUN0RCxPQUFPLElBQUlrTiwyQkFBMkJMLGNBQWNDLFdBQVdDLFNBQVNDLGdCQUFnQkMsY0FBY3ZLO0lBQ3hHO0lBRUEsSUFBSTBLLG9CQUFxQixTQUFTdkwsU0FBUztRQUN6QzlDLFNBQVNxTyxtQkFBbUJ2TDtRQUM1QixTQUFTdUwsa0JBQWtCdkosTUFBTSxFQUFFL0IsRUFBRSxFQUFFQyxDQUFDO1lBQ3RDLElBQUksQ0FBQzhCLE1BQU0sR0FBR0E7WUFDZCxJQUFJLENBQUM3QixHQUFHLEdBQUdGO1lBQ1gsSUFBSSxDQUFDRyxFQUFFLEdBQUdGO1lBQ1ZGLFVBQVVqRCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBd08sa0JBQWtCaE8sU0FBUyxDQUFDOEMsYUFBYSxHQUFHLFNBQVVDLENBQUM7WUFDckQsSUFBSVcsSUFBSSxJQUFJM0M7WUFFWjJDLEVBQUUrQixhQUFhLENBQUMsSUFBSSxDQUFDNUMsRUFBRSxDQUFDRyxjQUFjLENBQUM7Z0JBQUMsSUFBSSxDQUFDeUIsTUFBTTtnQkFBRTFCO2dCQUFHVzthQUFFLEVBQUUsSUFBSSxDQUFDZCxHQUFHLEVBQUVLO1lBRXRFLE9BQU9TO1FBQ1Q7UUFFQSxTQUFTVCxlQUFlTixDQUFDLEVBQUVtRixLQUFLO1lBQzlCLElBQUlyRCxTQUFTcUQsS0FBSyxDQUFDLEVBQUUsRUFBRS9FLElBQUkrRSxLQUFLLENBQUMsRUFBRSxFQUFFcEUsSUFBSW9FLEtBQUssQ0FBQyxFQUFFO1lBQ2pEcEUsRUFBRStCLGFBQWEsQ0FBQ2hCLE9BQU9TLFNBQVMsQ0FBQ25DO1FBQ25DO1FBRUEsT0FBT2lMO0lBQ1QsRUFBRTlOO0lBRUY7Ozs7Ozs7Ozs7R0FVQyxHQUNESCxnQkFBZ0JrTyxpQkFBaUIsR0FBRyxTQUFVNUssT0FBTyxFQUFFQyxTQUFTO1FBQzlENUIsWUFBWTRCLGNBQWVBLENBQUFBLFlBQVkxQyxnQkFBZTtRQUN0RCxPQUFPLElBQUlvTixrQkFBa0IsSUFBSSxFQUFFM0ssU0FBU0M7SUFDOUM7SUFFQSxJQUFJNEssNkJBQThCLFNBQVV6TCxTQUFTO1FBQ25EOUMsU0FBU3VPLDRCQUE0QnpMO1FBQ3JDLFNBQVN5TCwyQkFBMkJ6SixNQUFNLEVBQUVmLENBQUMsRUFBRWYsQ0FBQztZQUM5QyxJQUFJLENBQUM4QixNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDK0MsRUFBRSxHQUFHOUQ7WUFDVixJQUFJLENBQUNiLEVBQUUsR0FBR0Y7WUFDVkYsVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUEwTywyQkFBMkJsTyxTQUFTLENBQUM4QyxhQUFhLEdBQUcsU0FBVUMsQ0FBQztZQUM5RCxPQUFPLElBQUksQ0FBQzBCLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDLElBQUlpSix5QkFBeUJwTCxHQUFHLElBQUk7UUFDbkU7UUFFQSxPQUFPbUw7SUFDVCxFQUFFaE87SUFFRixJQUFJaU8sMkJBQTRCLFNBQVUxTCxTQUFTO1FBQ2pEOUMsU0FBU3dPLDBCQUEwQjFMO1FBRW5DLFNBQVMwTCx5QkFBeUJwTCxDQUFDLEVBQUVZLENBQUM7WUFDcEMsSUFBSSxDQUFDNEQsRUFBRSxHQUFHeEU7WUFDVixJQUFJLENBQUNGLEVBQUUsR0FBR2MsRUFBRWQsRUFBRTtZQUNkLElBQUksQ0FBQzJFLEVBQUUsR0FBRzdELEVBQUU2RCxFQUFFO1lBQ2QsSUFBSSxDQUFDNEcsRUFBRSxHQUFHLEVBQUU7WUFDWjNMLFVBQVVqRCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBMk8seUJBQXlCbk8sU0FBUyxDQUFDZ0ksSUFBSSxHQUFHLFNBQVVwQixDQUFDO1lBQ25ELElBQUk5QyxNQUFNLElBQUksQ0FBQ2pCLEVBQUUsQ0FBQ2lCLEdBQUc7WUFDckIsSUFBSSxDQUFDc0ssRUFBRSxDQUFDOUksSUFBSSxDQUFDO2dCQUFFbEIsVUFBVU47Z0JBQUszRixPQUFPeUk7WUFBRTtZQUN2QyxNQUFPLElBQUksQ0FBQ3dILEVBQUUsQ0FBQ3RJLE1BQU0sR0FBRyxLQUFLaEMsTUFBTSxJQUFJLENBQUNzSyxFQUFFLENBQUMsRUFBRSxDQUFDaEssUUFBUSxJQUFJLElBQUksQ0FBQ29ELEVBQUUsQ0FBRTtnQkFDakUsSUFBSSxDQUFDRCxFQUFFLENBQUNyRSxNQUFNLENBQUMsSUFBSSxDQUFDa0wsRUFBRSxDQUFDckksS0FBSyxHQUFHNUgsS0FBSztZQUN0QztRQUNGO1FBQ0FnUSx5QkFBeUJuTyxTQUFTLENBQUN1RixLQUFLLEdBQUcsU0FBVXpELENBQUM7WUFBSSxJQUFJLENBQUN5RixFQUFFLENBQUMvQixPQUFPLENBQUMxRDtRQUFJO1FBQzlFcU0seUJBQXlCbk8sU0FBUyxDQUFDaUksU0FBUyxHQUFHO1lBQzdDLElBQUluRSxNQUFNLElBQUksQ0FBQ2pCLEVBQUUsQ0FBQ2lCLEdBQUc7WUFDckIsTUFBTyxJQUFJLENBQUNzSyxFQUFFLENBQUN0SSxNQUFNLEdBQUcsS0FBS2hDLE1BQU0sSUFBSSxDQUFDc0ssRUFBRSxDQUFDLEVBQUUsQ0FBQ2hLLFFBQVEsSUFBSSxJQUFJLENBQUNvRCxFQUFFLENBQUU7Z0JBQ2pFLElBQUksQ0FBQ0QsRUFBRSxDQUFDckUsTUFBTSxDQUFDLElBQUksQ0FBQ2tMLEVBQUUsQ0FBQ3JJLEtBQUssR0FBRzVILEtBQUs7WUFDdEM7WUFDQSxJQUFJLENBQUNvSixFQUFFLENBQUNwRSxXQUFXO1FBQ3JCO1FBRUEsT0FBT2dMO0lBQ1QsRUFBRXRPO0lBRUY7Ozs7Ozs7OztHQVNDLEdBQ0RFLGdCQUFnQnNPLGdCQUFnQixHQUFHLFNBQVVDLFFBQVEsRUFBRWhMLFNBQVM7UUFDOUQ1QixZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELE9BQU8sSUFBSXNOLDJCQUEyQixJQUFJLEVBQUVJLFVBQVVoTDtJQUN4RDtJQUVBLElBQUlpTCw2QkFBOEIsU0FBVTlMLFNBQVM7UUFDbkQ5QyxTQUFTNE8sNEJBQTRCOUw7UUFDckMsU0FBUzhMLDJCQUEyQjlKLE1BQU0sRUFBRWYsQ0FBQyxFQUFFZixDQUFDO1lBQzlDLElBQUksQ0FBQzhCLE1BQU0sR0FBR0E7WUFDZCxJQUFJLENBQUMrQyxFQUFFLEdBQUc5RDtZQUNWLElBQUksQ0FBQ2IsRUFBRSxHQUFHRjtZQUNWRixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQStPLDJCQUEyQnZPLFNBQVMsQ0FBQzhDLGFBQWEsR0FBRyxTQUFVQyxDQUFDO1lBQzlELE9BQU8sSUFBSSxDQUFDMEIsTUFBTSxDQUFDUyxTQUFTLENBQUMsSUFBSXNKLHlCQUF5QnpMLEdBQUcsSUFBSSxDQUFDeUUsRUFBRSxFQUFFLElBQUksQ0FBQzNFLEVBQUU7UUFDL0U7UUFFQSxPQUFPMEw7SUFDVCxFQUFFck87SUFFRixJQUFJc08sMkJBQTRCLFNBQVUvTCxTQUFTO1FBQ2pEOUMsU0FBUzZPLDBCQUEwQi9MO1FBRW5DLFNBQVMrTCx5QkFBeUJ6TCxDQUFDLEVBQUVXLENBQUMsRUFBRWYsQ0FBQztZQUN2QyxJQUFJLENBQUM0RSxFQUFFLEdBQUd4RTtZQUNWLElBQUksQ0FBQ3lFLEVBQUUsR0FBRzlEO1lBQ1YsSUFBSSxDQUFDYixFQUFFLEdBQUdGO1lBQ1YsSUFBSSxDQUFDeUwsRUFBRSxHQUFHLEVBQUU7WUFDWjNMLFVBQVVqRCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBZ1AseUJBQXlCeE8sU0FBUyxDQUFDZ0ksSUFBSSxHQUFHLFNBQVVwQixDQUFDO1lBQ25ELElBQUk5QyxNQUFNLElBQUksQ0FBQ2pCLEVBQUUsQ0FBQ2lCLEdBQUc7WUFDckIsSUFBSSxDQUFDc0ssRUFBRSxDQUFDOUksSUFBSSxDQUFDO2dCQUFFbEIsVUFBVU47Z0JBQUszRixPQUFPeUk7WUFBRTtZQUN2QyxNQUFPLElBQUksQ0FBQ3dILEVBQUUsQ0FBQ3RJLE1BQU0sR0FBRyxLQUFLaEMsTUFBTSxJQUFJLENBQUNzSyxFQUFFLENBQUMsRUFBRSxDQUFDaEssUUFBUSxJQUFJLElBQUksQ0FBQ29ELEVBQUUsQ0FBRTtnQkFDakUsSUFBSSxDQUFDNEcsRUFBRSxDQUFDckksS0FBSztZQUNmO1FBQ0Y7UUFDQXlJLHlCQUF5QnhPLFNBQVMsQ0FBQ3VGLEtBQUssR0FBRyxTQUFVekQsQ0FBQztZQUFJLElBQUksQ0FBQ3lGLEVBQUUsQ0FBQy9CLE9BQU8sQ0FBQzFEO1FBQUk7UUFDOUUwTSx5QkFBeUJ4TyxTQUFTLENBQUNpSSxTQUFTLEdBQUc7WUFDN0MsSUFBSW5FLE1BQU0sSUFBSSxDQUFDakIsRUFBRSxDQUFDaUIsR0FBRztZQUNyQixNQUFPLElBQUksQ0FBQ3NLLEVBQUUsQ0FBQ3RJLE1BQU0sR0FBRyxFQUFHO2dCQUN6QixJQUFJa0MsT0FBTyxJQUFJLENBQUNvRyxFQUFFLENBQUNySSxLQUFLO2dCQUN4QixJQUFJakMsTUFBTWtFLEtBQUs1RCxRQUFRLElBQUksSUFBSSxDQUFDb0QsRUFBRSxFQUFFO29CQUFFLElBQUksQ0FBQ0QsRUFBRSxDQUFDckUsTUFBTSxDQUFDOEUsS0FBSzdKLEtBQUs7Z0JBQUc7WUFDcEU7WUFDQSxJQUFJLENBQUNvSixFQUFFLENBQUNwRSxXQUFXO1FBQ3JCO1FBRUEsT0FBT3FMO0lBQ1QsRUFBRTNPO0lBRUY7Ozs7Ozs7OztHQVNDLEdBQ0RFLGdCQUFnQjBPLGdCQUFnQixHQUFHLFNBQVVILFFBQVEsRUFBRWhMLFNBQVM7UUFDOUQ1QixZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELE9BQU8sSUFBSTJOLDJCQUEyQixJQUFJLEVBQUVELFVBQVVoTDtJQUN4RDtJQUVBOzs7Ozs7Ozs7R0FTQyxHQUNEdkQsZ0JBQWdCMk8sc0JBQXNCLEdBQUcsU0FBVUosUUFBUSxFQUFFaEwsU0FBUztRQUNwRSxJQUFJbUIsU0FBUyxJQUFJO1FBQ2pCL0MsWUFBWTRCLGNBQWVBLENBQUFBLFlBQVkxQyxnQkFBZTtRQUN0RCxPQUFPLElBQUlYLG9CQUFvQixTQUFVOEMsQ0FBQztZQUN4QyxJQUFJOEIsSUFBSSxFQUFFO1lBQ1YsT0FBT0osT0FBT1MsU0FBUyxDQUFDLFNBQVUwQixDQUFDO2dCQUNqQyxJQUFJOUMsTUFBTVIsVUFBVVEsR0FBRztnQkFDdkJlLEVBQUVTLElBQUksQ0FBQztvQkFBRWxCLFVBQVVOO29CQUFLM0YsT0FBT3lJO2dCQUFFO2dCQUNqQyxNQUFPL0IsRUFBRWlCLE1BQU0sR0FBRyxLQUFLaEMsTUFBTWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQ1QsUUFBUSxJQUFJa0ssU0FBVTtvQkFDdER6SixFQUFFa0IsS0FBSztnQkFDVDtZQUNGLEdBQUcsU0FBVWpFLENBQUM7Z0JBQUlpQixFQUFFeUMsT0FBTyxDQUFDMUQ7WUFBSSxHQUFHO2dCQUNqQyxJQUFJZ0MsTUFBTVIsVUFBVVEsR0FBRyxJQUFJeUksTUFBTSxFQUFFO2dCQUNuQyxNQUFPMUgsRUFBRWlCLE1BQU0sR0FBRyxFQUFHO29CQUNuQixJQUFJa0MsT0FBT25ELEVBQUVrQixLQUFLO29CQUNsQmpDLE1BQU1rRSxLQUFLNUQsUUFBUSxJQUFJa0ssWUFBWS9CLElBQUlqSCxJQUFJLENBQUMwQyxLQUFLN0osS0FBSztnQkFDeEQ7Z0JBQ0E0RSxFQUFFRyxNQUFNLENBQUNxSjtnQkFDVHhKLEVBQUVJLFdBQVc7WUFDZjtRQUNGLEdBQUdzQjtJQUNMO0lBRUEsSUFBSWtLLHlCQUEwQixTQUFVbE0sU0FBUztRQUMvQzlDLFNBQVNnUCx3QkFBd0JsTTtRQUNqQyxTQUFTa00sdUJBQXVCbEssTUFBTSxFQUFFZixDQUFDLEVBQUVmLENBQUM7WUFDMUMsSUFBSSxDQUFDOEIsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQytDLEVBQUUsR0FBRzlEO1lBQ1YsSUFBSSxDQUFDYixFQUFFLEdBQUdGO1lBQ1ZGLFVBQVVqRCxJQUFJLENBQUMsSUFBSTtRQUNyQjtRQUVBLFNBQVN5RCxlQUFlTixDQUFDLEVBQUVJLENBQUM7WUFDMUJBLEVBQUVJLFdBQVc7UUFDZjtRQUVBd0wsdUJBQXVCM08sU0FBUyxDQUFDOEMsYUFBYSxHQUFHLFNBQVVDLENBQUM7WUFDMUQsT0FBTyxJQUFJOUIsaUJBQ1QsSUFBSSxDQUFDNEIsRUFBRSxDQUFDRyxjQUFjLENBQUNELEdBQUcsSUFBSSxDQUFDeUUsRUFBRSxFQUFFdkUsaUJBQ25DLElBQUksQ0FBQ3dCLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDbkM7UUFFMUI7UUFFQSxPQUFPNEw7SUFDVCxFQUFFek87SUFFRjs7Ozs7Ozs7Ozs7O0dBWUMsR0FDREgsZ0JBQWdCNk8sWUFBWSxHQUFHLFNBQVVOLFFBQVEsRUFBRWhMLFNBQVM7UUFDMUQ1QixZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELE9BQU8sSUFBSStOLHVCQUF1QixJQUFJLEVBQUVMLFVBQVVoTDtJQUNwRDtJQUVBLElBQUl1TCx5QkFBMEIsU0FBVXBNLFNBQVM7UUFDL0M5QyxTQUFTa1Asd0JBQXdCcE07UUFDakMsU0FBU29NLHVCQUF1QnBLLE1BQU0sRUFBRWYsQ0FBQyxFQUFFZixDQUFDO1lBQzFDLElBQUksQ0FBQzhCLE1BQU0sR0FBR0E7WUFDZCxJQUFJLENBQUMrQyxFQUFFLEdBQUc5RDtZQUNWLElBQUksQ0FBQ2IsRUFBRSxHQUFHRjtZQUNWLElBQUksQ0FBQ21NLEtBQUssR0FBRztZQUNick0sVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUEsU0FBU3lELGVBQWVOLENBQUMsRUFBRTlELEtBQUk7WUFDN0JBLE1BQUtpUSxLQUFLLEdBQUc7UUFDZjtRQUVBRCx1QkFBdUI3TyxTQUFTLENBQUM4QyxhQUFhLEdBQUcsU0FBVUMsQ0FBQztZQUMxRCxPQUFPLElBQUk5QixpQkFDVCxJQUFJLENBQUM0QixFQUFFLENBQUNHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDd0UsRUFBRSxFQUFFdkUsaUJBQ3RDLElBQUksQ0FBQ3dCLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDLElBQUk2SixxQkFBcUJoTSxHQUFHLElBQUk7UUFFMUQ7UUFFQSxPQUFPOEw7SUFDVCxFQUFFM087SUFFRixJQUFJNk8sdUJBQXdCLFNBQVV0TSxTQUFTO1FBQzdDOUMsU0FBU29QLHNCQUFzQnRNO1FBRS9CLFNBQVNzTSxxQkFBcUJoTSxDQUFDLEVBQUVZLENBQUM7WUFDaEMsSUFBSSxDQUFDNEQsRUFBRSxHQUFHeEU7WUFDVixJQUFJLENBQUNpTSxFQUFFLEdBQUdyTDtZQUNWbEIsVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUF1UCxxQkFBcUIvTyxTQUFTLENBQUNnSSxJQUFJLEdBQUcsU0FBVXBCLENBQUM7WUFBSSxJQUFJLENBQUNvSSxFQUFFLENBQUNGLEtBQUssSUFBSSxJQUFJLENBQUN2SCxFQUFFLENBQUNyRSxNQUFNLENBQUMwRDtRQUFJO1FBQ3pGbUkscUJBQXFCL08sU0FBUyxDQUFDdUYsS0FBSyxHQUFHLFNBQVV6RCxDQUFDO1lBQUksSUFBSSxDQUFDeUYsRUFBRSxDQUFDL0IsT0FBTyxDQUFDMUQ7UUFBSTtRQUMxRWlOLHFCQUFxQi9PLFNBQVMsQ0FBQ2lJLFNBQVMsR0FBRztZQUFjLElBQUksQ0FBQ1YsRUFBRSxDQUFDcEUsV0FBVztRQUFJO1FBRWhGLE9BQU80TDtJQUNULEVBQUVsUDtJQUVGOzs7Ozs7Ozs7OztHQVdDLEdBQ0RFLGdCQUFnQmtQLFlBQVksR0FBRyxTQUFVWCxRQUFRLEVBQUVoTCxTQUFTO1FBQzFENUIsWUFBWTRCLGNBQWVBLENBQUFBLFlBQVkxQyxnQkFBZTtRQUN0RCxPQUFPLElBQUlpTyx1QkFBdUIsSUFBSSxFQUFFUCxVQUFVaEw7SUFDcEQ7SUFFQSxJQUFJNEwsOEJBQStCLFNBQVV6TSxTQUFTO1FBQ3BEOUMsU0FBU3VQLDZCQUE2QnpNO1FBQ3RDLFNBQVN5TSw0QkFBNEJ6SyxNQUFNLEVBQUUwSyxTQUFTLEVBQUU3TCxTQUFTO1lBQy9ELElBQUksQ0FBQ21CLE1BQU0sR0FBR0E7WUFDZCxJQUFJLENBQUMySyxHQUFHLEdBQUdEO1lBQ1gsSUFBSSxDQUFDdE0sRUFBRSxHQUFHUztZQUNWYixVQUFVakQsSUFBSSxDQUFDLElBQUk7UUFDckI7UUFFQSxTQUFTeUQsZUFBZU4sQ0FBQyxFQUFFbUYsS0FBSztZQUM5QkEsTUFBTWdILEtBQUssR0FBRztRQUNoQjtRQUVBSSw0QkFBNEJsUCxTQUFTLENBQUM4QyxhQUFhLEdBQUcsU0FBVUMsQ0FBQztZQUMvRCxJQUFJLENBQUMrTCxLQUFLLEdBQUc7WUFDYixPQUFPLElBQUk3TixpQkFDVCxJQUFJLENBQUM0QixFQUFFLENBQUNHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDb00sR0FBRyxFQUFFbk0saUJBQ3ZDLElBQUksQ0FBQ3dCLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDLElBQUltSywwQkFBMEJ0TSxHQUFHLElBQUk7UUFFL0Q7UUFFQSxPQUFPbU07SUFDVCxFQUFFaFA7SUFFRixJQUFJbVAsNEJBQTZCLFNBQVU1TSxTQUFTO1FBQ2xEOUMsU0FBUzBQLDJCQUEyQjVNO1FBRXBDLFNBQVM0TSwwQkFBMEJ0TSxDQUFDLEVBQUVZLENBQUM7WUFDckMsSUFBSSxDQUFDNEQsRUFBRSxHQUFHeEU7WUFDVixJQUFJLENBQUNpTSxFQUFFLEdBQUdyTDtZQUNWbEIsVUFBVWpELElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUE2UCwwQkFBMEJyUCxTQUFTLENBQUNnSSxJQUFJLEdBQUcsU0FBVXBCLENBQUM7WUFBSSxJQUFJLENBQUNvSSxFQUFFLENBQUNGLEtBQUssSUFBSSxJQUFJLENBQUN2SCxFQUFFLENBQUNyRSxNQUFNLENBQUMwRDtRQUFJO1FBQzlGeUksMEJBQTBCclAsU0FBUyxDQUFDdUYsS0FBSyxHQUFHLFNBQVV6RCxDQUFDO1lBQUksSUFBSSxDQUFDeUYsRUFBRSxDQUFDL0IsT0FBTyxDQUFDMUQ7UUFBSTtRQUMvRXVOLDBCQUEwQnJQLFNBQVMsQ0FBQ2lJLFNBQVMsR0FBRztZQUFjLElBQUksQ0FBQ1YsRUFBRSxDQUFDcEUsV0FBVztRQUFJO1FBRXJGLE9BQU9rTTtJQUNULEVBQUV4UDtJQUdGOzs7Ozs7Ozs7O0dBVUMsR0FDREUsZ0JBQWdCdVAsaUJBQWlCLEdBQUcsU0FBVUgsU0FBUyxFQUFFN0wsU0FBUztRQUNoRTVCLFlBQVk0QixjQUFlQSxDQUFBQSxZQUFZMUMsZ0JBQWU7UUFDdEQsT0FBTyxJQUFJc08sNEJBQTRCLElBQUksRUFBRUMsV0FBVzdMO0lBQzFEO0lBRUE7Ozs7O0dBS0MsR0FDRHZELGdCQUFnQndQLGlCQUFpQixHQUFHLFNBQVVDLE9BQU8sRUFBRWxNLFNBQVM7UUFDOUQ1QixZQUFZNEIsY0FBZUEsQ0FBQUEsWUFBWTFDLGdCQUFlO1FBQ3RELElBQUk2RCxTQUFTLElBQUk7UUFDakIsT0FBTyxJQUFJeEUsb0JBQW9CLFNBQVU4QyxDQUFDO1lBQ3hDLE9BQU8sSUFBSTlCLGlCQUNUcUMsVUFBVU4sY0FBYyxDQUFDRCxHQUFHeU0sU0FBUyxTQUFVOUosQ0FBQyxFQUFFM0MsQ0FBQztnQkFBSUEsRUFBRUksV0FBVztZQUFJLElBQ3hFc0IsT0FBT1MsU0FBUyxDQUFDbkM7UUFDckIsR0FBRzBCO0lBQ0w7SUFFQTs7Ozs7R0FLQyxHQUNEMUUsZ0JBQWdCdUksUUFBUSxHQUFHLFNBQVVtSCxjQUFjLEVBQUVuTSxTQUFTO1FBQzVENUIsWUFBWTRCLGNBQWVBLENBQUFBLFlBQVkxQyxnQkFBZTtRQUN0RCxJQUFJME4sV0FBVyxDQUFDbUIsa0JBQWtCO1FBQ2xDLElBQUluQixZQUFZLEdBQUc7WUFBRSxNQUFNLElBQUlvQixXQUFXO1FBQWlEO1FBQzNGLElBQUlqTCxTQUFTLElBQUk7UUFDakIsT0FBTyxJQUFJeEUsb0JBQW9CLFNBQVU4QyxDQUFDO1lBQ3hDLElBQUk0TSxhQUFhO1lBQ2pCLE9BQU9sTCxPQUFPUyxTQUFTLENBQ3JCLFNBQVUwQixDQUFDO2dCQUNULElBQUk5QyxNQUFNUixVQUFVUSxHQUFHO2dCQUN2QixJQUFJNkwsZUFBZSxLQUFLN0wsTUFBTTZMLGNBQWNyQixVQUFVO29CQUNwRHFCLGFBQWE3TDtvQkFDYmYsRUFBRUcsTUFBTSxDQUFDMEQ7Z0JBQ1g7WUFDRixHQUFFLFNBQVU5RSxDQUFDO2dCQUFJaUIsRUFBRXlDLE9BQU8sQ0FBQzFEO1lBQUksR0FBRztnQkFBY2lCLEVBQUVJLFdBQVc7WUFBSTtRQUVyRSxHQUFHc0I7SUFDTDtJQUVBLE9BQU9uRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9kaXN0L3J4LnRpbWUuanM/ZDQ1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCwgQWxsIHJpZ2h0cyByZXNlcnZlZC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0dsb2JhbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgdmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKSA/IGV4cG9ydHMgOiBudWxsO1xuICB2YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSkgPyBtb2R1bGUgOiBudWxsO1xuICB2YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcbiAgdmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuICB2YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG4gIHZhciBtb2R1bGVFeHBvcnRzID0gKGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykgPyBmcmVlRXhwb3J0cyA6IG51bGw7XG4gIHZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvLyBCZWNhdXNlIG9mIGJ1aWxkIG9wdGltaXplcnNcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJy4vcngnXSwgZnVuY3Rpb24gKFJ4LCBleHBvcnRzKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShyb290LCBleHBvcnRzLCBSeCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyb290LCBtb2R1bGUuZXhwb3J0cywgcmVxdWlyZSgnLi9yeCcpKTtcbiAgfSBlbHNlIHtcbiAgICByb290LlJ4ID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5SeCk7XG4gIH1cbn0uY2FsbCh0aGlzLCBmdW5jdGlvbiAocm9vdCwgZXhwLCBSeCwgdW5kZWZpbmVkKSB7XG5cbiAgLy8gUmVmZXJuY2VzXG4gIHZhciBpbmhlcml0cyA9IFJ4LmludGVybmFscy5pbmhlcml0cyxcbiAgICBBYnN0cmFjdE9ic2VydmVyID0gUnguaW50ZXJuYWxzLkFic3RyYWN0T2JzZXJ2ZXIsXG4gICAgT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUsXG4gICAgb2JzZXJ2YWJsZVByb3RvID0gT2JzZXJ2YWJsZS5wcm90b3R5cGUsXG4gICAgQW5vbnltb3VzT2JzZXJ2YWJsZSA9IFJ4LkFub255bW91c09ic2VydmFibGUsXG4gICAgT2JzZXJ2YWJsZUJhc2UgPSBSeC5PYnNlcnZhYmxlQmFzZSxcbiAgICBvYnNlcnZhYmxlRGVmZXIgPSBPYnNlcnZhYmxlLmRlZmVyLFxuICAgIG9ic2VydmFibGVFbXB0eSA9IE9ic2VydmFibGUuZW1wdHksXG4gICAgb2JzZXJ2YWJsZU5ldmVyID0gT2JzZXJ2YWJsZS5uZXZlcixcbiAgICBvYnNlcnZhYmxlVGhyb3cgPSBPYnNlcnZhYmxlWyd0aHJvdyddLFxuICAgIG9ic2VydmFibGVGcm9tQXJyYXkgPSBPYnNlcnZhYmxlLmZyb21BcnJheSxcbiAgICBkZWZhdWx0U2NoZWR1bGVyID0gUnguU2NoZWR1bGVyWydkZWZhdWx0J10sXG4gICAgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUgPSBSeC5TaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSxcbiAgICBTZXJpYWxEaXNwb3NhYmxlID0gUnguU2VyaWFsRGlzcG9zYWJsZSxcbiAgICBDb21wb3NpdGVEaXNwb3NhYmxlID0gUnguQ29tcG9zaXRlRGlzcG9zYWJsZSxcbiAgICBCaW5hcnlEaXNwb3NhYmxlID0gUnguQmluYXJ5RGlzcG9zYWJsZSxcbiAgICBSZWZDb3VudERpc3Bvc2FibGUgPSBSeC5SZWZDb3VudERpc3Bvc2FibGUsXG4gICAgU3ViamVjdCA9IFJ4LlN1YmplY3QsXG4gICAgYWRkUmVmID0gUnguaW50ZXJuYWxzLmFkZFJlZixcbiAgICBub3JtYWxpemVUaW1lID0gUnguU2NoZWR1bGVyLm5vcm1hbGl6ZSxcbiAgICBoZWxwZXJzID0gUnguaGVscGVycyxcbiAgICBpc1Byb21pc2UgPSBoZWxwZXJzLmlzUHJvbWlzZSxcbiAgICBpc0Z1bmN0aW9uID0gaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgIGlzU2NoZWR1bGVyID0gUnguU2NoZWR1bGVyLmlzU2NoZWR1bGVyLFxuICAgIG9ic2VydmFibGVGcm9tUHJvbWlzZSA9IE9ic2VydmFibGUuZnJvbVByb21pc2U7XG5cbiAgdmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbiAgXG4gIGZ1bmN0aW9uIHRyeUNhdGNoZXJHZW4odHJ5Q2F0Y2hUYXJnZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgdHJ5Q2F0Y2ggPSBSeC5pbnRlcm5hbHMudHJ5Q2F0Y2ggPSBmdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignZm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7IH1cbiAgICByZXR1cm4gdHJ5Q2F0Y2hlckdlbihmbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIHZhciBUaW1lck9ic2VydmFibGUgPSAoZnVuY3Rpb24oX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZXJPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdCwgcykge1xuICAgICAgdGhpcy5fZHQgPSBkdDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZXJPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zLnNjaGVkdWxlRnV0dXJlKG8sIHRoaXMuX2R0LCBzY2hlZHVsZU1ldGhvZCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWV0aG9kKHMsIG8pIHtcbiAgICAgIG8ub25OZXh0KDApO1xuICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBUaW1lck9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICBmdW5jdGlvbiBfb2JzZXJ2YWJsZVRpbWVyKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgVGltZXJPYnNlcnZhYmxlKGR1ZVRpbWUsIHNjaGVkdWxlcik7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlVGltZXJEYXRlQW5kUGVyaW9kKGR1ZVRpbWUsIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGQgPSBkdWVUaW1lLCBwID0gbm9ybWFsaXplVGltZShwZXJpb2QpO1xuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZSgwLCBkLCBmdW5jdGlvbiAoY291bnQsIHNlbGYpIHtcbiAgICAgICAgaWYgKHAgPiAwKSB7XG4gICAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcbiAgICAgICAgICBkID0gbmV3IERhdGUoZC5nZXRUaW1lKCkgKyBwKTtcbiAgICAgICAgICBkLmdldFRpbWUoKSA8PSBub3cgJiYgKGQgPSBuZXcgRGF0ZShub3cgKyBwKSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGNvdW50KTtcbiAgICAgICAgc2VsZihjb3VudCArIDEsIG5ldyBEYXRlKGQpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZVRpbWVyVGltZVNwYW5BbmRQZXJpb2QoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gZHVlVGltZSA9PT0gcGVyaW9kID9cbiAgICAgIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlUGVyaW9kaWMoMCwgcGVyaW9kLCBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQoY291bnQpO1xuICAgICAgICAgIHJldHVybiBjb3VudCArIDE7XG4gICAgICAgIH0pO1xuICAgICAgfSkgOlxuICAgICAgb2JzZXJ2YWJsZURlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVUaW1lckRhdGVBbmRQZXJpb2QobmV3IERhdGUoc2NoZWR1bGVyLm5vdygpICsgZHVlVGltZSksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGVhY2ggcGVyaW9kLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAqICAyIC0gcmVzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwLCBSeC5TY2hlZHVsZXIudGltZW91dCk7XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2QgUGVyaW9kIGZvciBwcm9kdWNpbmcgdGhlIHZhbHVlcyBpbiB0aGUgcmVzdWx0aW5nIHNlcXVlbmNlIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIFJ4LlNjaGVkdWxlci50aW1lb3V0IGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgcHJvZHVjZXMgYSB2YWx1ZSBhZnRlciBlYWNoIHBlcmlvZC5cbiAgICovXG4gIHZhciBvYnNlcnZhYmxlaW50ZXJ2YWwgPSBPYnNlcnZhYmxlLmludGVydmFsID0gZnVuY3Rpb24gKHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVUaW1lclRpbWVTcGFuQW5kUGVyaW9kKHBlcmlvZCwgcGVyaW9kLCBpc1NjaGVkdWxlcihzY2hlZHVsZXIpID8gc2NoZWR1bGVyIDogZGVmYXVsdFNjaGVkdWxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGR1ZVRpbWUgaGFzIGVsYXBzZWQgYW5kIHRoZW4gYWZ0ZXIgZWFjaCBwZXJpb2QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdWVUaW1lIEFic29sdXRlIChzcGVjaWZpZWQgYXMgYSBEYXRlIG9iamVjdCkgb3IgcmVsYXRpdmUgdGltZSAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSBhdCB3aGljaCB0byBwcm9kdWNlIHRoZSBmaXJzdCB2YWx1ZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3BlcmlvZE9yU2NoZWR1bGVyXSAgUGVyaW9kIHRvIHByb2R1Y2Ugc3Vic2VxdWVudCB2YWx1ZXMgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcyksIG9yIHRoZSBzY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHJlc3VsdGluZyB0aW1lciBpcyBub3QgcmVjdXJyaW5nLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgdGhhdCBwcm9kdWNlcyBhIHZhbHVlIGFmdGVyIGR1ZSB0aW1lIGhhcyBlbGFwc2VkIGFuZCB0aGVuIGVhY2ggcGVyaW9kLlxuICAgKi9cbiAgdmFyIG9ic2VydmFibGVUaW1lciA9IE9ic2VydmFibGUudGltZXIgPSBmdW5jdGlvbiAoZHVlVGltZSwgcGVyaW9kT3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICAgIHZhciBwZXJpb2Q7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgaWYgKHBlcmlvZE9yU2NoZWR1bGVyICE9IG51bGwgJiYgdHlwZW9mIHBlcmlvZE9yU2NoZWR1bGVyID09PSAnbnVtYmVyJykge1xuICAgICAgcGVyaW9kID0gcGVyaW9kT3JTY2hlZHVsZXI7XG4gICAgfSBlbHNlIGlmIChpc1NjaGVkdWxlcihwZXJpb2RPclNjaGVkdWxlcikpIHtcbiAgICAgIHNjaGVkdWxlciA9IHBlcmlvZE9yU2NoZWR1bGVyO1xuICAgIH1cbiAgICBpZiAoKGR1ZVRpbWUgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBkdWVUaW1lID09PSAnbnVtYmVyJykgJiYgcGVyaW9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfb2JzZXJ2YWJsZVRpbWVyKGR1ZVRpbWUsIHNjaGVkdWxlcik7XG4gICAgfVxuICAgIGlmIChkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSAmJiBwZXJpb2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG9ic2VydmFibGVUaW1lckRhdGVBbmRQZXJpb2QoZHVlVGltZSwgcGVyaW9kT3JTY2hlZHVsZXIsIHNjaGVkdWxlcik7XG4gICAgfVxuICAgIHJldHVybiBvYnNlcnZhYmxlVGltZXJUaW1lU3BhbkFuZFBlcmlvZChkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZURlbGF5UmVsYXRpdmUoc291cmNlLCBkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c09ic2VydmFibGUoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhY3RpdmUgPSBmYWxzZSxcbiAgICAgICAgY2FuY2VsYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIGV4Y2VwdGlvbiA9IG51bGwsXG4gICAgICAgIHEgPSBbXSxcbiAgICAgICAgcnVubmluZyA9IGZhbHNlLFxuICAgICAgICBzdWJzY3JpcHRpb247XG4gICAgICBzdWJzY3JpcHRpb24gPSBzb3VyY2UubWF0ZXJpYWxpemUoKS50aW1lc3RhbXAoc2NoZWR1bGVyKS5zdWJzY3JpYmUoZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgICB2YXIgZCwgc2hvdWxkUnVuO1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnZhbHVlLmtpbmQgPT09ICdFJykge1xuICAgICAgICAgIHEgPSBbXTtcbiAgICAgICAgICBxLnB1c2gobm90aWZpY2F0aW9uKTtcbiAgICAgICAgICBleGNlcHRpb24gPSBub3RpZmljYXRpb24udmFsdWUuZXJyb3I7XG4gICAgICAgICAgc2hvdWxkUnVuID0gIXJ1bm5pbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcS5wdXNoKHsgdmFsdWU6IG5vdGlmaWNhdGlvbi52YWx1ZSwgdGltZXN0YW1wOiBub3RpZmljYXRpb24udGltZXN0YW1wICsgZHVlVGltZSB9KTtcbiAgICAgICAgICBzaG91bGRSdW4gPSAhYWN0aXZlO1xuICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJ1bikge1xuICAgICAgICAgIGlmIChleGNlcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG8ub25FcnJvcihleGNlcHRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgICBjYW5jZWxhYmxlLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICAgICAgICBkLnNldERpc3Bvc2FibGUoc2NoZWR1bGVyLnNjaGVkdWxlUmVjdXJzaXZlRnV0dXJlKG51bGwsIGR1ZVRpbWUsIGZ1bmN0aW9uIChfLCBzZWxmKSB7XG4gICAgICAgICAgICAgIHZhciBlLCByZWN1cnNlRHVlVGltZSwgcmVzdWx0LCBzaG91bGRSZWN1cnNlO1xuICAgICAgICAgICAgICBpZiAoZXhjZXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocS5sZW5ndGggPiAwICYmIHFbMF0udGltZXN0YW1wIC0gc2NoZWR1bGVyLm5vdygpIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHEuc2hpZnQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmFjY2VwdChvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgIHNob3VsZFJlY3Vyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmVjdXJzZUR1ZVRpbWUgPSAwO1xuICAgICAgICAgICAgICBpZiAocS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVjdXJzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVjdXJzZUR1ZVRpbWUgPSBNYXRoLm1heCgwLCBxWzBdLnRpbWVzdGFtcCAtIHNjaGVkdWxlci5ub3coKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZSA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG8ub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRSZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZihudWxsLCByZWN1cnNlRHVlVGltZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSk7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGVEZWxheUFic29sdXRlKHNvdXJjZSwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVEZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZURlbGF5UmVsYXRpdmUoc291cmNlLCBkdWVUaW1lIC0gc2NoZWR1bGVyLm5vdygpLCBzY2hlZHVsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsYXlXaXRoU2VsZWN0b3Ioc291cmNlLCBzdWJzY3JpcHRpb25EZWxheSwgZGVsYXlEdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgdmFyIHN1YkRlbGF5LCBzZWxlY3RvcjtcbiAgICBpZiAoaXNGdW5jdGlvbihzdWJzY3JpcHRpb25EZWxheSkpIHtcbiAgICAgIHNlbGVjdG9yID0gc3Vic2NyaXB0aW9uRGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YkRlbGF5ID0gc3Vic2NyaXB0aW9uRGVsYXk7XG4gICAgICBzZWxlY3RvciA9IGRlbGF5RHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgZGVsYXlzID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKSwgYXRFbmQgPSBmYWxzZSwgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcblxuICAgICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRyeUNhdGNoKHNlbGVjdG9yKSh4KTtcbiAgICAgICAgICAgIGlmIChkZWxheSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIG8ub25FcnJvcihkZWxheS5lKTsgfVxuICAgICAgICAgICAgdmFyIGQgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKTtcbiAgICAgICAgICAgIGRlbGF5cy5hZGQoZCk7XG4gICAgICAgICAgICBkLnNldERpc3Bvc2FibGUoZGVsYXkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgby5vbk5leHQoeCk7XG4gICAgICAgICAgICAgICAgZGVsYXlzLnJlbW92ZShkKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG8ub25OZXh0KHgpO1xuICAgICAgICAgICAgICAgIGRlbGF5cy5yZW1vdmUoZCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhdEVuZCA9IHRydWU7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgICAgICBhdEVuZCAmJiBkZWxheXMubGVuZ3RoID09PSAwICYmIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdWJEZWxheSkge1xuICAgICAgICBzdGFydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUoc3ViRGVsYXkuc3Vic2NyaWJlKHN0YXJ0LCBmdW5jdGlvbiAoZSkgeyBvLm9uRXJyb3IoZSk7IH0sIHN0YXJ0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGRlbGF5cyk7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgVGltZSBzaGlmdHMgdGhlIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgZHVlVGltZS5cbiAgICogIFRoZSByZWxhdGl2ZSB0aW1lIGludGVydmFscyBiZXR3ZWVuIHRoZSB2YWx1ZXMgYXJlIHByZXNlcnZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgKHNwZWNpZmllZCBhcyBhIERhdGUgb2JqZWN0KSBvciByZWxhdGl2ZSB0aW1lIChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpIGJ5IHdoaWNoIHRvIHNoaWZ0IHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgZGVsYXkgdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRpbWUtc2hpZnRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kZWxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ251bWJlcicgfHwgZmlyc3RBcmcgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICB2YXIgZHVlVGltZSA9IGZpcnN0QXJnLCBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICAgIHJldHVybiBkdWVUaW1lIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgIG9ic2VydmFibGVEZWxheUFic29sdXRlKHRoaXMsIGR1ZVRpbWUsIHNjaGVkdWxlcikgOlxuICAgICAgICBvYnNlcnZhYmxlRGVsYXlSZWxhdGl2ZSh0aGlzLCBkdWVUaW1lLCBzY2hlZHVsZXIpO1xuICAgIH0gZWxzZSBpZiAoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUoZmlyc3RBcmcpIHx8IGlzRnVuY3Rpb24oZmlyc3RBcmcpKSB7XG4gICAgICByZXR1cm4gZGVsYXlXaXRoU2VsZWN0b3IodGhpcywgZmlyc3RBcmcsIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIERlYm91bmNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVib3VuY2VPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlT2JzZXJ2YWJsZShzb3VyY2UsIGR0LCBzKSB7XG4gICAgICBpc1NjaGVkdWxlcihzKSB8fCAocyA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kdCA9IGR0O1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBEZWJvdW5jZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGNhbmNlbGFibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlT2JzZXJ2ZXIobywgdGhpcy5fZHQsIHRoaXMuX3MsIGNhbmNlbGFibGUpKSxcbiAgICAgICAgY2FuY2VsYWJsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBEZWJvdW5jZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgRGVib3VuY2VPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoRGVib3VuY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZU9ic2VydmVyKG9ic2VydmVyLCBkdWVUaW1lLCBzY2hlZHVsZXIsIGNhbmNlbGFibGUpIHtcbiAgICAgIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuX2QgPSBkdWVUaW1lO1xuICAgICAgdGhpcy5fc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgdGhpcy5fYyA9IGNhbmNlbGFibGU7XG4gICAgICB0aGlzLl92ID0gbnVsbDtcbiAgICAgIHRoaXMuX2h2ID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZCA9IDA7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZ1dHVyZShzLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuc2VsZi5faHYgJiYgc3RhdGUuc2VsZi5faWQgPT09IHN0YXRlLmN1cnJlbnRJZCAmJiBzdGF0ZS5zZWxmLl9vLm9uTmV4dChzdGF0ZS54KTtcbiAgICAgIHN0YXRlLnNlbGYuX2h2ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgRGVib3VuY2VPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl9odiA9IHRydWU7XG4gICAgICB0aGlzLl92ID0geDtcbiAgICAgIHZhciBjdXJyZW50SWQgPSArK3RoaXMuX2lkLCBkID0gbmV3IFNpbmdsZUFzc2lnbm1lbnREaXNwb3NhYmxlKCk7XG4gICAgICB0aGlzLl9jLnNldERpc3Bvc2FibGUoZCk7XG4gICAgICBkLnNldERpc3Bvc2FibGUodGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlRnV0dXJlKHRoaXMsIHRoaXMuX2QsIGZ1bmN0aW9uIChfLCBzZWxmKSB7XG4gICAgICAgIHNlbGYuX2h2ICYmIHNlbGYuX2lkID09PSBjdXJyZW50SWQgJiYgc2VsZi5fby5vbk5leHQoeCk7XG4gICAgICAgIHNlbGYuX2h2ID0gZmFsc2U7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIERlYm91bmNlT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2MuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fby5vbkVycm9yKGUpO1xuICAgICAgdGhpcy5faHYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lkKys7XG4gICAgfTtcblxuICAgIERlYm91bmNlT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2MuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5faHYgJiYgdGhpcy5fby5vbk5leHQodGhpcy5fdik7XG4gICAgICB0aGlzLl9vLm9uQ29tcGxldGVkKCk7XG4gICAgICB0aGlzLl9odiA9IGZhbHNlO1xuICAgICAgdGhpcy5faWQrKztcbiAgICB9O1xuXG4gICAgcmV0dXJuIERlYm91bmNlT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIGZ1bmN0aW9uIGRlYm91bmNlV2l0aFNlbGVjdG9yKHNvdXJjZSwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHZhbHVlLCBoYXNWYWx1ZSA9IGZhbHNlLCBjYW5jZWxhYmxlID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSwgaWQgPSAwO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIHRocm90dGxlID0gdHJ5Q2F0Y2goZHVyYXRpb25TZWxlY3RvcikoeCk7XG4gICAgICAgICAgaWYgKHRocm90dGxlID09PSBlcnJvck9iaikgeyByZXR1cm4gby5vbkVycm9yKHRocm90dGxlLmUpOyB9XG5cbiAgICAgICAgICBpc1Byb21pc2UodGhyb3R0bGUpICYmICh0aHJvdHRsZSA9IG9ic2VydmFibGVGcm9tUHJvbWlzZSh0aHJvdHRsZSkpO1xuXG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlID0geDtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICAgIHZhciBjdXJyZW50aWQgPSBpZCwgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICAgIGNhbmNlbGFibGUuc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgICAgICBkLnNldERpc3Bvc2FibGUodGhyb3R0bGUuc3Vic2NyaWJlKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBoYXNWYWx1ZSAmJiBpZCA9PT0gY3VycmVudGlkICYmIG8ub25OZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHsgby5vbkVycm9yKGUpOyB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBoYXNWYWx1ZSAmJiBpZCA9PT0gY3VycmVudGlkICYmIG8ub25OZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY2FuY2VsYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgaWQrKztcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbmNlbGFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgIGhhc1ZhbHVlICYmIG8ub25OZXh0KHZhbHVlKTtcbiAgICAgICAgICBvLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgY2FuY2VsYWJsZSk7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIG9ic2VydmFibGVQcm90by5kZWJvdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNGdW5jdGlvbiAoYXJndW1lbnRzWzBdKSkge1xuICAgICAgcmV0dXJuIGRlYm91bmNlV2l0aFNlbGVjdG9yKHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG5ldyBEZWJvdW5jZU9ic2VydmFibGUodGhpcywgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAgUHJvamVjdHMgZWFjaCBlbGVtZW50IG9mIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgaW50byB6ZXJvIG9yIG1vcmUgd2luZG93cyB3aGljaCBhcmUgcHJvZHVjZWQgYmFzZWQgb24gdGltaW5nIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVNwYW4gTGVuZ3RoIG9mIGVhY2ggd2luZG93IChzcGVjaWZpZWQgYXMgYW4gaW50ZWdlciBkZW5vdGluZyBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGltZVNoaWZ0T3JTY2hlZHVsZXJdICBJbnRlcnZhbCBiZXR3ZWVuIGNyZWF0aW9uIG9mIGNvbnNlY3V0aXZlIHdpbmRvd3MgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcyksIG9yIGFuIG9wdGlvbmFsIHNjaGVkdWxlciBwYXJhbWV0ZXIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lIHNoaWZ0IGNvcnJlc3BvbmRzIHRvIHRoZSB0aW1lU3BhbiBwYXJhbWV0ZXIsIHJlc3VsdGluZyBpbiBub24tb3ZlcmxhcHBpbmcgYWRqYWNlbnQgd2luZG93cy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdICBTY2hlZHVsZXIgdG8gcnVuIHdpbmRvd2luZyB0aW1lcnMgb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBvZiB3aW5kb3dzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLndpbmRvd1dpdGhUaW1lID0gb2JzZXJ2YWJsZVByb3RvLndpbmRvd1RpbWUgPSBmdW5jdGlvbiAodGltZVNwYW4sIHRpbWVTaGlmdE9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcywgdGltZVNoaWZ0O1xuICAgIHRpbWVTaGlmdE9yU2NoZWR1bGVyID09IG51bGwgJiYgKHRpbWVTaGlmdCA9IHRpbWVTcGFuKTtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICBpZiAodHlwZW9mIHRpbWVTaGlmdE9yU2NoZWR1bGVyID09PSAnbnVtYmVyJykge1xuICAgICAgdGltZVNoaWZ0ID0gdGltZVNoaWZ0T3JTY2hlZHVsZXI7XG4gICAgfSBlbHNlIGlmIChpc1NjaGVkdWxlcih0aW1lU2hpZnRPclNjaGVkdWxlcikpIHtcbiAgICAgIHRpbWVTaGlmdCA9IHRpbWVTcGFuO1xuICAgICAgc2NoZWR1bGVyID0gdGltZVNoaWZ0T3JTY2hlZHVsZXI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBncm91cERpc3Bvc2FibGUsXG4gICAgICAgIG5leHRTaGlmdCA9IHRpbWVTaGlmdCxcbiAgICAgICAgbmV4dFNwYW4gPSB0aW1lU3BhbixcbiAgICAgICAgcSA9IFtdLFxuICAgICAgICByZWZDb3VudERpc3Bvc2FibGUsXG4gICAgICAgIHRpbWVyRCA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgIHRvdGFsVGltZSA9IDA7XG4gICAgICAgIGdyb3VwRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKHRpbWVyRCksXG4gICAgICAgIHJlZkNvdW50RGlzcG9zYWJsZSA9IG5ldyBSZWZDb3VudERpc3Bvc2FibGUoZ3JvdXBEaXNwb3NhYmxlKTtcblxuICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRpbWVyICgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgICBpc1NwYW4gPSBmYWxzZSxcbiAgICAgICAgICBpc1NoaWZ0ID0gZmFsc2U7XG4gICAgICAgIHRpbWVyRC5zZXREaXNwb3NhYmxlKG0pO1xuICAgICAgICBpZiAobmV4dFNwYW4gPT09IG5leHRTaGlmdCkge1xuICAgICAgICAgIGlzU3BhbiA9IHRydWU7XG4gICAgICAgICAgaXNTaGlmdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFNwYW4gPCBuZXh0U2hpZnQpIHtcbiAgICAgICAgICAgIGlzU3BhbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNTaGlmdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RvdGFsVGltZSA9IGlzU3BhbiA/IG5leHRTcGFuIDogbmV4dFNoaWZ0LFxuICAgICAgICAgIHRzID0gbmV3VG90YWxUaW1lIC0gdG90YWxUaW1lO1xuICAgICAgICB0b3RhbFRpbWUgPSBuZXdUb3RhbFRpbWU7XG4gICAgICAgIGlmIChpc1NwYW4pIHtcbiAgICAgICAgICBuZXh0U3BhbiArPSB0aW1lU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hpZnQpIHtcbiAgICAgICAgICBuZXh0U2hpZnQgKz0gdGltZVNoaWZ0O1xuICAgICAgICB9XG4gICAgICAgIG0uc2V0RGlzcG9zYWJsZShzY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUobnVsbCwgdHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNTaGlmdCkge1xuICAgICAgICAgICAgdmFyIHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgcS5wdXNoKHMpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihzLCByZWZDb3VudERpc3Bvc2FibGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTcGFuICYmIHEuc2hpZnQoKS5vbkNvbXBsZXRlZCgpO1xuICAgICAgICAgIGNyZWF0ZVRpbWVyKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICBxLnB1c2gobmV3IFN1YmplY3QoKSk7XG4gICAgICBvYnNlcnZlci5vbk5leHQoYWRkUmVmKHFbMF0sIHJlZkNvdW50RGlzcG9zYWJsZSkpO1xuICAgICAgY3JlYXRlVGltZXIoKTtcbiAgICAgIGdyb3VwRGlzcG9zYWJsZS5hZGQoc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uTmV4dCh4KTsgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IHFbaV0ub25FcnJvcihlKTsgfVxuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcS5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyBxW2ldLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICAgIHJldHVybiByZWZDb3VudERpc3Bvc2FibGU7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gYSB3aW5kb3cgdGhhdCBpcyBjb21wbGV0ZWQgd2hlbiBlaXRoZXIgaXQncyBmdWxsIG9yIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUgaGFzIGVsYXBzZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBNYXhpbXVtIHRpbWUgbGVuZ3RoIG9mIGEgd2luZG93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIGEgd2luZG93LlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gd2luZG93aW5nIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIHdpbmRvd3MuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8ud2luZG93V2l0aFRpbWVPckNvdW50ID0gb2JzZXJ2YWJsZVByb3RvLndpbmRvd1RpbWVPckNvdW50ID0gZnVuY3Rpb24gKHRpbWVTcGFuLCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHRpbWVyRCA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCksXG4gICAgICAgICAgZ3JvdXBEaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUodGltZXJEKSxcbiAgICAgICAgICByZWZDb3VudERpc3Bvc2FibGUgPSBuZXcgUmVmQ291bnREaXNwb3NhYmxlKGdyb3VwRGlzcG9zYWJsZSksXG4gICAgICAgICAgbiA9IDAsXG4gICAgICAgICAgd2luZG93SWQgPSAwLFxuICAgICAgICAgIHMgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVUaW1lcihpZCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aW1lckQuc2V0RGlzcG9zYWJsZShtKTtcbiAgICAgICAgbS5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShudWxsLCB0aW1lU3BhbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpZCAhPT0gd2luZG93SWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgdmFyIG5ld0lkID0gKyt3aW5kb3dJZDtcbiAgICAgICAgICBzLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihzLCByZWZDb3VudERpc3Bvc2FibGUpKTtcbiAgICAgICAgICBjcmVhdGVUaW1lcihuZXdJZCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihzLCByZWZDb3VudERpc3Bvc2FibGUpKTtcbiAgICAgIGNyZWF0ZVRpbWVyKDApO1xuXG4gICAgICBncm91cERpc3Bvc2FibGUuYWRkKHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIG5ld0lkID0gMCwgbmV3V2luZG93ID0gZmFsc2U7XG4gICAgICAgICAgcy5vbk5leHQoeCk7XG4gICAgICAgICAgaWYgKCsrbiA9PT0gY291bnQpIHtcbiAgICAgICAgICAgIG5ld1dpbmRvdyA9IHRydWU7XG4gICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgIG5ld0lkID0gKyt3aW5kb3dJZDtcbiAgICAgICAgICAgIHMub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIub25OZXh0KGFkZFJlZihzLCByZWZDb3VudERpc3Bvc2FibGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3V2luZG93ICYmIGNyZWF0ZVRpbWVyKG5ld0lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBzLm9uRXJyb3IoZSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcihlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHMub25Db21wbGV0ZWQoKTtcbiAgICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICAgIHJldHVybiByZWZDb3VudERpc3Bvc2FibGU7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0FycmF5KHgpIHsgcmV0dXJuIHgudG9BcnJheSgpOyB9XG5cbiAgLyoqXG4gICAqICBQcm9qZWN0cyBlYWNoIGVsZW1lbnQgb2YgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBpbnRvIHplcm8gb3IgbW9yZSBidWZmZXJzIHdoaWNoIGFyZSBwcm9kdWNlZCBiYXNlZCBvbiB0aW1pbmcgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBMZW5ndGggb2YgZWFjaCBidWZmZXIgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aW1lU2hpZnRPclNjaGVkdWxlcl0gIEludGVydmFsIGJldHdlZW4gY3JlYXRpb24gb2YgY29uc2VjdXRpdmUgYnVmZmVycyAoc3BlY2lmaWVkIGFzIGFuIGludGVnZXIgZGVub3RpbmcgbWlsbGlzZWNvbmRzKSwgb3IgYW4gb3B0aW9uYWwgc2NoZWR1bGVyIHBhcmFtZXRlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWUgc2hpZnQgY29ycmVzcG9uZHMgdG8gdGhlIHRpbWVTcGFuIHBhcmFtZXRlciwgcmVzdWx0aW5nIGluIG5vbi1vdmVybGFwcGluZyBhZGphY2VudCBidWZmZXJzLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gYnVmZmVyIHRpbWVycyBvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHRpbWVvdXQgc2NoZWR1bGVyIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIGJ1ZmZlcnMuXG4gICAqL1xuICBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyV2l0aFRpbWUgPSBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyVGltZSA9IGZ1bmN0aW9uICh0aW1lU3BhbiwgdGltZVNoaWZ0T3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiB0aGlzLndpbmRvd1dpdGhUaW1lKHRpbWVTcGFuLCB0aW1lU2hpZnRPclNjaGVkdWxlciwgc2NoZWR1bGVyKS5mbGF0TWFwKHRvQXJyYXkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoeCkgeyByZXR1cm4geC50b0FycmF5KCk7IH1cblxuICAvKipcbiAgICogIFByb2plY3RzIGVhY2ggZWxlbWVudCBvZiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGludG8gYSBidWZmZXIgdGhhdCBpcyBjb21wbGV0ZWQgd2hlbiBlaXRoZXIgaXQncyBmdWxsIG9yIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUgaGFzIGVsYXBzZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBNYXhpbXVtIHRpbWUgbGVuZ3RoIG9mIGEgYnVmZmVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTWF4aW11bSBlbGVtZW50IGNvdW50IG9mIGEgYnVmZmVyLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gYnVmZmVyaW4gdGltZXJzIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgYnVmZmVycy5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5idWZmZXJXaXRoVGltZU9yQ291bnQgPSBvYnNlcnZhYmxlUHJvdG8uYnVmZmVyVGltZU9yQ291bnQgPSBmdW5jdGlvbiAodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gdGhpcy53aW5kb3dXaXRoVGltZU9yQ291bnQodGltZVNwYW4sIGNvdW50LCBzY2hlZHVsZXIpLmZsYXRNYXAodG9BcnJheSk7XG4gIH07XG5cbiAgdmFyIFRpbWVJbnRlcnZhbE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRpbWVJbnRlcnZhbE9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGltZUludGVydmFsT2JzZXJ2YWJsZShzb3VyY2UsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUaW1lSW50ZXJ2YWxPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVJbnRlcnZhbE9ic2VydmVyKG8sIHRoaXMuX3MpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRpbWVJbnRlcnZhbE9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgVGltZUludGVydmFsT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRpbWVJbnRlcnZhbE9ic2VydmVyLCBfX3N1cGVyX18pO1xuXG4gICAgZnVuY3Rpb24gVGltZUludGVydmFsT2JzZXJ2ZXIobywgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIHRoaXMuX2wgPSBzLm5vdygpO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgVGltZUludGVydmFsT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIG5vdyA9IHRoaXMuX3Mubm93KCksIHNwYW4gPSBub3cgLSB0aGlzLl9sO1xuICAgICAgdGhpcy5fbCA9IG5vdztcbiAgICAgIHRoaXMuX28ub25OZXh0KHsgdmFsdWU6IHgsIGludGVydmFsOiBzcGFuIH0pO1xuICAgIH07XG4gICAgVGltZUludGVydmFsT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFRpbWVJbnRlcnZhbE9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX28ub25Db21wbGV0ZWQoKTsgfTtcblxuICAgIHJldHVybiBUaW1lSW50ZXJ2YWxPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZWNvcmRzIHRoZSB0aW1lIGludGVydmFsIGJldHdlZW4gY29uc2VjdXRpdmUgdmFsdWVzIGluIGFuIG9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLnRpbWVJbnRlcnZhbCgpO1xuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS50aW1lSW50ZXJ2YWwoUnguU2NoZWR1bGVyLnRpbWVvdXQpO1xuICAgKlxuICAgKiBAcGFyYW0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB1c2VkIHRvIGNvbXB1dGUgdGltZSBpbnRlcnZhbHMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRpbWUgaW50ZXJ2YWwgaW5mb3JtYXRpb24gb24gdmFsdWVzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRpbWVJbnRlcnZhbCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFRpbWVJbnRlcnZhbE9ic2VydmFibGUodGhpcywgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgVGltZXN0YW1wT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZXN0YW1wT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBPYnNlcnZhYmxlKHNvdXJjZSwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRpbWVzdGFtcE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgVGltZXN0YW1wT2JzZXJ2ZXIobywgdGhpcy5fcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGltZXN0YW1wT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUaW1lc3RhbXBPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGltZXN0YW1wT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gVGltZXN0YW1wT2JzZXJ2ZXIobywgcykge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRpbWVzdGFtcE9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX28ub25OZXh0KHsgdmFsdWU6IHgsIHRpbWVzdGFtcDogdGhpcy5fcy5ub3coKSB9KTtcbiAgICB9O1xuXG4gICAgVGltZXN0YW1wT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX28ub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgVGltZXN0YW1wT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRpbWVzdGFtcE9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFJlY29yZHMgdGhlIHRpbWVzdGFtcCBmb3IgZWFjaCB2YWx1ZSBpbiBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS50aW1lc3RhbXAoKTsgLy8gcHJvZHVjZXMgeyB2YWx1ZTogeCwgdGltZXN0YW1wOiB0cyB9XG4gICAqICAyIC0gcmVzID0gc291cmNlLnRpbWVzdGFtcChSeC5TY2hlZHVsZXIuZGVmYXVsdCk7XG4gICAqXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHVzZWQgdG8gY29tcHV0ZSB0aW1lc3RhbXBzLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2Ugd2l0aCB0aW1lc3RhbXAgaW5mb3JtYXRpb24gb24gdmFsdWVzLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRpbWVzdGFtcCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcE9ic2VydmFibGUodGhpcywgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU2FtcGxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTYW1wbGVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNhbXBsZU9ic2VydmFibGUoc291cmNlLCBzYW1wbGVyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX3NhbXBsZXIgPSBzYW1wbGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2FtcGxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIG86IG8sXG4gICAgICAgIGF0RW5kOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIGhhc1ZhbHVlOiBmYWxzZSxcbiAgICAgICAgc291cmNlU3Vic2NyaXB0aW9uOiBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKVxuICAgICAgfTtcblxuICAgICAgc3RhdGUuc291cmNlU3Vic2NyaXB0aW9uLnNldERpc3Bvc2FibGUodGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG5ldyBTYW1wbGVTb3VyY2VPYnNlcnZlcihzdGF0ZSkpKTtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgc3RhdGUuc291cmNlU3Vic2NyaXB0aW9uLFxuICAgICAgICB0aGlzLl9zYW1wbGVyLnN1YnNjcmliZShuZXcgU2FtcGxlck9ic2VydmVyKHN0YXRlKSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBTYW1wbGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgdmFyIFNhbXBsZXJPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTYW1wbGVyT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2FtcGxlck9ic2VydmVyKHMpIHtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2FtcGxlck9ic2VydmVyLnByb3RvdHlwZS5faGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9zLmhhc1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3MuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcy5vLm9uTmV4dCh0aGlzLl9zLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3MuYXRFbmQgJiYgdGhpcy5fcy5vLm9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIFNhbXBsZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGFuZGxlTWVzc2FnZSgpOyB9O1xuICAgIFNhbXBsZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm9uRXJyb3IoZSk7IH07XG4gICAgU2FtcGxlck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hhbmRsZU1lc3NhZ2UoKTsgfTtcblxuICAgIHJldHVybiBTYW1wbGVyT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIHZhciBTYW1wbGVTb3VyY2VPYnNlcnZlciA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTYW1wbGVTb3VyY2VPYnNlcnZlciwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTYW1wbGVTb3VyY2VPYnNlcnZlcihzKSB7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNhbXBsZVNvdXJjZU9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3MuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgdGhpcy5fcy52YWx1ZSA9IHg7XG4gICAgfTtcbiAgICBTYW1wbGVTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9zLm8ub25FcnJvcihlKTsgfTtcbiAgICBTYW1wbGVTb3VyY2VPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcy5hdEVuZCA9IHRydWU7XG4gICAgICB0aGlzLl9zLnNvdXJjZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTYW1wbGVTb3VyY2VPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBTYW1wbGVzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGF0IGVhY2ggaW50ZXJ2YWwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLnNhbXBsZShzYW1wbGVPYnNlcnZhYmxlKTsgLy8gU2FtcGxlciB0aWNrIHNlcXVlbmNlXG4gICAqICAyIC0gcmVzID0gc291cmNlLnNhbXBsZSg1MDAwKTsgLy8gNSBzZWNvbmRzXG4gICAqICAyIC0gcmVzID0gc291cmNlLnNhbXBsZSg1MDAwLCBSeC5TY2hlZHVsZXIudGltZW91dCk7IC8vIDUgc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBpbnRlcnZhbE9yU2FtcGxlciBJbnRlcnZhbCBhdCB3aGljaCB0byBzYW1wbGUgKHNwZWNpZmllZCBhcyBhbiBpbnRlZ2VyIGRlbm90aW5nIG1pbGxpc2Vjb25kcykgb3IgU2FtcGxlciBPYnNlcnZhYmxlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHNhbXBsaW5nIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFNhbXBsZWQgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5zYW1wbGUgPSBmdW5jdGlvbiAoaW50ZXJ2YWxPclNhbXBsZXIsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiB0eXBlb2YgaW50ZXJ2YWxPclNhbXBsZXIgPT09ICdudW1iZXInID9cbiAgICAgIG5ldyBTYW1wbGVPYnNlcnZhYmxlKHRoaXMsIG9ic2VydmFibGVpbnRlcnZhbChpbnRlcnZhbE9yU2FtcGxlciwgc2NoZWR1bGVyKSkgOlxuICAgICAgbmV3IFNhbXBsZU9ic2VydmFibGUodGhpcywgaW50ZXJ2YWxPclNhbXBsZXIpO1xuICB9O1xuXG4gIHZhciBUaW1lb3V0RXJyb3IgPSBSeC5UaW1lb3V0RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGltZW91dCBoYXMgb2NjdXJyZWQnO1xuICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gIH07XG4gIFRpbWVvdXRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gdGltZW91dFdpdGhTZWxlY3Rvcihzb3VyY2UsIGZpcnN0VGltZW91dCwgdGltZW91dER1cmF0aW9uU2VsZWN0b3IsIG90aGVyKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZmlyc3RUaW1lb3V0KSkge1xuICAgICAgb3RoZXIgPSB0aW1lb3V0RHVyYXRpb25TZWxlY3RvcjtcbiAgICAgIHRpbWVvdXREdXJhdGlvblNlbGVjdG9yID0gZmlyc3RUaW1lb3V0O1xuICAgICAgZmlyc3RUaW1lb3V0ID0gb2JzZXJ2YWJsZU5ldmVyKCk7XG4gICAgfVxuICAgIE9ic2VydmFibGUuaXNPYnNlcnZhYmxlKG90aGVyKSB8fCAob3RoZXIgPSBvYnNlcnZhYmxlVGhyb3cobmV3IFRpbWVvdXRFcnJvcigpKSk7XG4gICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNPYnNlcnZhYmxlKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgdGltZXIgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpLFxuICAgICAgICBvcmlnaW5hbCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuXG4gICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShvcmlnaW5hbCk7XG5cbiAgICAgIHZhciBpZCA9IDAsIHN3aXRjaGVkID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIHNldFRpbWVyKHRpbWVvdXQpIHtcbiAgICAgICAgdmFyIG15SWQgPSBpZCwgZCA9IG5ldyBTaW5nbGVBc3NpZ25tZW50RGlzcG9zYWJsZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVyV2lucygpIHtcbiAgICAgICAgICBzd2l0Y2hlZCA9IChteUlkID09PSBpZCk7XG4gICAgICAgICAgcmV0dXJuIHN3aXRjaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZXIuc2V0RGlzcG9zYWJsZShkKTtcbiAgICAgICAgZC5zZXREaXNwb3NhYmxlKHRpbWVvdXQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aW1lcldpbnMoKSAmJiBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShvdGhlci5zdWJzY3JpYmUobykpO1xuICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRpbWVyV2lucygpICYmIG8ub25FcnJvcihlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVyV2lucygpICYmIHN1YnNjcmlwdGlvbi5zZXREaXNwb3NhYmxlKG90aGVyLnN1YnNjcmliZShvKSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG5cbiAgICAgIHNldFRpbWVyKGZpcnN0VGltZW91dCk7XG5cbiAgICAgIGZ1bmN0aW9uIG9XaW5zKCkge1xuICAgICAgICB2YXIgcmVzID0gIXN3aXRjaGVkO1xuICAgICAgICBpZiAocmVzKSB7IGlkKys7IH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgb3JpZ2luYWwuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChvV2lucygpKSB7XG4gICAgICAgICAgby5vbk5leHQoeCk7XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSB0cnlDYXRjaCh0aW1lb3V0RHVyYXRpb25TZWxlY3RvcikoeCk7XG4gICAgICAgICAgaWYgKHRpbWVvdXQgPT09IGVycm9yT2JqKSB7IHJldHVybiBvLm9uRXJyb3IodGltZW91dC5lKTsgfVxuICAgICAgICAgIHNldFRpbWVyKGlzUHJvbWlzZSh0aW1lb3V0KSA/IG9ic2VydmFibGVGcm9tUHJvbWlzZSh0aW1lb3V0KSA6IHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBvV2lucygpICYmIG8ub25FcnJvcihlKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1dpbnMoKSAmJiBvLm9uQ29tcGxldGVkKCk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gbmV3IEJpbmFyeURpc3Bvc2FibGUoc3Vic2NyaXB0aW9uLCB0aW1lcik7XG4gICAgfSwgc291cmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVvdXQoc291cmNlLCBkdWVUaW1lLCBvdGhlciwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGlzU2NoZWR1bGVyKG90aGVyKSkge1xuICAgICAgc2NoZWR1bGVyID0gb3RoZXI7XG4gICAgICBvdGhlciA9IG9ic2VydmFibGVUaHJvdyhuZXcgVGltZW91dEVycm9yKCkpO1xuICAgIH1cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBFcnJvcikgeyBvdGhlciA9IG9ic2VydmFibGVUaHJvdyhvdGhlcik7IH1cbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICBPYnNlcnZhYmxlLmlzT2JzZXJ2YWJsZShvdGhlcikgfHwgKG90aGVyID0gb2JzZXJ2YWJsZVRocm93KG5ldyBUaW1lb3V0RXJyb3IoKSkpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGlkID0gMCxcbiAgICAgICAgb3JpZ2luYWwgPSBuZXcgU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUoKSxcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKSxcbiAgICAgICAgc3dpdGNoZWQgPSBmYWxzZSxcbiAgICAgICAgdGltZXIgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuXG4gICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShvcmlnaW5hbCk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRpbWVyKCkge1xuICAgICAgICB2YXIgbXlJZCA9IGlkO1xuICAgICAgICB0aW1lci5zZXREaXNwb3NhYmxlKHNjaGVkdWxlci5zY2hlZHVsZUZ1dHVyZShudWxsLCBkdWVUaW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3dpdGNoZWQgPSBpZCA9PT0gbXlJZDtcbiAgICAgICAgICBpZiAoc3dpdGNoZWQpIHtcbiAgICAgICAgICAgIGlzUHJvbWlzZShvdGhlcikgJiYgKG90aGVyID0gb2JzZXJ2YWJsZUZyb21Qcm9taXNlKG90aGVyKSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uc2V0RGlzcG9zYWJsZShvdGhlci5zdWJzY3JpYmUobykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVUaW1lcigpO1xuXG4gICAgICBvcmlnaW5hbC5zZXREaXNwb3NhYmxlKHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlZCkge1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgby5vbk5leHQoeCk7XG4gICAgICAgICAgY3JlYXRlVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlZCkge1xuICAgICAgICAgIGlkKys7XG4gICAgICAgICAgby5vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc3dpdGNoZWQpIHtcbiAgICAgICAgICBpZCsrO1xuICAgICAgICAgIG8ub25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKHN1YnNjcmlwdGlvbiwgdGltZXIpO1xuICAgIH0sIHNvdXJjZSk7XG4gIH1cblxuICBvYnNlcnZhYmxlUHJvdG8udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3RBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGZpcnN0QXJnIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgZmlyc3RBcmcgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGltZW91dCh0aGlzLCBmaXJzdEFyZywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgIH0gZWxzZSBpZiAoT2JzZXJ2YWJsZS5pc09ic2VydmFibGUoZmlyc3RBcmcpIHx8IGlzRnVuY3Rpb24oZmlyc3RBcmcpKSB7XG4gICAgICByZXR1cm4gdGltZW91dFdpdGhTZWxlY3Rvcih0aGlzLCBmaXJzdEFyZywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGUoc3RhdGUsIGNuZEZuLCBpdHJGbiwgcmVzRm4sIHRpbWVGbiwgcykge1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX2NuZEZuID0gY25kRm47XG4gICAgICB0aGlzLl9pdHJGbiA9IGl0ckZuO1xuICAgICAgdGhpcy5fcmVzRm4gPSByZXNGbjtcbiAgICAgIHRoaXMuX3RpbWVGbiA9IHRpbWVGbjtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWN1cnNpdmUoc3RhdGUsIHJlY3Vyc2UpIHtcbiAgICAgIHN0YXRlLmhhc1Jlc3VsdCAmJiBzdGF0ZS5vLm9uTmV4dChzdGF0ZS5yZXN1bHQpO1xuXG4gICAgICBpZiAoc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgc3RhdGUuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm5ld1N0YXRlID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5faXRyRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLm5ld1N0YXRlID09PSBlcnJvck9iaikgeyByZXR1cm4gc3RhdGUuby5vbkVycm9yKHN0YXRlLm5ld1N0YXRlLmUpOyB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5oYXNSZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9jbmRGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmhhc1Jlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5oYXNSZXN1bHQuZSk7IH1cbiAgICAgIGlmIChzdGF0ZS5oYXNSZXN1bHQpIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fcmVzRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLnJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5yZXN1bHQuZSk7IH1cbiAgICAgICAgdmFyIHRpbWUgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl90aW1lRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHRpbWUgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IodGltZS5lKTsgfVxuICAgICAgICByZWN1cnNlKHN0YXRlLCB0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIG86IG8sXG4gICAgICAgIHNlbGY6IHRoaXMsXG4gICAgICAgIG5ld1N0YXRlOiB0aGlzLl9zdGF0ZSxcbiAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgIGhhc1Jlc3VsdDogZmFsc2VcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fcy5zY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZShzdGF0ZSwgbmV3IERhdGUodGhpcy5fcy5ub3coKSksIHNjaGVkdWxlUmVjdXJzaXZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdlbmVyYXRlQWJzb2x1dGVPYnNlcnZhYmxlO1xuICB9KE9ic2VydmFibGVCYXNlKSk7XG5cbiAgLyoqXG4gICAqICBHZW5lcmF0ZUFic29sdXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGl0ZXJhdGluZyBhIHN0YXRlIGZyb20gYW4gaW5pdGlhbCBzdGF0ZSB1bnRpbCB0aGUgY29uZGl0aW9uIGZhaWxzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgcmVzID0gc291cmNlLmdlbmVyYXRlV2l0aEFic29sdXRlVGltZSgwLFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiByZXR1cm4gdHJ1ZTsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIG5ldyBEYXRlKCk7IH1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBpbml0aWFsU3RhdGUgSW5pdGlhbCBzdGF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIENvbmRpdGlvbiB0byB0ZXJtaW5hdGUgZ2VuZXJhdGlvbiAodXBvbiByZXR1cm5pbmcgZmFsc2UpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXN1bHRTZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiBmb3IgcmVzdWx0cyBwcm9kdWNlZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVTZWxlY3RvciBUaW1lIHNlbGVjdG9yIGZ1bmN0aW9uIHRvIGNvbnRyb2wgdGhlIHNwZWVkIG9mIHZhbHVlcyBiZWluZyBwcm9kdWNlZCBlYWNoIGl0ZXJhdGlvbiwgcmV0dXJuaW5nIERhdGUgdmFsdWVzLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciBvbiB3aGljaCB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBPYnNlcnZhYmxlLmdlbmVyYXRlV2l0aEFic29sdXRlVGltZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHRpbWVTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmF0ZUFic29sdXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHRpbWVTZWxlY3Rvciwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlKHN0YXRlLCBjbmRGbiwgaXRyRm4sIHJlc0ZuLCB0aW1lRm4sIHMpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9jbmRGbiA9IGNuZEZuO1xuICAgICAgdGhpcy5faXRyRm4gPSBpdHJGbjtcbiAgICAgIHRoaXMuX3Jlc0ZuID0gcmVzRm47XG4gICAgICB0aGlzLl90aW1lRm4gPSB0aW1lRm47XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVjdXJzaXZlKHN0YXRlLCByZWN1cnNlKSB7XG4gICAgICBzdGF0ZS5oYXNSZXN1bHQgJiYgc3RhdGUuby5vbk5leHQoc3RhdGUucmVzdWx0KTtcblxuICAgICAgaWYgKHN0YXRlLmZpcnN0KSB7XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5uZXdTdGF0ZSA9IHRyeUNhdGNoKHN0YXRlLnNlbGYuX2l0ckZuKShzdGF0ZS5uZXdTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5uZXdTdGF0ZSA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5uZXdTdGF0ZS5lKTsgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5oYXNSZXN1bHQgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl9jbmRGbikoc3RhdGUubmV3U3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmhhc1Jlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5oYXNSZXN1bHQuZSk7IH1cbiAgICAgIGlmIChzdGF0ZS5oYXNSZXN1bHQpIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHJ5Q2F0Y2goc3RhdGUuc2VsZi5fcmVzRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLnJlc3VsdCA9PT0gZXJyb3JPYmopIHsgcmV0dXJuIHN0YXRlLm8ub25FcnJvcihzdGF0ZS5yZXN1bHQuZSk7IH1cbiAgICAgICAgdmFyIHRpbWUgPSB0cnlDYXRjaChzdGF0ZS5zZWxmLl90aW1lRm4pKHN0YXRlLm5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHRpbWUgPT09IGVycm9yT2JqKSB7IHJldHVybiBzdGF0ZS5vLm9uRXJyb3IodGltZS5lKTsgfVxuICAgICAgICByZWN1cnNlKHN0YXRlLCB0aW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm8ub25Db21wbGV0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlQ29yZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIG86IG8sXG4gICAgICAgIHNlbGY6IHRoaXMsXG4gICAgICAgIG5ld1N0YXRlOiB0aGlzLl9zdGF0ZSxcbiAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgIGhhc1Jlc3VsdDogZmFsc2VcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fcy5zY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZShzdGF0ZSwgMCwgc2NoZWR1bGVSZWN1cnNpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gR2VuZXJhdGVSZWxhdGl2ZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIEdlbmVyYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGl0ZXJhdGluZyBhIHN0YXRlIGZyb20gYW4gaW5pdGlhbCBzdGF0ZSB1bnRpbCB0aGUgY29uZGl0aW9uIGZhaWxzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgcmVzID0gc291cmNlLmdlbmVyYXRlV2l0aFJlbGF0aXZlVGltZSgwLFxuICAgKiAgICAgIGZ1bmN0aW9uICh4KSB7IHJldHVybiByZXR1cm4gdHJ1ZTsgfSxcbiAgICogICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAqICAgICAgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIDUwMDsgfVxuICAgKiAgKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFN0YXRlIEluaXRpYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZSBJdGVyYXRpb24gc3RlcCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzdWx0U2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gZm9yIHJlc3VsdHMgcHJvZHVjZWQgaW4gdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0aW1lU2VsZWN0b3IgVGltZSBzZWxlY3RvciBmdW5jdGlvbiB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB2YWx1ZXMgYmVpbmcgcHJvZHVjZWQgZWFjaCBpdGVyYXRpb24sIHJldHVybmluZyBpbnRlZ2VyIHZhbHVlcyBkZW5vdGluZyBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHJ1biB0aGUgZ2VuZXJhdG9yIGxvb3AuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aW1lb3V0IHNjaGVkdWxlciBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gVGhlIGdlbmVyYXRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIE9ic2VydmFibGUuZ2VuZXJhdGVXaXRoUmVsYXRpdmVUaW1lID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciwgdGltZVNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IEdlbmVyYXRlUmVsYXRpdmVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZSwgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciwgdGltZVNlbGVjdG9yLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBEZWxheVN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbihfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhEZWxheVN1YnNjcmlwdGlvbiwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBEZWxheVN1YnNjcmlwdGlvbihzb3VyY2UsIGR0LCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2R0ID0gZHQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIERlbGF5U3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBkID0gbmV3IFNlcmlhbERpc3Bvc2FibGUoKTtcblxuICAgICAgZC5zZXREaXNwb3NhYmxlKHRoaXMuX3Muc2NoZWR1bGVGdXR1cmUoW3RoaXMuc291cmNlLCBvLCBkXSwgdGhpcy5fZHQsIHNjaGVkdWxlTWV0aG9kKSk7XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBzdGF0ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlWzBdLCBvID0gc3RhdGVbMV0sIGQgPSBzdGF0ZVsyXTtcbiAgICAgIGQuc2V0RGlzcG9zYWJsZShzb3VyY2Uuc3Vic2NyaWJlKG8pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGVsYXlTdWJzY3JpcHRpb247XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICAvKipcbiAgICogIFRpbWUgc2hpZnRzIHRoZSBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IGRlbGF5aW5nIHRoZSBzdWJzY3JpcHRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHRpbWUgZHVyYXRpb24sIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAxIC0gcmVzID0gc291cmNlLmRlbGF5U3Vic2NyaXB0aW9uKDUwMDApOyAvLyA1c1xuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS5kZWxheVN1YnNjcmlwdGlvbig1MDAwLCBSeC5TY2hlZHVsZXIuZGVmYXVsdCk7IC8vIDUgc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBSZWxhdGl2ZSBvciBhYnNvbHV0ZSB0aW1lIHNoaWZ0IG9mIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgc3Vic2NyaXB0aW9uIGRlbGF5IHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGltZW91dCBzY2hlZHVsZXIgaXMgdXNlZC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IFRpbWUtc2hpZnRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5kZWxheVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IERlbGF5U3Vic2NyaXB0aW9uKHRoaXMsIGR1ZVRpbWUsIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZShzb3VyY2UsIGQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlcihvLCB0aGlzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3MgPSBwLl9zO1xuICAgICAgdGhpcy5fZCA9IHAuX2Q7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIG5vdyA9IHRoaXMuX3Mubm93KCk7XG4gICAgICB0aGlzLl9xLnB1c2goeyBpbnRlcnZhbDogbm93LCB2YWx1ZTogeCB9KTtcbiAgICAgIHdoaWxlICh0aGlzLl9xLmxlbmd0aCA+IDAgJiYgbm93IC0gdGhpcy5fcVswXS5pbnRlcnZhbCA+PSB0aGlzLl9kKSB7XG4gICAgICAgIHRoaXMuX28ub25OZXh0KHRoaXMuX3Euc2hpZnQoKS52YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFNraXBMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vdyA9IHRoaXMuX3Mubm93KCk7XG4gICAgICB3aGlsZSAodGhpcy5fcS5sZW5ndGggPiAwICYmIG5vdyAtIHRoaXMuX3FbMF0uaW50ZXJ2YWwgPj0gdGhpcy5fZCkge1xuICAgICAgICB0aGlzLl9vLm9uTmV4dCh0aGlzLl9xLnNoaWZ0KCkudmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fby5vbkNvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcExhc3RXaXRoVGltZU9ic2VydmVyO1xuICB9KEFic3RyYWN0T2JzZXJ2ZXIpKTtcblxuICAvKipcbiAgICogIFNraXBzIGVsZW1lbnRzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgVGhpcyBvcGVyYXRvciBhY2N1bXVsYXRlcyBhIHF1ZXVlIHdpdGggYSBsZW5ndGggZW5vdWdoIHRvIHN0b3JlIGVsZW1lbnRzIHJlY2VpdmVkIGR1cmluZyB0aGUgaW5pdGlhbCBkdXJhdGlvbiB3aW5kb3cuXG4gICAqICBBcyBtb3JlIGVsZW1lbnRzIGFyZSByZWNlaXZlZCwgZWxlbWVudHMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGFyZSB0YWtlbiBmcm9tIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlXG4gICAqICByZXN1bHQgc2VxdWVuY2UuIFRoaXMgY2F1c2VzIGVsZW1lbnRzIHRvIGJlIGRlbGF5ZWQgd2l0aCBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIGZvciBza2lwcGluZyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBSeC5TY2hlZHVsZXIudGltZW91dFxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyBza2lwcGVkIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnNraXBMYXN0V2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgU2tpcExhc3RXaXRoVGltZU9ic2VydmFibGUodGhpcywgZHVyYXRpb24sIHNjaGVkdWxlcik7XG4gIH07XG5cbiAgdmFyIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZShzb3VyY2UsIGQsIHMpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fZCA9IGQ7XG4gICAgICB0aGlzLl9zID0gcztcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlcihvLCB0aGlzLl9kLCB0aGlzLl9zKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKF9fc3VwZXJfXykge1xuICAgIGluaGVyaXRzKFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlcihvLCBkLCBzKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9xID0gW107XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIG5vdyA9IHRoaXMuX3Mubm93KCk7XG4gICAgICB0aGlzLl9xLnB1c2goeyBpbnRlcnZhbDogbm93LCB2YWx1ZTogeCB9KTtcbiAgICAgIHdoaWxlICh0aGlzLl9xLmxlbmd0aCA+IDAgJiYgbm93IC0gdGhpcy5fcVswXS5pbnRlcnZhbCA+PSB0aGlzLl9kKSB7XG4gICAgICAgIHRoaXMuX3Euc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyB0aGlzLl9vLm9uRXJyb3IoZSk7IH07XG4gICAgVGFrZUxhc3RXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gdGhpcy5fcy5ub3coKTtcbiAgICAgIHdoaWxlICh0aGlzLl9xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLl9xLnNoaWZ0KCk7XG4gICAgICAgIGlmIChub3cgLSBuZXh0LmludGVydmFsIDw9IHRoaXMuX2QpIHsgdGhpcy5fby5vbk5leHQobmV4dC52YWx1ZSk7IH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX28ub25Db21wbGV0ZWQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRha2VMYXN0V2l0aFRpbWVPYnNlcnZlcjtcbiAgfShBYnN0cmFjdE9ic2VydmVyKSk7XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGVsZW1lbnRzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2Ugc2VxdWVuY2UsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVycyB0byBydW4gdGltZXJzIGFuZCB0byBkcmFpbiB0aGUgY29sbGVjdGVkIGVsZW1lbnRzLlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxuICAgKiAgQXMgbW9yZSBlbGVtZW50cyBhcmUgcmVjZWl2ZWQsIGVsZW1lbnRzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBhcmUgdGFrZW4gZnJvbSB0aGUgcXVldWUgYW5kIHByb2R1Y2VkIG9uIHRoZVxuICAgKiAgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkIHdpdGggZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3IgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyB0YWtlbiBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by50YWtlTGFzdFdpdGhUaW1lID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICByZXR1cm4gbmV3IFRha2VMYXN0V2l0aFRpbWVPYnNlcnZhYmxlKHRoaXMsIGR1cmF0aW9uLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFRoaXMgb3BlcmF0b3IgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoIGVub3VnaCB0byBzdG9yZSBlbGVtZW50cyByZWNlaXZlZCBkdXJpbmcgdGhlIGluaXRpYWwgZHVyYXRpb24gd2luZG93LlxuICAgKiAgQXMgbW9yZSBlbGVtZW50cyBhcmUgcmVjZWl2ZWQsIGVsZW1lbnRzIG9sZGVyIHRoYW4gdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBhcmUgdGFrZW4gZnJvbSB0aGUgcXVldWUgYW5kIHByb2R1Y2VkIG9uIHRoZVxuICAgKiAgcmVzdWx0IHNlcXVlbmNlLiBUaGlzIGNhdXNlcyBlbGVtZW50cyB0byBiZSBkZWxheWVkIHdpdGggZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBmb3IgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIGEgc2luZ2xlIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VMYXN0QnVmZmVyV2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHEgPSBbXTtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHEucHVzaCh7IGludGVydmFsOiBub3csIHZhbHVlOiB4IH0pO1xuICAgICAgICB3aGlsZSAocS5sZW5ndGggPiAwICYmIG5vdyAtIHFbMF0uaW50ZXJ2YWwgPj0gZHVyYXRpb24pIHtcbiAgICAgICAgICBxLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpLCByZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gcS5zaGlmdCgpO1xuICAgICAgICAgIG5vdyAtIG5leHQuaW50ZXJ2YWwgPD0gZHVyYXRpb24gJiYgcmVzLnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgby5vbk5leHQocmVzKTtcbiAgICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgICAgfSk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICB2YXIgVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZSwgX19zdXBlcl9fKTtcbiAgICBmdW5jdGlvbiBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgZCwgcykge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9kID0gZDtcbiAgICAgIHRoaXMuX3MgPSBzO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgbykge1xuICAgICAgby5vbkNvbXBsZXRlZCgpO1xuICAgIH1cblxuICAgIFRha2VXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLl9zLnNjaGVkdWxlRnV0dXJlKG8sIHRoaXMuX2QsIHNjaGVkdWxlTWV0aG9kKSxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKG8pXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFrZVdpdGhUaW1lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIC8qKlxuICAgKiAgVGFrZXMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgMSAtIHJlcyA9IHNvdXJjZS50YWtlV2l0aFRpbWUoNTAwMCwgIFtvcHRpb25hbCBzY2hlZHVsZXJdKTtcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBUaGlzIG9wZXJhdG9yIGFjY3VtdWxhdGVzIGEgcXVldWUgd2l0aCBhIGxlbmd0aCBlbm91Z2ggdG8gc3RvcmUgZWxlbWVudHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBpbml0aWFsIGR1cmF0aW9uIHdpbmRvdy5cbiAgICogIEFzIG1vcmUgZWxlbWVudHMgYXJlIHJlY2VpdmVkLCBlbGVtZW50cyBvbGRlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gYXJlIHRha2VuIGZyb20gdGhlIHF1ZXVlIGFuZCBwcm9kdWNlZCBvbiB0aGVcbiAgICogIHJlc3VsdCBzZXF1ZW5jZS4gVGhpcyBjYXVzZXMgZWxlbWVudHMgdG8gYmUgZGVsYXllZCB3aXRoIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyB0YWtlbiBkdXJpbmcgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc291cmNlIHNlcXVlbmNlLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VXaXRoVGltZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSB8fCAoc2NoZWR1bGVyID0gZGVmYXVsdFNjaGVkdWxlcik7XG4gICAgcmV0dXJuIG5ldyBUYWtlV2l0aFRpbWVPYnNlcnZhYmxlKHRoaXMsIGR1cmF0aW9uLCBzY2hlZHVsZXIpO1xuICB9O1xuXG4gIHZhciBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwV2l0aFRpbWVPYnNlcnZhYmxlLCBfX3N1cGVyX18pO1xuICAgIGZ1bmN0aW9uIFNraXBXaXRoVGltZU9ic2VydmFibGUoc291cmNlLCBkLCBzKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2QgPSBkO1xuICAgICAgdGhpcy5fcyA9IHM7XG4gICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1ldGhvZChzLCBzZWxmKSB7XG4gICAgICBzZWxmLl9vcGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBTa2lwV2l0aFRpbWVPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVDb3JlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBuZXcgQmluYXJ5RGlzcG9zYWJsZShcbiAgICAgICAgdGhpcy5fcy5zY2hlZHVsZUZ1dHVyZSh0aGlzLCB0aGlzLl9kLCBzY2hlZHVsZU1ldGhvZCksXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdpdGhUaW1lT2JzZXJ2ZXIobywgdGhpcykpXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZTtcbiAgfShPYnNlcnZhYmxlQmFzZSkpO1xuXG4gIHZhciBTa2lwV2l0aFRpbWVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFdpdGhUaW1lT2JzZXJ2ZXIsIF9fc3VwZXJfXyk7XG5cbiAgICBmdW5jdGlvbiBTa2lwV2l0aFRpbWVPYnNlcnZlcihvLCBwKSB7XG4gICAgICB0aGlzLl9vID0gbztcbiAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgU2tpcFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9wLl9vcGVuICYmIHRoaXMuX28ub25OZXh0KHgpOyB9O1xuICAgIFNraXBXaXRoVGltZU9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7IHRoaXMuX28ub25FcnJvcihlKTsgfTtcbiAgICBTa2lwV2l0aFRpbWVPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vLm9uQ29tcGxldGVkKCk7IH07XG5cbiAgICByZXR1cm4gU2tpcFdpdGhUaW1lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG4gIC8qKlxuICAgKiAgU2tpcHMgZWxlbWVudHMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIG9ic2VydmFibGUgc291cmNlIHNlcXVlbmNlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlciB0byBydW4gdGltZXJzLlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFNwZWNpZnlpbmcgYSB6ZXJvIHZhbHVlIGZvciBkdXJhdGlvbiBkb2Vzbid0IGd1YXJhbnRlZSBubyBlbGVtZW50cyB3aWxsIGJlIGRyb3BwZWQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICogIFRoaXMgaXMgYSBzaWRlLWVmZmVjdCBvZiB0aGUgYXN5bmNocm9ueSBpbnRyb2R1Y2VkIGJ5IHRoZSBzY2hlZHVsZXIsIHdoZXJlIHRoZSBhY3Rpb24gdGhhdCBjYXVzZXMgY2FsbGJhY2tzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZSB0byBiZSBmb3J3YXJkZWRcbiAgICogIG1heSBub3QgZXhlY3V0ZSBpbW1lZGlhdGVseSwgZGVzcGl0ZSB0aGUgemVybyBkdWUgdGltZS5cbiAgICpcbiAgICogIEVycm9ycyBwcm9kdWNlZCBieSB0aGUgc291cmNlIHNlcXVlbmNlIGFyZSBhbHdheXMgZm9yd2FyZGVkIHRvIHRoZSByZXN1bHQgc2VxdWVuY2UsIGV2ZW4gaWYgdGhlIGVycm9yIG9jY3VycyBiZWZvcmUgdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gZm9yIHNraXBwaW5nIGVsZW1lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IHNjaGVkdWxlciBTY2hlZHVsZXIgdG8gcnVuIHRoZSB0aW1lciBvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gUnguU2NoZWR1bGVyLnRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIHdpdGggdGhlIGVsZW1lbnRzIHNraXBwZWQgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZSBzZXF1ZW5jZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5za2lwV2l0aFRpbWUgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgU2tpcFdpdGhUaW1lT2JzZXJ2YWJsZSh0aGlzLCBkdXJhdGlvbiwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICB2YXIgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUsIF9fc3VwZXJfXyk7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlKHNvdXJjZSwgc3RhcnRUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5fc3QgPSBzdGFydFRpbWU7XG4gICAgICB0aGlzLl9zID0gc2NoZWR1bGVyO1xuICAgICAgX19zdXBlcl9fLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNZXRob2Qocywgc3RhdGUpIHtcbiAgICAgIHN0YXRlLl9vcGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZUNvcmUgPSBmdW5jdGlvbiAobykge1xuICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICB0aGlzLl9zLnNjaGVkdWxlRnV0dXJlKHRoaXMsIHRoaXMuX3N0LCBzY2hlZHVsZU1ldGhvZCksXG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlcihvLCB0aGlzKSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBTa2lwVW50aWxXaXRoVGltZU9ic2VydmFibGU7XG4gIH0oT2JzZXJ2YWJsZUJhc2UpKTtcblxuICB2YXIgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlciA9IChmdW5jdGlvbiAoX19zdXBlcl9fKSB7XG4gICAgaW5oZXJpdHMoU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlciwgX19zdXBlcl9fKTtcblxuICAgIGZ1bmN0aW9uIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIobywgcCkge1xuICAgICAgdGhpcy5fbyA9IG87XG4gICAgICB0aGlzLl9wID0gcDtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoeCkgeyB0aGlzLl9wLl9vcGVuICYmIHRoaXMuX28ub25OZXh0KHgpOyB9O1xuICAgIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHsgdGhpcy5fby5vbkVycm9yKGUpOyB9O1xuICAgIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fby5vbkNvbXBsZXRlZCgpOyB9O1xuXG4gICAgcmV0dXJuIFNraXBVbnRpbFdpdGhUaW1lT2JzZXJ2ZXI7XG4gIH0oQWJzdHJhY3RPYnNlcnZlcikpO1xuXG5cbiAgLyoqXG4gICAqICBTa2lwcyBlbGVtZW50cyBmcm9tIHRoZSBvYnNlcnZhYmxlIHNvdXJjZSBzZXF1ZW5jZSB1bnRpbCB0aGUgc3BlY2lmaWVkIHN0YXJ0IHRpbWUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqICBFcnJvcnMgcHJvZHVjZWQgYnkgdGhlIHNvdXJjZSBzZXF1ZW5jZSBhcmUgYWx3YXlzIGZvcndhcmRlZCB0byB0aGUgcmVzdWx0IHNlcXVlbmNlLCBldmVuIGlmIHRoZSBlcnJvciBvY2N1cnMgYmVmb3JlIHRoZSBzdGFydCB0aW1lLlxuICAgKlxuICAgKiBAZXhhbXBsZXNcbiAgICogIDEgLSByZXMgPSBzb3VyY2Uuc2tpcFVudGlsV2l0aFRpbWUobmV3IERhdGUoKSwgW3NjaGVkdWxlcl0pO1xuICAgKiAgMiAtIHJlcyA9IHNvdXJjZS5za2lwVW50aWxXaXRoVGltZSg1MDAwLCBbc2NoZWR1bGVyXSk7XG4gICAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IHN0YXJ0VGltZSBUaW1lIHRvIHN0YXJ0IHRha2luZyBlbGVtZW50cyBmcm9tIHRoZSBzb3VyY2Ugc2VxdWVuY2UuIElmIHRoaXMgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIERhdGUoKSwgbm8gZWxlbWVudHMgd2lsbCBiZSBza2lwcGVkLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIHRvIHJ1biB0aGUgdGltZXIgb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFJ4LlNjaGVkdWxlci50aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyBza2lwcGVkIHVudGlsIHRoZSBzcGVjaWZpZWQgc3RhcnQgdGltZS5cbiAgICovXG4gIG9ic2VydmFibGVQcm90by5za2lwVW50aWxXaXRoVGltZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHJldHVybiBuZXcgU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlKHRoaXMsIHN0YXJ0VGltZSwgc2NoZWR1bGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIFRha2VzIGVsZW1lbnRzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIHVudGlsIHRoZSBzcGVjaWZpZWQgZW5kIHRpbWUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyIHRvIHJ1biB0aW1lcnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgRGF0ZX0gZW5kVGltZSBUaW1lIHRvIHN0b3AgdGFraW5nIGVsZW1lbnRzIGZyb20gdGhlIHNvdXJjZSBzZXF1ZW5jZS4gSWYgdGhpcyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbmV3IERhdGUoKSwgdGhlIHJlc3VsdCBzdHJlYW0gd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB0byBydW4gdGhlIHRpbWVyIG9uLlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbGVtZW50cyB0YWtlbiB1bnRpbCB0aGUgc3BlY2lmaWVkIGVuZCB0aW1lLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRha2VVbnRpbFdpdGhUaW1lID0gZnVuY3Rpb24gKGVuZFRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlzU2NoZWR1bGVyKHNjaGVkdWxlcikgfHwgKHNjaGVkdWxlciA9IGRlZmF1bHRTY2hlZHVsZXIpO1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG5ldyBCaW5hcnlEaXNwb3NhYmxlKFxuICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGVGdXR1cmUobywgZW5kVGltZSwgZnVuY3Rpb24gKF8sIG8pIHsgby5vbkNvbXBsZXRlZCgpOyB9KSxcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShvKSk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgZmlyc3QgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBkdXJpbmcgc2VxdWVudGlhbCB0aW1lIHdpbmRvd3Mgb2YgYSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dEdXJhdGlvbiB0aW1lIHRvIHdhaXQgYmVmb3JlIGVtaXR0aW5nIGFub3RoZXIgaXRlbSBhZnRlciBlbWl0dGluZyB0aGUgbGFzdCBpdGVtXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSB0aGUgU2NoZWR1bGVyIHRvIHVzZSBpbnRlcm5hbGx5IHRvIG1hbmFnZSB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRpbWVvdXQgZm9yIGVhY2ggaXRlbS4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBTY2hlZHVsZXIudGltZW91dC5cbiAgICogQHJldHVybnMge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uLlxuICAgKi9cbiAgb2JzZXJ2YWJsZVByb3RvLnRocm90dGxlID0gZnVuY3Rpb24gKHdpbmRvd0R1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICBpc1NjaGVkdWxlcihzY2hlZHVsZXIpIHx8IChzY2hlZHVsZXIgPSBkZWZhdWx0U2NoZWR1bGVyKTtcbiAgICB2YXIgZHVyYXRpb24gPSArd2luZG93RHVyYXRpb24gfHwgMDtcbiAgICBpZiAoZHVyYXRpb24gPD0gMCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2luZG93RHVyYXRpb24gY2Fubm90IGJlIGxlc3Mgb3IgZXF1YWwgemVyby4nKTsgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzT2JzZXJ2YWJsZShmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGxhc3RPbk5leHQgPSAwO1xuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgdmFyIG5vdyA9IHNjaGVkdWxlci5ub3coKTtcbiAgICAgICAgICBpZiAobGFzdE9uTmV4dCA9PT0gMCB8fCBub3cgLSBsYXN0T25OZXh0ID49IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBsYXN0T25OZXh0ID0gbm93O1xuICAgICAgICAgICAgby5vbk5leHQoeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LGZ1bmN0aW9uIChlKSB7IG8ub25FcnJvcihlKTsgfSwgZnVuY3Rpb24gKCkgeyBvLm9uQ29tcGxldGVkKCk7IH1cbiAgICAgICk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiaW5oZXJpdHMiLCJpbnRlcm5hbHMiLCJBYnN0cmFjdE9ic2VydmVyIiwiT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVQcm90byIsInByb3RvdHlwZSIsIkFub255bW91c09ic2VydmFibGUiLCJPYnNlcnZhYmxlQmFzZSIsIm9ic2VydmFibGVEZWZlciIsImRlZmVyIiwib2JzZXJ2YWJsZUVtcHR5IiwiZW1wdHkiLCJvYnNlcnZhYmxlTmV2ZXIiLCJuZXZlciIsIm9ic2VydmFibGVUaHJvdyIsIm9ic2VydmFibGVGcm9tQXJyYXkiLCJmcm9tQXJyYXkiLCJkZWZhdWx0U2NoZWR1bGVyIiwiU2NoZWR1bGVyIiwiU2luZ2xlQXNzaWdubWVudERpc3Bvc2FibGUiLCJTZXJpYWxEaXNwb3NhYmxlIiwiQ29tcG9zaXRlRGlzcG9zYWJsZSIsIkJpbmFyeURpc3Bvc2FibGUiLCJSZWZDb3VudERpc3Bvc2FibGUiLCJTdWJqZWN0IiwiYWRkUmVmIiwibm9ybWFsaXplVGltZSIsIm5vcm1hbGl6ZSIsImhlbHBlcnMiLCJpc1Byb21pc2UiLCJpc0Z1bmN0aW9uIiwiaXNTY2hlZHVsZXIiLCJvYnNlcnZhYmxlRnJvbVByb21pc2UiLCJmcm9tUHJvbWlzZSIsImVycm9yT2JqIiwiZSIsInRyeUNhdGNoZXJHZW4iLCJ0cnlDYXRjaFRhcmdldCIsInRyeUNhdGNoZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyeUNhdGNoIiwiZm4iLCJUeXBlRXJyb3IiLCJ0aHJvd2VyIiwiVGltZXJPYnNlcnZhYmxlIiwiX19zdXBlcl9fIiwiZHQiLCJzIiwiX2R0IiwiX3MiLCJzdWJzY3JpYmVDb3JlIiwibyIsInNjaGVkdWxlRnV0dXJlIiwic2NoZWR1bGVNZXRob2QiLCJvbk5leHQiLCJvbkNvbXBsZXRlZCIsIl9vYnNlcnZhYmxlVGltZXIiLCJkdWVUaW1lIiwic2NoZWR1bGVyIiwib2JzZXJ2YWJsZVRpbWVyRGF0ZUFuZFBlcmlvZCIsInBlcmlvZCIsIm9ic2VydmVyIiwiZCIsInAiLCJzY2hlZHVsZVJlY3Vyc2l2ZUZ1dHVyZSIsImNvdW50Iiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJvYnNlcnZhYmxlVGltZXJUaW1lU3BhbkFuZFBlcmlvZCIsInNjaGVkdWxlUGVyaW9kaWMiLCJvYnNlcnZhYmxlaW50ZXJ2YWwiLCJpbnRlcnZhbCIsIm9ic2VydmFibGVUaW1lciIsInRpbWVyIiwicGVyaW9kT3JTY2hlZHVsZXIiLCJvYnNlcnZhYmxlRGVsYXlSZWxhdGl2ZSIsInNvdXJjZSIsImFjdGl2ZSIsImNhbmNlbGFibGUiLCJleGNlcHRpb24iLCJxIiwicnVubmluZyIsInN1YnNjcmlwdGlvbiIsIm1hdGVyaWFsaXplIiwidGltZXN0YW1wIiwic3Vic2NyaWJlIiwibm90aWZpY2F0aW9uIiwic2hvdWxkUnVuIiwia2luZCIsInB1c2giLCJlcnJvciIsIm9uRXJyb3IiLCJzZXREaXNwb3NhYmxlIiwiXyIsInJlY3Vyc2VEdWVUaW1lIiwicmVzdWx0Iiwic2hvdWxkUmVjdXJzZSIsImxlbmd0aCIsInNoaWZ0IiwiYWNjZXB0IiwiTWF0aCIsIm1heCIsIm9ic2VydmFibGVEZWxheUFic29sdXRlIiwiZGVsYXlXaXRoU2VsZWN0b3IiLCJzdWJzY3JpcHRpb25EZWxheSIsImRlbGF5RHVyYXRpb25TZWxlY3RvciIsInN1YkRlbGF5Iiwic2VsZWN0b3IiLCJkZWxheXMiLCJhdEVuZCIsInN0YXJ0IiwieCIsImRlbGF5IiwiYWRkIiwicmVtb3ZlIiwiZG9uZSIsImRpc3Bvc2UiLCJmaXJzdEFyZyIsImlzT2JzZXJ2YWJsZSIsIkVycm9yIiwiRGVib3VuY2VPYnNlcnZhYmxlIiwiRGVib3VuY2VPYnNlcnZlciIsIl9vIiwiX2QiLCJfc2NoZWR1bGVyIiwiX2MiLCJfdiIsIl9odiIsIl9pZCIsInN0YXRlIiwiY3VycmVudElkIiwibmV4dCIsImNvbXBsZXRlZCIsImRlYm91bmNlV2l0aFNlbGVjdG9yIiwiZHVyYXRpb25TZWxlY3RvciIsImhhc1ZhbHVlIiwiaWQiLCJ0aHJvdHRsZSIsImN1cnJlbnRpZCIsImRlYm91bmNlIiwid2luZG93V2l0aFRpbWUiLCJ3aW5kb3dUaW1lIiwidGltZVNwYW4iLCJ0aW1lU2hpZnRPclNjaGVkdWxlciIsInRpbWVTaGlmdCIsImdyb3VwRGlzcG9zYWJsZSIsIm5leHRTaGlmdCIsIm5leHRTcGFuIiwicmVmQ291bnREaXNwb3NhYmxlIiwidGltZXJEIiwidG90YWxUaW1lIiwiY3JlYXRlVGltZXIiLCJtIiwiaXNTcGFuIiwiaXNTaGlmdCIsIm5ld1RvdGFsVGltZSIsInRzIiwiaSIsImxlbiIsIndpbmRvd1dpdGhUaW1lT3JDb3VudCIsIndpbmRvd1RpbWVPckNvdW50IiwibiIsIndpbmRvd0lkIiwibmV3SWQiLCJuZXdXaW5kb3ciLCJ0b0FycmF5IiwiYnVmZmVyV2l0aFRpbWUiLCJidWZmZXJUaW1lIiwiZmxhdE1hcCIsImJ1ZmZlcldpdGhUaW1lT3JDb3VudCIsImJ1ZmZlclRpbWVPckNvdW50IiwiVGltZUludGVydmFsT2JzZXJ2YWJsZSIsIlRpbWVJbnRlcnZhbE9ic2VydmVyIiwiX2wiLCJzcGFuIiwidGltZUludGVydmFsIiwiVGltZXN0YW1wT2JzZXJ2YWJsZSIsIlRpbWVzdGFtcE9ic2VydmVyIiwiU2FtcGxlT2JzZXJ2YWJsZSIsInNhbXBsZXIiLCJfc2FtcGxlciIsInNvdXJjZVN1YnNjcmlwdGlvbiIsIlNhbXBsZVNvdXJjZU9ic2VydmVyIiwiU2FtcGxlck9ic2VydmVyIiwiX2hhbmRsZU1lc3NhZ2UiLCJzYW1wbGUiLCJpbnRlcnZhbE9yU2FtcGxlciIsIlRpbWVvdXRFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY3JlYXRlIiwidGltZW91dFdpdGhTZWxlY3RvciIsImZpcnN0VGltZW91dCIsInRpbWVvdXREdXJhdGlvblNlbGVjdG9yIiwib3RoZXIiLCJvcmlnaW5hbCIsInN3aXRjaGVkIiwic2V0VGltZXIiLCJ0aW1lb3V0IiwibXlJZCIsInRpbWVyV2lucyIsIm9XaW5zIiwicmVzIiwiR2VuZXJhdGVBYnNvbHV0ZU9ic2VydmFibGUiLCJjbmRGbiIsIml0ckZuIiwicmVzRm4iLCJ0aW1lRm4iLCJfc3RhdGUiLCJfY25kRm4iLCJfaXRyRm4iLCJfcmVzRm4iLCJfdGltZUZuIiwic2NoZWR1bGVSZWN1cnNpdmUiLCJyZWN1cnNlIiwiaGFzUmVzdWx0IiwiZmlyc3QiLCJuZXdTdGF0ZSIsInRpbWUiLCJnZW5lcmF0ZVdpdGhBYnNvbHV0ZVRpbWUiLCJpbml0aWFsU3RhdGUiLCJjb25kaXRpb24iLCJpdGVyYXRlIiwicmVzdWx0U2VsZWN0b3IiLCJ0aW1lU2VsZWN0b3IiLCJHZW5lcmF0ZVJlbGF0aXZlT2JzZXJ2YWJsZSIsImdlbmVyYXRlV2l0aFJlbGF0aXZlVGltZSIsIkRlbGF5U3Vic2NyaXB0aW9uIiwiZGVsYXlTdWJzY3JpcHRpb24iLCJTa2lwTGFzdFdpdGhUaW1lT2JzZXJ2YWJsZSIsIlNraXBMYXN0V2l0aFRpbWVPYnNlcnZlciIsIl9xIiwic2tpcExhc3RXaXRoVGltZSIsImR1cmF0aW9uIiwiVGFrZUxhc3RXaXRoVGltZU9ic2VydmFibGUiLCJUYWtlTGFzdFdpdGhUaW1lT2JzZXJ2ZXIiLCJ0YWtlTGFzdFdpdGhUaW1lIiwidGFrZUxhc3RCdWZmZXJXaXRoVGltZSIsIlRha2VXaXRoVGltZU9ic2VydmFibGUiLCJ0YWtlV2l0aFRpbWUiLCJTa2lwV2l0aFRpbWVPYnNlcnZhYmxlIiwiX29wZW4iLCJTa2lwV2l0aFRpbWVPYnNlcnZlciIsIl9wIiwic2tpcFdpdGhUaW1lIiwiU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZhYmxlIiwic3RhcnRUaW1lIiwiX3N0IiwiU2tpcFVudGlsV2l0aFRpbWVPYnNlcnZlciIsInNraXBVbnRpbFdpdGhUaW1lIiwidGFrZVVudGlsV2l0aFRpbWUiLCJlbmRUaW1lIiwid2luZG93RHVyYXRpb24iLCJSYW5nZUVycm9yIiwibGFzdE9uTmV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/dist/rx.virtualtime.js":
/*!************************************************!*\
  !*** ./node_modules/rx/dist/rx.virtualtime.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n(function(factory) {\n    var objectTypes = {\n        \"function\": true,\n        \"object\": true\n    };\n    function checkGlobal(value) {\n        return value && value.Object === Object ? value : null;\n    }\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : null;\n    var freeModule = objectTypes[\"object\"] && module && !module.nodeType ? module : null;\n    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === \"object\" && global);\n    var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n    var freeWindow = checkGlobal(objectTypes[\"undefined\"] && window);\n    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : null;\n    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function(\"return this\")();\n    // Because of build optimizers\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./rx */ \"(ssr)/./node_modules/rx/dist/rx.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(Rx, exports1) {\n            return factory(root, exports1, Rx);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}).call(void 0, function(root, exp, Rx, undefined) {\n    // Aliases\n    var Scheduler = Rx.Scheduler, ScheduledItem = Rx.internals.ScheduledItem, SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive, PriorityQueue = Rx.internals.PriorityQueue, inherits = Rx.internals.inherits, defaultSubComparer = Rx.helpers.defaultSubComparer, notImplemented = Rx.helpers.notImplemented;\n    /** Provides a set of extension methods for virtual time scheduling. */ var VirtualTimeScheduler = Rx.VirtualTimeScheduler = function(__super__) {\n        inherits(VirtualTimeScheduler, __super__);\n        /**\n     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.\n     *\n     * @constructor\n     * @param {Number} initialClock Initial value for the clock.\n     * @param {Function} comparer Comparer to determine causality of events based on absolute time.\n     */ function VirtualTimeScheduler(initialClock, comparer) {\n            this.clock = initialClock;\n            this.comparer = comparer;\n            this.isEnabled = false;\n            this.queue = new PriorityQueue(1024);\n            __super__.call(this);\n        }\n        var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;\n        VirtualTimeSchedulerPrototype.now = function() {\n            return this.toAbsoluteTime(this.clock);\n        };\n        VirtualTimeSchedulerPrototype.schedule = function(state, action) {\n            return this.scheduleAbsolute(state, this.clock, action);\n        };\n        VirtualTimeSchedulerPrototype.scheduleFuture = function(state, dueTime, action) {\n            var dt = dueTime instanceof Date ? this.toRelativeTime(dueTime - this.now()) : this.toRelativeTime(dueTime);\n            return this.scheduleRelative(state, dt, action);\n        };\n        /**\n     * Adds a relative time value to an absolute time value.\n     * @param {Number} absolute Absolute virtual time value.\n     * @param {Number} relative Relative virtual time value to add.\n     * @return {Number} Resulting absolute virtual time sum value.\n     */ VirtualTimeSchedulerPrototype.add = notImplemented;\n        /**\n     * Converts an absolute time to a number\n     * @param {Any} The absolute time.\n     * @returns {Number} The absolute time in ms\n     */ VirtualTimeSchedulerPrototype.toAbsoluteTime = notImplemented;\n        /**\n     * Converts the TimeSpan value to a relative virtual time value.\n     * @param {Number} timeSpan TimeSpan value to convert.\n     * @return {Number} Corresponding relative virtual time value.\n     */ VirtualTimeSchedulerPrototype.toRelativeTime = notImplemented;\n        /**\n     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.\n     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n     * @param {Number} period Period for running the work periodically.\n     * @param {Function} action Action to be executed, potentially updating the state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n     */ VirtualTimeSchedulerPrototype.schedulePeriodic = function(state, period, action) {\n            var s = new SchedulePeriodicRecursive(this, state, period, action);\n            return s.start();\n        };\n        /**\n     * Schedules an action to be executed after dueTime.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Number} dueTime Relative time after which to execute the action.\n     * @param {Function} action Action to be executed.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */ VirtualTimeSchedulerPrototype.scheduleRelative = function(state, dueTime, action) {\n            var runAt = this.add(this.clock, dueTime);\n            return this.scheduleAbsolute(state, runAt, action);\n        };\n        /**\n     * Starts the virtual time scheduler.\n     */ VirtualTimeSchedulerPrototype.start = function() {\n            if (!this.isEnabled) {\n                this.isEnabled = true;\n                do {\n                    var next = this.getNext();\n                    if (next !== null) {\n                        this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);\n                        next.invoke();\n                    } else {\n                        this.isEnabled = false;\n                    }\n                }while (this.isEnabled);\n            }\n        };\n        /**\n     * Stops the virtual time scheduler.\n     */ VirtualTimeSchedulerPrototype.stop = function() {\n            this.isEnabled = false;\n        };\n        /**\n     * Advances the scheduler's clock to the specified time, running all work till that point.\n     * @param {Number} time Absolute time to advance the scheduler's clock to.\n     */ VirtualTimeSchedulerPrototype.advanceTo = function(time) {\n            var dueToClock = this.comparer(this.clock, time);\n            if (this.comparer(this.clock, time) > 0) {\n                throw new ArgumentOutOfRangeError();\n            }\n            if (dueToClock === 0) {\n                return;\n            }\n            if (!this.isEnabled) {\n                this.isEnabled = true;\n                do {\n                    var next = this.getNext();\n                    if (next !== null && this.comparer(next.dueTime, time) <= 0) {\n                        this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);\n                        next.invoke();\n                    } else {\n                        this.isEnabled = false;\n                    }\n                }while (this.isEnabled);\n                this.clock = time;\n            }\n        };\n        /**\n     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.\n     * @param {Number} time Relative time to advance the scheduler's clock by.\n     */ VirtualTimeSchedulerPrototype.advanceBy = function(time) {\n            var dt = this.add(this.clock, time), dueToClock = this.comparer(this.clock, dt);\n            if (dueToClock > 0) {\n                throw new ArgumentOutOfRangeError();\n            }\n            if (dueToClock === 0) {\n                return;\n            }\n            this.advanceTo(dt);\n        };\n        /**\n     * Advances the scheduler's clock by the specified relative time.\n     * @param {Number} time Relative time to advance the scheduler's clock by.\n     */ VirtualTimeSchedulerPrototype.sleep = function(time) {\n            var dt = this.add(this.clock, time);\n            if (this.comparer(this.clock, dt) >= 0) {\n                throw new ArgumentOutOfRangeError();\n            }\n            this.clock = dt;\n        };\n        /**\n     * Gets the next scheduled item to be executed.\n     * @returns {ScheduledItem} The next scheduled item.\n     */ VirtualTimeSchedulerPrototype.getNext = function() {\n            while(this.queue.length > 0){\n                var next = this.queue.peek();\n                if (next.isCancelled()) {\n                    this.queue.dequeue();\n                } else {\n                    return next;\n                }\n            }\n            return null;\n        };\n        /**\n     * Schedules an action to be executed at dueTime.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Number} dueTime Absolute time at which to execute the action.\n     * @param {Function} action Action to be executed.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */ VirtualTimeSchedulerPrototype.scheduleAbsolute = function(state, dueTime, action) {\n            var self1 = this;\n            function run(scheduler, state1) {\n                self1.queue.remove(si);\n                return action(scheduler, state1);\n            }\n            var si = new ScheduledItem(this, state, run, dueTime, this.comparer);\n            this.queue.enqueue(si);\n            return si.disposable;\n        };\n        return VirtualTimeScheduler;\n    }(Scheduler);\n    /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */ Rx.HistoricalScheduler = function(__super__) {\n        inherits(HistoricalScheduler, __super__);\n        /**\n     * Creates a new historical scheduler with the specified initial clock value.\n     * @constructor\n     * @param {Number} initialClock Initial value for the clock.\n     * @param {Function} comparer Comparer to determine causality of events based on absolute time.\n     */ function HistoricalScheduler(initialClock, comparer) {\n            var clock = initialClock == null ? 0 : initialClock;\n            var cmp = comparer || defaultSubComparer;\n            __super__.call(this, clock, cmp);\n        }\n        var HistoricalSchedulerProto = HistoricalScheduler.prototype;\n        /**\n     * Adds a relative time value to an absolute time value.\n     * @param {Number} absolute Absolute virtual time value.\n     * @param {Number} relative Relative virtual time value to add.\n     * @return {Number} Resulting absolute virtual time sum value.\n     */ HistoricalSchedulerProto.add = function(absolute, relative) {\n            return absolute + relative;\n        };\n        HistoricalSchedulerProto.toAbsoluteTime = function(absolute) {\n            return new Date(absolute).getTime();\n        };\n        /**\n     * Converts the TimeSpan value to a relative virtual time value.\n     * @memberOf HistoricalScheduler\n     * @param {Number} timeSpan TimeSpan value to convert.\n     * @return {Number} Corresponding relative virtual time value.\n     */ HistoricalSchedulerProto.toRelativeTime = function(timeSpan) {\n            return timeSpan;\n        };\n        return HistoricalScheduler;\n    }(Rx.VirtualTimeScheduler);\n    return Rx;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvZGlzdC9yeC52aXJ0dWFsdGltZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsNktBQTZHOztBQUUzRyxVQUFVQSxPQUFPO0lBQ2pCLElBQUlDLGNBQWM7UUFDaEIsWUFBWTtRQUNaLFVBQVU7SUFDWjtJQUVBLFNBQVNDLFlBQVlDLEtBQUs7UUFDeEIsT0FBTyxTQUFVQSxNQUFNQyxNQUFNLEtBQUtBLFNBQVVELFFBQVE7SUFDdEQ7SUFFQSxJQUFJRSxjQUFjLFdBQVksQ0FBQyxPQUFPQyxRQUFRLElBQUlBLFdBQVcsQ0FBQ0EsUUFBUUMsUUFBUSxHQUFJRCxVQUFVO0lBQzVGLElBQUlFLGFBQWEsV0FBWSxDQUFDLFFBQWFDLENBQUMsSUFBSUEsVUFBVSxDQUFDQSxPQUFPRixRQUFRLEdBQUlFLFNBQVM7SUFDdkYsSUFBSUMsYUFBYVIsWUFBWUcsZUFBZUcsY0FBYyxPQUFPRyxXQUFXLFlBQVlBO0lBQ3hGLElBQUlDLFdBQVdWLFlBQVlELFdBQVcsQ0FBQyxPQUFPWSxLQUFLLElBQUlBO0lBQ3ZELElBQUlDLGFBQWFaLFlBQVlELFdBQVcsQ0FBQyxZQUFjLElBQUljO0lBQzNELElBQUlDLGdCQUFnQixjQUFlUixXQUFXRixPQUFPLEtBQUtELGNBQWVBLGNBQWM7SUFDdkYsSUFBSVksYUFBYWYsWUFBWUQsV0FBVyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksSUFBSTtJQUM3RCxJQUFJaUIsT0FBT1IsY0FBZSxlQUFpQk8sQ0FBQUEsY0FBY0EsV0FBV0YsTUFBTSxLQUFNRCxjQUFlRixZQUFZSyxjQUFjRSxTQUFTO0lBRWxJLDhCQUE4QjtJQUM5QixJQUFJLElBQTBDLEVBQUU7UUFDOUNDLGlDQUFPO1lBQUM7U0FBTyxtQ0FBRSxTQUFVRSxFQUFFLEVBQUVoQixRQUFPO1lBQ3BDLE9BQU9OLFFBQVFrQixNQUFNWixVQUFTZ0I7UUFDaEMsQ0FBQztBQUFBLGtHQUFDO0lBQ0osT0FBTyxFQUlOO0FBQ0gsR0FBRUUsSUFBSSxDQUFDLFFBQU0sU0FBVU4sSUFBSSxFQUFFTyxHQUFHLEVBQUVILEVBQUUsRUFBRUksU0FBUztJQUU3QyxVQUFVO0lBQ1YsSUFBSUMsWUFBWUwsR0FBR0ssU0FBUyxFQUMxQkMsZ0JBQWdCTixHQUFHTyxTQUFTLENBQUNELGFBQWEsRUFDMUNFLDRCQUE2QlIsR0FBR08sU0FBUyxDQUFDQyx5QkFBeUIsRUFDbkVDLGdCQUFnQlQsR0FBR08sU0FBUyxDQUFDRSxhQUFhLEVBQzFDQyxXQUFXVixHQUFHTyxTQUFTLENBQUNHLFFBQVEsRUFDaENDLHFCQUFxQlgsR0FBR1ksT0FBTyxDQUFDRCxrQkFBa0IsRUFDbERFLGlCQUFpQmIsR0FBR1ksT0FBTyxDQUFDQyxjQUFjO0lBRTVDLHFFQUFxRSxHQUNyRSxJQUFJQyx1QkFBdUJkLEdBQUdjLG9CQUFvQixHQUFJLFNBQVVDLFNBQVM7UUFDdkVMLFNBQVNJLHNCQUFzQkM7UUFFL0I7Ozs7OztLQU1DLEdBQ0QsU0FBU0QscUJBQXFCRSxZQUFZLEVBQUVDLFFBQVE7WUFDbEQsSUFBSSxDQUFDQyxLQUFLLEdBQUdGO1lBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1lBQ2hCLElBQUksQ0FBQ0UsU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlYLGNBQWM7WUFDL0JNLFVBQVViLElBQUksQ0FBQyxJQUFJO1FBQ3JCO1FBRUEsSUFBSW1CLGdDQUFnQ1AscUJBQXFCUSxTQUFTO1FBRWxFRCw4QkFBOEJFLEdBQUcsR0FBRztZQUNsQyxPQUFPLElBQUksQ0FBQ0MsY0FBYyxDQUFDLElBQUksQ0FBQ04sS0FBSztRQUN2QztRQUVBRyw4QkFBOEJJLFFBQVEsR0FBRyxTQUFVQyxLQUFLLEVBQUVDLE1BQU07WUFDOUQsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDRixPQUFPLElBQUksQ0FBQ1IsS0FBSyxFQUFFUztRQUNsRDtRQUVBTiw4QkFBOEJRLGNBQWMsR0FBRyxTQUFVSCxLQUFLLEVBQUVJLE9BQU8sRUFBRUgsTUFBTTtZQUM3RSxJQUFJSSxLQUFLRCxtQkFBbUJFLE9BQzFCLElBQUksQ0FBQ0MsY0FBYyxDQUFDSCxVQUFVLElBQUksQ0FBQ1AsR0FBRyxNQUN0QyxJQUFJLENBQUNVLGNBQWMsQ0FBQ0g7WUFFdEIsT0FBTyxJQUFJLENBQUNJLGdCQUFnQixDQUFDUixPQUFPSyxJQUFJSjtRQUMxQztRQUVBOzs7OztLQUtDLEdBQ0ROLDhCQUE4QmMsR0FBRyxHQUFHdEI7UUFFcEM7Ozs7S0FJQyxHQUNEUSw4QkFBOEJHLGNBQWMsR0FBR1g7UUFFL0M7Ozs7S0FJQyxHQUNEUSw4QkFBOEJZLGNBQWMsR0FBR3BCO1FBRS9DOzs7Ozs7S0FNQyxHQUNEUSw4QkFBOEJlLGdCQUFnQixHQUFHLFNBQVVWLEtBQUssRUFBRVcsTUFBTSxFQUFFVixNQUFNO1lBQzlFLElBQUlXLElBQUksSUFBSTlCLDBCQUEwQixJQUFJLEVBQUVrQixPQUFPVyxRQUFRVjtZQUMzRCxPQUFPVyxFQUFFQyxLQUFLO1FBQ2hCO1FBRUE7Ozs7OztLQU1DLEdBQ0RsQiw4QkFBOEJhLGdCQUFnQixHQUFHLFNBQVVSLEtBQUssRUFBRUksT0FBTyxFQUFFSCxNQUFNO1lBQy9FLElBQUlhLFFBQVEsSUFBSSxDQUFDTCxHQUFHLENBQUMsSUFBSSxDQUFDakIsS0FBSyxFQUFFWTtZQUNqQyxPQUFPLElBQUksQ0FBQ0YsZ0JBQWdCLENBQUNGLE9BQU9jLE9BQU9iO1FBQzdDO1FBRUE7O0tBRUMsR0FDRE4sOEJBQThCa0IsS0FBSyxHQUFHO1lBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUNwQixTQUFTLEVBQUU7Z0JBQ25CLElBQUksQ0FBQ0EsU0FBUyxHQUFHO2dCQUNqQixHQUFHO29CQUNELElBQUlzQixPQUFPLElBQUksQ0FBQ0MsT0FBTztvQkFDdkIsSUFBSUQsU0FBUyxNQUFNO3dCQUNqQixJQUFJLENBQUN4QixRQUFRLENBQUN3QixLQUFLWCxPQUFPLEVBQUUsSUFBSSxDQUFDWixLQUFLLElBQUksS0FBTSxLQUFJLENBQUNBLEtBQUssR0FBR3VCLEtBQUtYLE9BQU87d0JBQ3pFVyxLQUFLRSxNQUFNO29CQUNiLE9BQU87d0JBQ0wsSUFBSSxDQUFDeEIsU0FBUyxHQUFHO29CQUNuQjtnQkFDRixRQUFTLElBQUksQ0FBQ0EsU0FBUyxFQUFFO1lBQzNCO1FBQ0Y7UUFFQTs7S0FFQyxHQUNERSw4QkFBOEJ1QixJQUFJLEdBQUc7WUFDbkMsSUFBSSxDQUFDekIsU0FBUyxHQUFHO1FBQ25CO1FBRUE7OztLQUdDLEdBQ0RFLDhCQUE4QndCLFNBQVMsR0FBRyxTQUFVQyxJQUFJO1lBQ3RELElBQUlDLGFBQWEsSUFBSSxDQUFDOUIsUUFBUSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxFQUFFNEI7WUFDM0MsSUFBSSxJQUFJLENBQUM3QixRQUFRLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUU0QixRQUFRLEdBQUc7Z0JBQUUsTUFBTSxJQUFJRTtZQUEyQjtZQUNoRixJQUFJRCxlQUFlLEdBQUc7Z0JBQUU7WUFBUTtZQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDNUIsU0FBUyxFQUFFO2dCQUNuQixJQUFJLENBQUNBLFNBQVMsR0FBRztnQkFDakIsR0FBRztvQkFDRCxJQUFJc0IsT0FBTyxJQUFJLENBQUNDLE9BQU87b0JBQ3ZCLElBQUlELFNBQVMsUUFBUSxJQUFJLENBQUN4QixRQUFRLENBQUN3QixLQUFLWCxPQUFPLEVBQUVnQixTQUFTLEdBQUc7d0JBQzNELElBQUksQ0FBQzdCLFFBQVEsQ0FBQ3dCLEtBQUtYLE9BQU8sRUFBRSxJQUFJLENBQUNaLEtBQUssSUFBSSxLQUFNLEtBQUksQ0FBQ0EsS0FBSyxHQUFHdUIsS0FBS1gsT0FBTzt3QkFDekVXLEtBQUtFLE1BQU07b0JBQ2IsT0FBTzt3QkFDTCxJQUFJLENBQUN4QixTQUFTLEdBQUc7b0JBQ25CO2dCQUNGLFFBQVMsSUFBSSxDQUFDQSxTQUFTLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0QsS0FBSyxHQUFHNEI7WUFDZjtRQUNGO1FBRUE7OztLQUdDLEdBQ0R6Qiw4QkFBOEI0QixTQUFTLEdBQUcsU0FBVUgsSUFBSTtZQUN0RCxJQUFJZixLQUFLLElBQUksQ0FBQ0ksR0FBRyxDQUFDLElBQUksQ0FBQ2pCLEtBQUssRUFBRTRCLE9BQzFCQyxhQUFhLElBQUksQ0FBQzlCLFFBQVEsQ0FBQyxJQUFJLENBQUNDLEtBQUssRUFBRWE7WUFDM0MsSUFBSWdCLGFBQWEsR0FBRztnQkFBRSxNQUFNLElBQUlDO1lBQTJCO1lBQzNELElBQUlELGVBQWUsR0FBRztnQkFBRztZQUFRO1lBRWpDLElBQUksQ0FBQ0YsU0FBUyxDQUFDZDtRQUNqQjtRQUVBOzs7S0FHQyxHQUNEViw4QkFBOEI2QixLQUFLLEdBQUcsU0FBVUosSUFBSTtZQUNsRCxJQUFJZixLQUFLLElBQUksQ0FBQ0ksR0FBRyxDQUFDLElBQUksQ0FBQ2pCLEtBQUssRUFBRTRCO1lBQzlCLElBQUksSUFBSSxDQUFDN0IsUUFBUSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxFQUFFYSxPQUFPLEdBQUc7Z0JBQUUsTUFBTSxJQUFJaUI7WUFBMkI7WUFFL0UsSUFBSSxDQUFDOUIsS0FBSyxHQUFHYTtRQUNmO1FBRUE7OztLQUdDLEdBQ0RWLDhCQUE4QnFCLE9BQU8sR0FBRztZQUN0QyxNQUFPLElBQUksQ0FBQ3RCLEtBQUssQ0FBQytCLE1BQU0sR0FBRyxFQUFHO2dCQUM1QixJQUFJVixPQUFPLElBQUksQ0FBQ3JCLEtBQUssQ0FBQ2dDLElBQUk7Z0JBQzFCLElBQUlYLEtBQUtZLFdBQVcsSUFBSTtvQkFDdEIsSUFBSSxDQUFDakMsS0FBSyxDQUFDa0MsT0FBTztnQkFDcEIsT0FBTztvQkFDTCxPQUFPYjtnQkFDVDtZQUNGO1lBQ0EsT0FBTztRQUNUO1FBRUE7Ozs7OztLQU1DLEdBQ0RwQiw4QkFBOEJPLGdCQUFnQixHQUFHLFNBQVVGLEtBQUssRUFBRUksT0FBTyxFQUFFSCxNQUFNO1lBQy9FLElBQUlwQyxRQUFPLElBQUk7WUFFZixTQUFTZ0UsSUFBSUMsU0FBUyxFQUFFQyxNQUFNO2dCQUM1QmxFLE1BQUs2QixLQUFLLENBQUNzQyxNQUFNLENBQUNDO2dCQUNsQixPQUFPaEMsT0FBTzZCLFdBQVdDO1lBQzNCO1lBRUEsSUFBSUUsS0FBSyxJQUFJckQsY0FBYyxJQUFJLEVBQUVvQixPQUFPNkIsS0FBS3pCLFNBQVMsSUFBSSxDQUFDYixRQUFRO1lBQ25FLElBQUksQ0FBQ0csS0FBSyxDQUFDd0MsT0FBTyxDQUFDRDtZQUVuQixPQUFPQSxHQUFHRSxVQUFVO1FBQ3RCO1FBRUEsT0FBTy9DO0lBQ1QsRUFBRVQ7SUFFRixxR0FBcUcsR0FDckdMLEdBQUc4RCxtQkFBbUIsR0FBSSxTQUFVL0MsU0FBUztRQUMzQ0wsU0FBU29ELHFCQUFxQi9DO1FBRTlCOzs7OztLQUtDLEdBQ0QsU0FBUytDLG9CQUFvQjlDLFlBQVksRUFBRUMsUUFBUTtZQUNqRCxJQUFJQyxRQUFRRixnQkFBZ0IsT0FBTyxJQUFJQTtZQUN2QyxJQUFJK0MsTUFBTTlDLFlBQVlOO1lBQ3RCSSxVQUFVYixJQUFJLENBQUMsSUFBSSxFQUFFZ0IsT0FBTzZDO1FBQzlCO1FBRUEsSUFBSUMsMkJBQTJCRixvQkFBb0J4QyxTQUFTO1FBRTVEOzs7OztLQUtDLEdBQ0QwQyx5QkFBeUI3QixHQUFHLEdBQUcsU0FBVThCLFFBQVEsRUFBRUMsUUFBUTtZQUN6RCxPQUFPRCxXQUFXQztRQUNwQjtRQUVBRix5QkFBeUJ4QyxjQUFjLEdBQUcsU0FBVXlDLFFBQVE7WUFDMUQsT0FBTyxJQUFJakMsS0FBS2lDLFVBQVVFLE9BQU87UUFDbkM7UUFFQTs7Ozs7S0FLQyxHQUNESCx5QkFBeUIvQixjQUFjLEdBQUcsU0FBVW1DLFFBQVE7WUFDMUQsT0FBT0E7UUFDVDtRQUVBLE9BQU9OO0lBQ1QsRUFBRTlELEdBQUdjLG9CQUFvQjtJQUV6QixPQUFPZDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9kaXN0L3J4LnZpcnR1YWx0aW1lLmpzPzdhM2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQsIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLk9iamVjdCA9PT0gT2JqZWN0KSA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIHZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkgPyBleHBvcnRzIDogbnVsbDtcbiAgdmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpID8gbW9kdWxlIDogbnVsbDtcbiAgdmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCk7XG4gIHZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcbiAgdmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IChmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpID8gZnJlZUV4cG9ydHMgOiBudWxsO1xuICB2YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLy8gQmVjYXVzZSBvZiBidWlsZCBvcHRpbWl6ZXJzXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWycuL3J4J10sIGZ1bmN0aW9uIChSeCwgZXhwb3J0cykge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgUngpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCwgbW9kdWxlLmV4cG9ydHMsIHJlcXVpcmUoJy4vcngnKSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5SeCA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuUngpO1xuICB9XG59LmNhbGwodGhpcywgZnVuY3Rpb24gKHJvb3QsIGV4cCwgUngsIHVuZGVmaW5lZCkge1xuXG4gIC8vIEFsaWFzZXNcbiAgdmFyIFNjaGVkdWxlciA9IFJ4LlNjaGVkdWxlcixcbiAgICBTY2hlZHVsZWRJdGVtID0gUnguaW50ZXJuYWxzLlNjaGVkdWxlZEl0ZW0sXG4gICAgU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZSAgPSBSeC5pbnRlcm5hbHMuU2NoZWR1bGVQZXJpb2RpY1JlY3Vyc2l2ZSxcbiAgICBQcmlvcml0eVF1ZXVlID0gUnguaW50ZXJuYWxzLlByaW9yaXR5UXVldWUsXG4gICAgaW5oZXJpdHMgPSBSeC5pbnRlcm5hbHMuaW5oZXJpdHMsXG4gICAgZGVmYXVsdFN1YkNvbXBhcmVyID0gUnguaGVscGVycy5kZWZhdWx0U3ViQ29tcGFyZXIsXG4gICAgbm90SW1wbGVtZW50ZWQgPSBSeC5oZWxwZXJzLm5vdEltcGxlbWVudGVkO1xuXG4gIC8qKiBQcm92aWRlcyBhIHNldCBvZiBleHRlbnNpb24gbWV0aG9kcyBmb3IgdmlydHVhbCB0aW1lIHNjaGVkdWxpbmcuICovXG4gIHZhciBWaXJ0dWFsVGltZVNjaGVkdWxlciA9IFJ4LlZpcnR1YWxUaW1lU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhWaXJ0dWFsVGltZVNjaGVkdWxlciwgX19zdXBlcl9fKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmlydHVhbCB0aW1lIHNjaGVkdWxlciB3aXRoIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCBjbG9jayB2YWx1ZSBhbmQgYWJzb2x1dGUgdGltZSBjb21wYXJlci5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbml0aWFsQ2xvY2sgSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIENvbXBhcmVyIHRvIGRldGVybWluZSBjYXVzYWxpdHkgb2YgZXZlbnRzIGJhc2VkIG9uIGFic29sdXRlIHRpbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlydHVhbFRpbWVTY2hlZHVsZXIoaW5pdGlhbENsb2NrLCBjb21wYXJlcikge1xuICAgICAgdGhpcy5jbG9jayA9IGluaXRpYWxDbG9jaztcbiAgICAgIHRoaXMuY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoMTAyNCk7XG4gICAgICBfX3N1cGVyX18uY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUgPSBWaXJ0dWFsVGltZVNjaGVkdWxlci5wcm90b3R5cGU7XG5cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0Fic29sdXRlVGltZSh0aGlzLmNsb2NrKTtcbiAgICB9O1xuXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVBYnNvbHV0ZShzdGF0ZSwgdGhpcy5jbG9jaywgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2NoZWR1bGVGdXR1cmUgPSBmdW5jdGlvbiAoc3RhdGUsIGR1ZVRpbWUsIGFjdGlvbikge1xuICAgICAgdmFyIGR0ID0gZHVlVGltZSBpbnN0YW5jZW9mIERhdGUgP1xuICAgICAgICB0aGlzLnRvUmVsYXRpdmVUaW1lKGR1ZVRpbWUgLSB0aGlzLm5vdygpKSA6XG4gICAgICAgIHRoaXMudG9SZWxhdGl2ZVRpbWUoZHVlVGltZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlUmVsYXRpdmUoc3RhdGUsIGR0LCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVsYXRpdmUgdGltZSB2YWx1ZSB0byBhbiBhYnNvbHV0ZSB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhYnNvbHV0ZSBBYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF0aXZlIFJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZSB0byBhZGQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBSZXN1bHRpbmcgYWJzb2x1dGUgdmlydHVhbCB0aW1lIHN1bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5hZGQgPSBub3RJbXBsZW1lbnRlZDtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGFic29sdXRlIHRpbWUgdG8gYSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge0FueX0gVGhlIGFic29sdXRlIHRpbWUuXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGFic29sdXRlIHRpbWUgaW4gbXNcbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS50b0Fic29sdXRlVGltZSA9IG5vdEltcGxlbWVudGVkO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIFRpbWVTcGFuIHZhbHVlIHRvIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lU3BhbiBUaW1lU3BhbiB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ29ycmVzcG9uZGluZyByZWxhdGl2ZSB2aXJ0dWFsIHRpbWUgdmFsdWUuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUudG9SZWxhdGl2ZVRpbWUgPSBub3RJbXBsZW1lbnRlZDtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHBlcmlvZGljIHBpZWNlIG9mIHdvcmsgYnkgZHluYW1pY2FsbHkgZGlzY292ZXJpbmcgdGhlIHNjaGVkdWxlcidzIGNhcGFiaWxpdGllcy4gVGhlIHBlcmlvZGljIHRhc2sgd2lsbCBiZSBlbXVsYXRlZCB1c2luZyByZWN1cnNpdmUgc2NoZWR1bGluZy5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBJbml0aWFsIHN0YXRlIHBhc3NlZCB0byB0aGUgYWN0aW9uIHVwb24gdGhlIGZpcnN0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kIFBlcmlvZCBmb3IgcnVubmluZyB0aGUgd29yayBwZXJpb2RpY2FsbHkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZCwgcG90ZW50aWFsbHkgdXBkYXRpbmcgdGhlIHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCByZWN1cnJpbmcgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2NoZWR1bGVQZXJpb2RpYyA9IGZ1bmN0aW9uIChzdGF0ZSwgcGVyaW9kLCBhY3Rpb24pIHtcbiAgICAgIHZhciBzID0gbmV3IFNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUodGhpcywgc3RhdGUsIHBlcmlvZCwgYWN0aW9uKTtcbiAgICAgIHJldHVybiBzLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZHVlVGltZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBzdGF0ZSBTdGF0ZSBwYXNzZWQgdG8gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHVlVGltZSBSZWxhdGl2ZSB0aW1lIGFmdGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEByZXR1cm5zIHtEaXNwb3NhYmxlfSBUaGUgZGlzcG9zYWJsZSBvYmplY3QgdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBhY3Rpb24gKGJlc3QgZWZmb3J0KS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zY2hlZHVsZVJlbGF0aXZlID0gZnVuY3Rpb24gKHN0YXRlLCBkdWVUaW1lLCBhY3Rpb24pIHtcbiAgICAgIHZhciBydW5BdCA9IHRoaXMuYWRkKHRoaXMuY2xvY2ssIGR1ZVRpbWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVBYnNvbHV0ZShzdGF0ZSwgcnVuQXQsIGFjdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdmlydHVhbCB0aW1lIHNjaGVkdWxlci5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJlcihuZXh0LmR1ZVRpbWUsIHRoaXMuY2xvY2spID4gMCAmJiAodGhpcy5jbG9jayA9IG5leHQuZHVlVGltZSk7XG4gICAgICAgICAgICBuZXh0Lmludm9rZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodGhpcy5pc0VuYWJsZWQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgdmlydHVhbCB0aW1lIHNjaGVkdWxlci5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdGhlIHNjaGVkdWxlcidzIGNsb2NrIHRvIHRoZSBzcGVjaWZpZWQgdGltZSwgcnVubmluZyBhbGwgd29yayB0aWxsIHRoYXQgcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgQWJzb2x1dGUgdGltZSB0byBhZHZhbmNlIHRoZSBzY2hlZHVsZXIncyBjbG9jayB0by5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5hZHZhbmNlVG8gPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgdmFyIGR1ZVRvQ2xvY2sgPSB0aGlzLmNvbXBhcmVyKHRoaXMuY2xvY2ssIHRpbWUpO1xuICAgICAgaWYgKHRoaXMuY29tcGFyZXIodGhpcy5jbG9jaywgdGltZSkgPiAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgICBpZiAoZHVlVG9DbG9jayA9PT0gMCkgeyByZXR1cm47IH1cbiAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dCAhPT0gbnVsbCAmJiB0aGlzLmNvbXBhcmVyKG5leHQuZHVlVGltZSwgdGltZSkgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJlcihuZXh0LmR1ZVRpbWUsIHRoaXMuY2xvY2spID4gMCAmJiAodGhpcy5jbG9jayA9IG5leHQuZHVlVGltZSk7XG4gICAgICAgICAgICBuZXh0Lmludm9rZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodGhpcy5pc0VuYWJsZWQpO1xuICAgICAgICB0aGlzLmNsb2NrID0gdGltZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdGhlIHNjaGVkdWxlcidzIGNsb2NrIGJ5IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgdGltZSwgcnVubmluZyBhbGwgd29yayBzY2hlZHVsZWQgZm9yIHRoYXQgdGltZXNwYW4uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgUmVsYXRpdmUgdGltZSB0byBhZHZhbmNlIHRoZSBzY2hlZHVsZXIncyBjbG9jayBieS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5hZHZhbmNlQnkgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgdmFyIGR0ID0gdGhpcy5hZGQodGhpcy5jbG9jaywgdGltZSksXG4gICAgICAgICAgZHVlVG9DbG9jayA9IHRoaXMuY29tcGFyZXIodGhpcy5jbG9jaywgZHQpO1xuICAgICAgaWYgKGR1ZVRvQ2xvY2sgPiAwKSB7IHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpOyB9XG4gICAgICBpZiAoZHVlVG9DbG9jayA9PT0gMCkgeyAgcmV0dXJuOyB9XG5cbiAgICAgIHRoaXMuYWR2YW5jZVRvKGR0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdGhlIHNjaGVkdWxlcidzIGNsb2NrIGJ5IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBSZWxhdGl2ZSB0aW1lIHRvIGFkdmFuY2UgdGhlIHNjaGVkdWxlcidzIGNsb2NrIGJ5LlxuICAgICAqL1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHZhciBkdCA9IHRoaXMuYWRkKHRoaXMuY2xvY2ssIHRpbWUpO1xuICAgICAgaWYgKHRoaXMuY29tcGFyZXIodGhpcy5jbG9jaywgZHQpID49IDApIHsgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7IH1cblxuICAgICAgdGhpcy5jbG9jayA9IGR0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHNjaGVkdWxlZCBpdGVtIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEByZXR1cm5zIHtTY2hlZHVsZWRJdGVtfSBUaGUgbmV4dCBzY2hlZHVsZWQgaXRlbS5cbiAgICAgKi9cbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlclByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMucXVldWUucGVlaygpO1xuICAgICAgICBpZiAobmV4dC5pc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gYWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGF0IGR1ZVRpbWUuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gc3RhdGUgU3RhdGUgcGFzc2VkIHRvIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1ZVRpbWUgQWJzb2x1dGUgdGltZSBhdCB3aGljaCB0byBleGVjdXRlIHRoZSBhY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJucyB7RGlzcG9zYWJsZX0gVGhlIGRpc3Bvc2FibGUgb2JqZWN0IHVzZWQgdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgYWN0aW9uIChiZXN0IGVmZm9ydCkuXG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXJQcm90b3R5cGUuc2NoZWR1bGVBYnNvbHV0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZHVlVGltZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bihzY2hlZHVsZXIsIHN0YXRlMSkge1xuICAgICAgICBzZWxmLnF1ZXVlLnJlbW92ZShzaSk7XG4gICAgICAgIHJldHVybiBhY3Rpb24oc2NoZWR1bGVyLCBzdGF0ZTEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2kgPSBuZXcgU2NoZWR1bGVkSXRlbSh0aGlzLCBzdGF0ZSwgcnVuLCBkdWVUaW1lLCB0aGlzLmNvbXBhcmVyKTtcbiAgICAgIHRoaXMucXVldWUuZW5xdWV1ZShzaSk7XG5cbiAgICAgIHJldHVybiBzaS5kaXNwb3NhYmxlO1xuICAgIH07XG5cbiAgICByZXR1cm4gVmlydHVhbFRpbWVTY2hlZHVsZXI7XG4gIH0oU2NoZWR1bGVyKSk7XG5cbiAgLyoqIFByb3ZpZGVzIGEgdmlydHVhbCB0aW1lIHNjaGVkdWxlciB0aGF0IHVzZXMgRGF0ZSBmb3IgYWJzb2x1dGUgdGltZSBhbmQgbnVtYmVyIGZvciByZWxhdGl2ZSB0aW1lLiAqL1xuICBSeC5IaXN0b3JpY2FsU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfX3N1cGVyX18pIHtcbiAgICBpbmhlcml0cyhIaXN0b3JpY2FsU2NoZWR1bGVyLCBfX3N1cGVyX18pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBoaXN0b3JpY2FsIHNjaGVkdWxlciB3aXRoIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCBjbG9jayB2YWx1ZS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5pdGlhbENsb2NrIEluaXRpYWwgdmFsdWUgZm9yIHRoZSBjbG9jay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBDb21wYXJlciB0byBkZXRlcm1pbmUgY2F1c2FsaXR5IG9mIGV2ZW50cyBiYXNlZCBvbiBhYnNvbHV0ZSB0aW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhpc3RvcmljYWxTY2hlZHVsZXIoaW5pdGlhbENsb2NrLCBjb21wYXJlcikge1xuICAgICAgdmFyIGNsb2NrID0gaW5pdGlhbENsb2NrID09IG51bGwgPyAwIDogaW5pdGlhbENsb2NrO1xuICAgICAgdmFyIGNtcCA9IGNvbXBhcmVyIHx8IGRlZmF1bHRTdWJDb21wYXJlcjtcbiAgICAgIF9fc3VwZXJfXy5jYWxsKHRoaXMsIGNsb2NrLCBjbXApO1xuICAgIH1cblxuICAgIHZhciBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8gPSBIaXN0b3JpY2FsU2NoZWR1bGVyLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZWxhdGl2ZSB0aW1lIHZhbHVlIHRvIGFuIGFic29sdXRlIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFic29sdXRlIEFic29sdXRlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXRpdmUgUmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJlc3VsdGluZyBhYnNvbHV0ZSB2aXJ0dWFsIHRpbWUgc3VtIHZhbHVlLlxuICAgICAqL1xuICAgIEhpc3RvcmljYWxTY2hlZHVsZXJQcm90by5hZGQgPSBmdW5jdGlvbiAoYWJzb2x1dGUsIHJlbGF0aXZlKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGUgKyByZWxhdGl2ZTtcbiAgICB9O1xuXG4gICAgSGlzdG9yaWNhbFNjaGVkdWxlclByb3RvLnRvQWJzb2x1dGVUaW1lID0gZnVuY3Rpb24gKGFic29sdXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYWJzb2x1dGUpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIFRpbWVTcGFuIHZhbHVlIHRvIGEgcmVsYXRpdmUgdmlydHVhbCB0aW1lIHZhbHVlLlxuICAgICAqIEBtZW1iZXJPZiBIaXN0b3JpY2FsU2NoZWR1bGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTcGFuIFRpbWVTcGFuIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDb3JyZXNwb25kaW5nIHJlbGF0aXZlIHZpcnR1YWwgdGltZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIaXN0b3JpY2FsU2NoZWR1bGVyUHJvdG8udG9SZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiAodGltZVNwYW4pIHtcbiAgICAgIHJldHVybiB0aW1lU3BhbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhpc3RvcmljYWxTY2hlZHVsZXI7XG4gIH0oUnguVmlydHVhbFRpbWVTY2hlZHVsZXIpKTtcblxuICByZXR1cm4gUng7XG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsIm9iamVjdFR5cGVzIiwiY2hlY2tHbG9iYWwiLCJ2YWx1ZSIsIk9iamVjdCIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJmcmVlV2luZG93Iiwid2luZG93IiwibW9kdWxlRXhwb3J0cyIsInRoaXNHbG9iYWwiLCJyb290IiwiRnVuY3Rpb24iLCJkZWZpbmUiLCJhbWQiLCJSeCIsInJlcXVpcmUiLCJjYWxsIiwiZXhwIiwidW5kZWZpbmVkIiwiU2NoZWR1bGVyIiwiU2NoZWR1bGVkSXRlbSIsImludGVybmFscyIsIlNjaGVkdWxlUGVyaW9kaWNSZWN1cnNpdmUiLCJQcmlvcml0eVF1ZXVlIiwiaW5oZXJpdHMiLCJkZWZhdWx0U3ViQ29tcGFyZXIiLCJoZWxwZXJzIiwibm90SW1wbGVtZW50ZWQiLCJWaXJ0dWFsVGltZVNjaGVkdWxlciIsIl9fc3VwZXJfXyIsImluaXRpYWxDbG9jayIsImNvbXBhcmVyIiwiY2xvY2siLCJpc0VuYWJsZWQiLCJxdWV1ZSIsIlZpcnR1YWxUaW1lU2NoZWR1bGVyUHJvdG90eXBlIiwicHJvdG90eXBlIiwibm93IiwidG9BYnNvbHV0ZVRpbWUiLCJzY2hlZHVsZSIsInN0YXRlIiwiYWN0aW9uIiwic2NoZWR1bGVBYnNvbHV0ZSIsInNjaGVkdWxlRnV0dXJlIiwiZHVlVGltZSIsImR0IiwiRGF0ZSIsInRvUmVsYXRpdmVUaW1lIiwic2NoZWR1bGVSZWxhdGl2ZSIsImFkZCIsInNjaGVkdWxlUGVyaW9kaWMiLCJwZXJpb2QiLCJzIiwic3RhcnQiLCJydW5BdCIsIm5leHQiLCJnZXROZXh0IiwiaW52b2tlIiwic3RvcCIsImFkdmFuY2VUbyIsInRpbWUiLCJkdWVUb0Nsb2NrIiwiQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IiLCJhZHZhbmNlQnkiLCJzbGVlcCIsImxlbmd0aCIsInBlZWsiLCJpc0NhbmNlbGxlZCIsImRlcXVldWUiLCJydW4iLCJzY2hlZHVsZXIiLCJzdGF0ZTEiLCJyZW1vdmUiLCJzaSIsImVucXVldWUiLCJkaXNwb3NhYmxlIiwiSGlzdG9yaWNhbFNjaGVkdWxlciIsImNtcCIsIkhpc3RvcmljYWxTY2hlZHVsZXJQcm90byIsImFic29sdXRlIiwicmVsYXRpdmUiLCJnZXRUaW1lIiwidGltZVNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/dist/rx.virtualtime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rx/index.js":
/*!**********************************!*\
  !*** ./node_modules/rx/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Rx = __webpack_require__(/*! ./dist/rx */ \"(ssr)/./node_modules/rx/dist/rx.js\");\n__webpack_require__(/*! ./dist/rx.aggregates */ \"(ssr)/./node_modules/rx/dist/rx.aggregates.js\");\n__webpack_require__(/*! ./dist/rx.async */ \"(ssr)/./node_modules/rx/dist/rx.async.js\");\n__webpack_require__(/*! ./dist/rx.backpressure */ \"(ssr)/./node_modules/rx/dist/rx.backpressure.js\");\n__webpack_require__(/*! ./dist/rx.binding */ \"(ssr)/./node_modules/rx/dist/rx.binding.js\");\n__webpack_require__(/*! ./dist/rx.coincidence */ \"(ssr)/./node_modules/rx/dist/rx.coincidence.js\");\n__webpack_require__(/*! ./dist/rx.experimental */ \"(ssr)/./node_modules/rx/dist/rx.experimental.js\");\n__webpack_require__(/*! ./dist/rx.joinpatterns */ \"(ssr)/./node_modules/rx/dist/rx.joinpatterns.js\");\n__webpack_require__(/*! ./dist/rx.sorting */ \"(ssr)/./node_modules/rx/dist/rx.sorting.js\");\n__webpack_require__(/*! ./dist/rx.virtualtime */ \"(ssr)/./node_modules/rx/dist/rx.virtualtime.js\");\n__webpack_require__(/*! ./dist/rx.testing */ \"(ssr)/./node_modules/rx/dist/rx.testing.js\");\n__webpack_require__(/*! ./dist/rx.time */ \"(ssr)/./node_modules/rx/dist/rx.time.js\");\nmodule.exports = Rx;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcngvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ2pCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSQyxPQUFPQyxPQUFPLEdBQUdIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VydmVyLWFjdGlvbi8uL25vZGVfbW9kdWxlcy9yeC9pbmRleC5qcz83MWI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBSeCA9IHJlcXVpcmUoJy4vZGlzdC9yeCcpO1xucmVxdWlyZSgnLi9kaXN0L3J4LmFnZ3JlZ2F0ZXMnKTtcbnJlcXVpcmUoJy4vZGlzdC9yeC5hc3luYycpO1xucmVxdWlyZSgnLi9kaXN0L3J4LmJhY2twcmVzc3VyZScpO1xucmVxdWlyZSgnLi9kaXN0L3J4LmJpbmRpbmcnKTtcbnJlcXVpcmUoJy4vZGlzdC9yeC5jb2luY2lkZW5jZScpO1xucmVxdWlyZSgnLi9kaXN0L3J4LmV4cGVyaW1lbnRhbCcpO1xucmVxdWlyZSgnLi9kaXN0L3J4LmpvaW5wYXR0ZXJucycpO1xucmVxdWlyZSgnLi9kaXN0L3J4LnNvcnRpbmcnKTtcbnJlcXVpcmUoJy4vZGlzdC9yeC52aXJ0dWFsdGltZScpO1xucmVxdWlyZSgnLi9kaXN0L3J4LnRlc3RpbmcnKTtcbnJlcXVpcmUoJy4vZGlzdC9yeC50aW1lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUng7XG4iXSwibmFtZXMiOlsiUngiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rx/index.js\n");

/***/ })

};
;